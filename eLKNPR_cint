# 1 "/scratch/condor/dir_19652/QCBAeV_cint.cxx"
# 1 "<command-line>"
# 1 "/scratch/condor/dir_19652/QCBAeV_cint.cxx"
# 1 "/tmp/rootcint_85GekZ.h" 1
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TObject.h" 1
// @(#)root/base:$Id: TObject.h 38832 2011-04-13 17:54:49Z rdm $
// Author: Rene Brun   26/12/94

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/





//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TObject                                                              //
//                                                                      //
// Mother of all ROOT objects.                                          //
//                                                                      //
// The TObject class provides default behaviour and protocol for all    //
// objects in the ROOT system. It provides protocol for object I/O,     //
// error handling, sorting, inspection, printing, drawing, etc.         //
// Every object which inherits from TObject can be stored in the        //
// ROOT collection classes.                                             //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h" 1
/* @(#)root/base:$Id: Rtypes.h 43708 2012-04-12 10:19:00Z axel $ */

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/




//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Rtypes                                                               //
//                                                                      //
// Basic types used by ROOT.                                            //
//                                                                      //
//////////////////////////////////////////////////////////////////////////



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/RConfig.h" 1
/* @(#)root/base:$Id: RConfig.h 43709 2012-04-12 11:04:01Z rdm $ */

/*************************************************************************
 * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/




/*************************************************************************
 *                                                                       *
 * RConfig                                                               *
 *                                                                       *
 * Defines used by ROOT.                                                 *
 *                                                                       *
 *************************************************************************/


# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/RVersion.h" 1



/* Version information automatically generated by installer. */

/*
 * These macros can be used in the following way:
 *
 *    #if ROOT_VERSION_CODE >= ROOT_VERSION(2,23,4)
 *       #include <newheader.h>
 *    #else
 *       #include <oldheader.h>
 *    #endif
 *
*/
# 24 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/RConfig.h" 2



/*---- new C++ features ------------------------------------------------------*/



/*---- machines --------------------------------------------------------------*/
# 181 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/RConfig.h"
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/external/gcc/4.7.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include-fixed/features.h" 1 3 4
/*  DO NOT EDIT THIS FILE.

    It has been auto-edited by fixincludes from:

	"/usr/include/features.h"

    This had to be done to correct non-standard usages in the
    original, manufacturer supplied header file.  */

/* Copyright (C) 1991,1992,1993,1995,1996,1997,1998,1999,2000,2001,2002,2003,2004,2005,2006
	Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */




/* These are defined by the user (or the compiler)
   to specify the desired environment:

   __STRICT_ANSI__	ISO Standard C.
   _ISOC99_SOURCE	Extensions to ISO C89 from ISO C99.
   _POSIX_SOURCE	IEEE Std 1003.1.
   _POSIX_C_SOURCE	If ==1, like _POSIX_SOURCE; if >=2 add IEEE Std 1003.2;
			if >=199309L, add IEEE Std 1003.1b-1993;
			if >=199506L, add IEEE Std 1003.1c-1995;
			if >=200112L, all of IEEE 1003.1-2004
   _XOPEN_SOURCE	Includes POSIX and XPG things.  Set to 500 if
			Single Unix conformance is wanted, to 600 for the
			upcoming sixth revision.
   _XOPEN_SOURCE_EXTENDED XPG things and X/Open Unix extensions.
   _LARGEFILE_SOURCE	Some more functions for correct standard I/O.
   _LARGEFILE64_SOURCE	Additional functionality from LFS for large files.
   _FILE_OFFSET_BITS=N	Select default filesystem interface.
   _BSD_SOURCE		ISO C, POSIX, and 4.3BSD things.
   _SVID_SOURCE		ISO C, POSIX, and SVID things.
   _ATFILE_SOURCE	Additional *at interfaces.
   _GNU_SOURCE		All of the above, plus GNU extensions.
   _REENTRANT		Select additionally reentrant object.
   _THREAD_SAFE		Same as _REENTRANT, often used by other systems.
   _FORTIFY_SOURCE	If set to numeric value > 0 additional security
			measures are defined, according to level.

   The `-ansi' switch to the GNU C compiler defines __STRICT_ANSI__.
   If none of these are defined, the default is to have _SVID_SOURCE,
   _BSD_SOURCE, and _POSIX_SOURCE set to one and _POSIX_C_SOURCE set to
   200112L.  If more than one of these are defined, they accumulate.
   For example __STRICT_ANSI__, _POSIX_SOURCE and _POSIX_C_SOURCE
   together give you ISO C, 1003.1, and 1003.2, but nothing else.

   These are defined by this file and are used by the
   header files to decide what to declare or define:

   __USE_ISOC99		Define ISO C99 things.
   __USE_POSIX		Define IEEE Std 1003.1 things.
   __USE_POSIX2		Define IEEE Std 1003.2 things.
   __USE_POSIX199309	Define IEEE Std 1003.1, and .1b things.
   __USE_POSIX199506	Define IEEE Std 1003.1, .1b, .1c and .1i things.
   __USE_XOPEN		Define XPG things.
   __USE_XOPEN_EXTENDED	Define X/Open Unix things.
   __USE_UNIX98		Define Single Unix V2 things.
   __USE_XOPEN2K        Define XPG6 things.
   __USE_LARGEFILE	Define correct standard I/O things.
   __USE_LARGEFILE64	Define LFS things with separate names.
   __USE_FILE_OFFSET64	Define 64bit interface as default.
   __USE_BSD		Define 4.3BSD things.
   __USE_SVID		Define SVID things.
   __USE_MISC		Define things common to BSD and System V Unix.
   __USE_ATFILE		Define *at interfaces and AT_* constants for them.
   __USE_GNU		Define GNU extensions.
   __USE_REENTRANT	Define reentrant/thread-safe *_r functions.
   __USE_FORTIFY_LEVEL	Additional security measures used, according to level.
   __FAVOR_BSD		Favor 4.3BSD things in cases of conflict.

   The macros `__GNU_LIBRARY__', `__GLIBC__', and `__GLIBC_MINOR__' are
   defined by this file unconditionally.  `__GNU_LIBRARY__' is provided
   only for compatibility.  All new code should use the other symbols
   to test for features.

   All macros listed above as possibly being defined by this file are
   explicitly undefined if they are not explicitly defined.
   Feature-test macros that are not defined by the user or compiler
   but are implied by the other feature-test macros defined (or by the
   lack of any definitions) are defined by the file.  */


/* Undefine everything, so we get a clean slate.  */
# 124 "/hpc/software/tier3/osg/slc5_amd64_gcc472/external/gcc/4.7.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include-fixed/features.h" 3 4
/* Suppress kernel-name space pollution unless user expressedly asks
   for it.  */




/* Always use ISO C things.  */


/* Convenience macros to test the versions of glibc and gcc.
   Use them like this:
   #if __GNUC_PREREQ (2,8)
   ... code requiring gcc 2.8 or later ...
   #endif
   Note - they won't work for gcc1 or glibc1, since the _MINOR macros
   were not defined then.  */
# 148 "/hpc/software/tier3/osg/slc5_amd64_gcc472/external/gcc/4.7.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include-fixed/features.h" 3 4
/* If _BSD_SOURCE was defined by the user, favor BSD over POSIX.  */







/* If _GNU_SOURCE was defined by the user, turn on all the other features.  */
# 178 "/hpc/software/tier3/osg/slc5_amd64_gcc472/external/gcc/4.7.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include-fixed/features.h" 3 4
/* If nothing (other than _GNU_SOURCE) is defined,
   define _BSD_SOURCE and _SVID_SOURCE.  */
# 188 "/hpc/software/tier3/osg/slc5_amd64_gcc472/external/gcc/4.7.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include-fixed/features.h" 3 4
/* This is to enable the ISO C99 extension.  Also recognize the old macro
   which was used prior to the standard acceptance.  This macro will
   eventually go away and the features enabled by default once the ISO C99
   standard is widely adopted.  */





/* If none of the ANSI/POSIX macros are defined, use POSIX.1 and POSIX.2
   (and IEEE Std 1003.1b-1993 unless _XOPEN_SOURCE is defined).  */
# 303 "/hpc/software/tier3/osg/slc5_amd64_gcc472/external/gcc/4.7.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include-fixed/features.h" 3 4
/* We do support the IEC 559 math functionality, real and complex.  */



/* wchar_t uses ISO 10646-1 (2nd ed., published 2000-09-15) / Unicode 3.1.  */


/* This macro indicates that the installed library is the GNU C Library.
   For historic reasons the value now is 6 and this will stay from now
   on.  The use of this variable is deprecated.  Use __GLIBC__ and
   __GLIBC_MINOR__ now (see below) when you want to test for a specific
   GNU C library version and use the values in <gnu/lib-names.h> to get
   the sonames of the shared libraries.  */



/* Major and minor version number of the GNU C library package.  Use
   these macros to test for features in specific releases.  */






/* Decide whether a compiler supports the long long datatypes.  */







/* This is here only because every header file already includes this one.  */


# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/sys/cdefs.h" 1 3 4
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/



/* Using external C/C++ preprocessor with -p or +P option */

# 1 "/usr/include/sys/cdefs.h" 1 3 4
/* Copyright (C) 1992-2001, 2002, 2004, 2005, 2006, 2007, 2009
   Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */




/* We are almost always included from features.h. */




/* The GNU libc does not support any K&R compilers or the traditional mode
   of ISO C compilers anymore.  Check for some of the combinations not
   anymore supported.  */




/* Some user header file might have defined this before.  */





/* GCC can always grok prototypes.  For C++ programs we add throw()
   to help it optimize the function calls.  But this works only with
   gcc 2.8.x and egcs.  For gcc 3.2 and up we even mark C functions
   as non-throwing using a function attribute since programs can use
   the -fexceptions options for C code as well.  */
# 72 "/usr/include/sys/cdefs.h" 3 4
/* These two macros are not used in glibc anymore.  They are kept here
   only because some other projects expect the macros to be defined.  */



/* For these things, GCC behaves the ANSI way normally,
   and the non-ANSI way under -traditional.  */




/* This is not a typedef so `const __ptr_t' does the right thing.  */




/* C++ needs to know that types and declarations are C, not C++.  */
# 98 "/usr/include/sys/cdefs.h" 3 4
/* The standard library needs the functions from the ISO C90 standard
   in the std namespace.  At the same time we want to be safe for
   future changes and we include the ISO C99 code in the non-standard
   namespace __c99.  The C++ wrapper header take case of adding the
   definitions to the global namespace.  */
# 111 "/usr/include/sys/cdefs.h" 3 4
/* For compatibility we do not add the declarations into any
   namespace.  They will end up in the global namespace which is what
   old code expects.  */
# 123 "/usr/include/sys/cdefs.h" 3 4
/* Support for bounded pointers.  */







/* Fortify support.  */
# 150 "/usr/include/sys/cdefs.h" 3 4
/* Support for flexible arrays.  */

/* GCC 2.97 supports C99 flexible array members.  */
# 168 "/usr/include/sys/cdefs.h" 3 4
/* __asm__ ("xyz") is used throughout the headers to rename functions
   at the assembly language level.  This is wrapped by the __REDIRECT
   macro, in order to support compilers that can do this some other
   way.  When compilers don't support asm-names at all, we have to do
   preprocessor tricks instead (which don't have exactly the right
   semantics, but it's the best we can do).

   Example:
   int __REDIRECT(setpgrp, (__pid_t pid, __pid_t pgrp), setpgid); */
# 191 "/usr/include/sys/cdefs.h" 3 4
/*
#elif __SOME_OTHER_COMPILER__

# define __REDIRECT(name, proto, alias) name proto; 	_Pragma("let " #name " = " #alias)
)
*/


/* GCC has various useful declarations that can be made with the
   `__attribute__' syntax.  All of the ways we use this do fine if
   they are omitted for compilers that don't understand it. */




/* At some point during the gcc 2.96 development the `malloc' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.  */






/* At some point during the gcc 2.96 development the `pure' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.  */






/* At some point during the gcc 3.1 development the `used' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.  */
# 235 "/usr/include/sys/cdefs.h" 3 4
/* gcc allows marking deprecated functions.  */






/* At some point during the gcc 2.8 development the `format_arg' attribute
   for functions was introduced.  We don't want to use it unconditionally
   (although this would be possible) since it generates warnings.
   If several `format_arg' attributes are given for the same function, in
   gcc-3.0 and older, all but the last one are ignored.  In newer gccs,
   all designated arguments are considered.  */






/* At some point during the gcc 2.97 development the `strfmon' format
   attribute for functions was introduced.  We don't want to use it
   unconditionally (although this would be possible) since it
   generates warnings.  */







/* The nonull function attribute allows to mark pointer parameters which
   must not be NULL.  */






/* If fortification mode, we warn about unused results of certain
   function calls which can lead to problems.  */
# 288 "/usr/include/sys/cdefs.h" 3 4
/* Forces a function to be always inlined.  */






/* GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
   inline semantics, unless -fgnu89-inline is used.  */
# 324 "/usr/include/sys/cdefs.h" 3 4
/* GCC 4.3 and above allow passing all anonymous arguments of an
   __extern_always_inline function to some other vararg function.  */
# 334 "/usr/include/sys/cdefs.h" 3 4
/* It is possible to compile containing GCC extensions even if GCC is
   run in pedantic mode if the uses are carefully marked using the
   `__extension__' keyword.  But this is not generally available before
   version 2.8.  */




/* __restrict is known in EGCS 1.2 and above. */




/* ISO C99 also allows to declare arrays as non-overlapping.  The syntax is
     array_name[restrict]
   GCC 3.1 supports this.  */
# 365 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 366 "/usr/include/sys/cdefs.h" 2 3 4
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/sys/cdefs.h" 2 3 4
# 339 "/hpc/software/tier3/osg/slc5_amd64_gcc472/external/gcc/4.7.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include-fixed/features.h" 2 3 4


/* If we don't have __REDIRECT, prototypes will be missing if
   __USE_FILE_OFFSET64 but not __USE_LARGEFILE[64]. */







/* Decide whether we can define 'extern inline' functions in headers.  */






/* This is here only because every header file already includes this one.
   Get the definitions of all the appropriate `__stub_FUNCTION' symbols.
   <gnu/stubs.h> contains `#define __stub_FUNCTION' when FUNCTION is a stub
   that will always return failure (and set errno to ENOSYS).  */
# 1 "/usr/include/gnu/stubs.h" 1 3 4
/* This file selects the right generated file of `__stub_FUNCTION' macros
   based on the architecture being compiled for.  */

# 1 "/usr/include/bits/wordsize.h" 1 3 4
/* Determine the wordsize from the preprocessor defines.  */
# 5 "/usr/include/gnu/stubs.h" 2 3 4




# 1 "/usr/include/gnu/stubs-64.h" 1 3 4
/* This file is automatically generated.
   It defines a symbol `__stub_FUNCTION' for each function
   in the C library which is a stub, meaning it will fail
   every time called, usually setting errno to ENOSYS.  */
# 10 "/usr/include/gnu/stubs.h" 2 3 4
# 362 "/hpc/software/tier3/osg/slc5_amd64_gcc472/external/gcc/4.7.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include-fixed/features.h" 2 3 4
# 182 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/RConfig.h" 2
# 251 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/RConfig.h"
/*
    Note, that there are really 3 APIs:

    mips, mipsel:
      O32 ABI, ILP32, "long long" in a "aligned" even-odd register
      pair, 4 argument registers

    mipsn32, mipsn32el
      N32 ABI, ILP32, but with 64 bit wide registers, and "long long"
      in a single register, 8 argument registers

    mips64, mips64el
      N64 ABI, LP64, 8 argument registers

    where O32, N32, and N64 are the ABI names.  ILP32 means that
    (I)int, (L)long, (P)pointer are 32bit long. LP64 means that
    long and pointer are 64bit long.  "el" denotes if the ABI is
    little endian.

    N32 is different from 032, in the calling convention.  Arguments
    passed as 64bit (long long) reference, and there are 8 of those.
    O32 is the one closest to "normal" GNU/Linux on i386.

    It's a bit more complex. MIPS spans probably the largest
    performance range of any CPU family, from a 32bit 20 MHz
    Microcontroller (made by Microchip) up to a 64bit monster with
    over 5000 CPUs (made by SiCortex).  Obviously, only the 64bit
    CPUs can run 64bit code, but 32bit code runs on all of them.

    The use cases for the different ABIs are:
    - O32: Most compatible, runs everywhere
    - N32: Best performance on 64 bit if a large address space isn't
           needed.  It is faster than O32 due to improved calling
           conventions, and it is faster than N64 due to reduced
           pointer size.
    - N64: Huge address space.

    Currently (end 2007) Debian GNU/Linux only supports O32

    Thanks to Thiemo Seufer <ths@networkno.de> of Debian
*/
# 431 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/RConfig.h"
/* allows symbols to be hidden from the shared library export symbol table */
/* use typically on file statics and private methods */
# 514 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/RConfig.h"
/*--- memory and object statistics -------------------------------------------*/

/* #define R__NOSTATS */

/*--- cpp --------------------------------------------------------------------*/


    /* symbol concatenation operator */




    /* stringizing */
# 539 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/RConfig.h"
/* produce an identifier that is almost unique inside a file */
# 549 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/RConfig.h"
    /* Currently CINT does not really mind to have duplicates and     */
    /* does not work correctly as far as merging tokens is concerned. */



/*---- misc ------------------------------------------------------------------*/
# 25 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h" 2


# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/DllImport.h" 1
/* @(#)root/base:$Id: DllImport.h 22729 2008-03-19 10:20:10Z pcanal $ */

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/

/*
  This include file defines the DllImport macro
  to build DLLs under Windows OS.

  They are defined as dummy for UNIX's
*/
# 28 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h" 2


# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypeinfo.h" 1
// @(#)root/base:$Id: Rtypeinfo.h 29770 2009-08-12 16:40:27Z rdm $
// Author: Philippe Canal   23/2/02

/*************************************************************************
 * Copyright (C) 1995-2002, Rene Brun, Fons Rademakers and al.           *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 32 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypeinfo.h"
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/typeinfo" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/typeinfo.h" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
/*********************************************************************
* typeinfo.h
*
*  Run time type identification
*
* Memo:
*   typeid(typename) , typeid(expression) is implemented as special 
*  function in the cint body src/G__func.c. 
*
*   As an extention, G__typeid(char *name) is defined in src/G__func.c
*  too for more dynamic use of the typeid.
*
*   type_info is extended to support non-polymorphic type objects.
*
*   In src/G__sizeof.c , G__typeid() is implemented. It relies on
*  specific binary layout of type_info object. If order of type_info
*  member declaration is modified, src/G__sizeof.c must be modified
*  too.
*
*********************************************************************/






# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/bool.h" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

/* 
   not needed anymore since v5.16.23,
   left for backward compatibility of possible user #includes
*/
# 35 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/typeinfo.h" 2

/*********************************************************************
* Functions embedded in cint core
* Most of those functions are defined in src/sizeof.c
* 
*********************************************************************/
// type_info typeid(expression);
// type_info typeid(char *typename);
// type_info G__typeid(char *expression);
// long G__get_classinfo(char *item,int tagnum);
// long G__get_variableinfo(char *item,long *handle,long *index,long tagnum);
// long G__get_functioninfo(char *item,long *handle,long &index,long tagnum);


/*********************************************************************
* type_info
*
*  Included in ANSI/ISO resolution proposal 1995 spring
* 
*********************************************************************/
class type_info {
 public:
  virtual ~type_info() { } // type_info is polymorphic
  bool operator==(const type_info&) const;
  bool operator!=(const type_info&) const;
  bool before(const type_info&) const;

  const char* name() const;

 private:
  type_info(const type_info&);
 protected: // original enhancement
  type_info& operator=(const type_info&);

  // implementation dependent representation
 protected:
  long type; // intrinsic types
  long tagnum; // class/struct/union
  long typenum; // typedefs
  long reftype; // pointing level and reference types
  long size; // size of the object

  long isconst; // constness


 public: // original enhancement
  type_info() { }
};


bool type_info::operator==(const type_info& a) const
{
  if(reftype == a.reftype && tagnum == a.tagnum && type == a.type)
    return(true);
  else
    return(false);
}

bool type_info::operator!=(const type_info& a) const
{
  if( *this == a ) return(false);
  else return(true);
}

bool type_info::before(const type_info& a) const
{
  if(-1!=tagnum)
    return( tagnum < a.tagnum );
  else if(-1!=a.tagnum)
    return( -1 < a.tagnum );
  else
    return( type < a.type );
}

const char* type_info::name() const
{
  static char namestring[100];
  //printf("%d %d %d %d\n",type,tagnum,typenum,reftype);


  char *cptr = G__type2string(type,tagnum,typenum,reftype,isconst);
  sprintf(namestring,"%d%s",strlen(cptr),cptr);






  return(namestring);
}

type_info::type_info(const type_info& a)
{
  type = a.type;
  tagnum = a.tagnum;
  typenum = a.typenum;
  reftype = a.reftype;
  size = a.size;

  isconst = a.isconst;

}

type_info& type_info::operator=(const type_info& a)
{
  type = a.type;
  tagnum = a.tagnum;
  typenum = a.typenum;
  reftype = a.reftype;
  size = a.size;

  isconst = a.isconst;

  return(*this);
}

/**************************************************************************
* original enhancment
**************************************************************************/
type_info::type_info()
{
  type = 0;
  tagnum = typenum = -1;
  reftype = 0;

  isconst = 0;

}


/**************************************************************************
* Further runtime type checking requirement from Fons Rademaker
**************************************************************************/

/*********************************************************************
* G__class_info
*
*********************************************************************/
class G__class_info : public type_info {
 public:
  G__class_info() { init(); }
  G__class_info(type_info& a) { init(a); }
  G__class_info(char *classname) { init(G__typeid(classname)); }

  void init() {
    typenum = -1;
    reftype = 0;
    tagnum = G__get_classinfo("next",-1);
    size = G__get_classinfo("size",tagnum);
    type = G__get_classinfo("type",tagnum);
  }

  void init(type_info& a) {
    type_info *p=this;
    *p = a;
  }

  G__class_info& operator=(G__class_info& a) {
    type = a.type;
    tagnum = a.tagnum;
    typenum = a.typenum;
    reftype = a.reftype;
    size = a.size;
  }

  G__class_info& operator=(type_info& a) {
    init(a);
  }

  G__class_info* next() {
    tagnum=G__get_classinfo("next",tagnum);
    if(-1!=tagnum) return(this);
    else {
      size = type = 0;
      return((G__class_info*)NULL);
    }
  }

  char *title() {
    return((char*)G__get_classinfo("title",tagnum));
  }

  // char *name() is inherited from type_info

  char *baseclass() {
    return((char*)G__get_classinfo("baseclass",tagnum));
  }


  int isabstract() {
    return((int)G__get_classinfo("isabstract",tagnum));
  }

  // can be implemented
  // int iscompiled();

  int Tagnum() {
    return(tagnum);
  }

};


/*********************************************************************
* G__variable_info
*
*********************************************************************/
class G__variable_info {
 public:
  G__variable_info() { init(); }
  G__variable_info(G__class_info& a) { init(a); }
  G__variable_info(char *classname) { init(G__class_info(classname)); }

  void init() {
    G__get_variableinfo("new",&handle,&index,tagnum=-1);
  }

  void init(G__class_info& a) {
    G__get_variableinfo("new",&handle,&index,tagnum=a.Tagnum());
  }

  G__variable_info* next() {
    if(G__get_variableinfo("next",&handle,&index,tagnum)) return(this);
    else return((G__variable_info*)NULL);
  }

  char *title() {
    return((char*)G__get_variableinfo("title",&handle,&index,tagnum));
  }

  char *name() {
    return((char*)G__get_variableinfo("name",&handle,&index,tagnum));
  }

  char *type() {
    return((char*)G__get_variableinfo("type",&handle,&index,tagnum));
  }

  int offset() {
    return((int)G__get_variableinfo("offset",&handle,&index,tagnum));
  }

  // can be implemented
  // char *access(); // return public,protected,private
  // int isstatic();
  // int iscompiled();

 private:
  long handle; // pointer to variable table
  long index;
  long tagnum; // class/struct identity
};

/*********************************************************************
* G__function_info
*
*********************************************************************/
class G__function_info {
 public:
  G__function_info() { init(); }
  G__function_info(G__class_info& a) { init(a); }
  G__function_info(char *classname) { init(G__class_info(classname)); }

  void init() {
    G__get_functioninfo("new",&handle,&index,tagnum=-1);
  } // initialize for global function

  void init(G__class_info& a) {
    G__get_functioninfo("new",&handle,&index,tagnum=a.Tagnum());
  } // initialize for member function

  G__function_info* next() {
    if(G__get_functioninfo("next",&handle,&index,tagnum)) return(this);
    else return((G__function_info*)NULL);
  }

  char *title() {
    return((char*)G__get_functioninfo("title",&handle,&index,tagnum));
  }

  char *name() {
    return((char*)G__get_functioninfo("name",&handle,&index,tagnum));
  }

  char *type() {
    return((char*)G__get_functioninfo("type",&handle,&index,tagnum));
  }

  char *arglist() {
    return((char*)G__get_functioninfo("arglist",&handle,&index,tagnum));
  }

  // can be implemented
  // char *access(); // return public,protected,private
  // int isstatic();
  // int iscompiled();
  // int isvirtual();
  // int ispurevirtual();

 private:
  long handle; // pointer to variable table
  long index;
  long tagnum; // class/struct identity
};

/*********************************************************************
* G__string_buf
*
*  This struct is used as temporary object for returning title strings.
* Size of buf[] limits maximum length of the title string you can
* describe. You can increase size of it here to increase it.
*
*********************************************************************/
struct G__string_buf {
  char buf[256];
};


/*********************************************************************
* Example code
*
*  Following functions are the examples of how to use the type info
* facilities.
*
*********************************************************************/


void G__list_class(void) {
  G__class_info a;
  do {
    printf("%s:%s =%d '%s'\n",a.name(),a.baseclass(),a.isabstract(),a.title());
  } while(a.next());
}

void G__list_class(char *classname) {
  G__list_memvar(classname);
  G__list_memfunc(classname);
}

void G__list_memvar(char *classname) {
  G__variable_info a=G__variable_info(G__typeid(classname));
  do {
    printf("%s %s; offset=%d '%s'\n",a.type(),a.name(),a.offset(),a.title());
  } while(a.next());
}

void G__list_memfunc(char *classname) {
  G__function_info a=G__function_info(G__typeid(classname));
  do {
    printf("%s %s(%s) '%s'\n",a.type(),a.name(),a.arglist(),a.title());
  } while(a.next());
}
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/typeinfo" 2
}
# 33 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypeinfo.h" 2
using std::type_info;
# 31 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h" 2


# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/stdio.h" 1



#pragma setstdio

typedef struct fpos_t {
  long l,u;
  fpos_t(long i=0){l=i;u=0;}
  void operator=(long i){l=i;u=0;}
} fpos_t;
#pragma link off class fpos_t;
#pragma link off typedef fpos_t;
# 30 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/stdio.h"
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/bool.h" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

/* 
   not needed anymore since v5.16.23,
   left for backward compatibility of possible user #includes
*/
# 31 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/stdio.h" 2

#pragma include_noerr <stdfunc.dll>
# 34 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/string.h" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
/****************************************************************
* string.h
*****************************************************************/
# 35 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/snprintf.h" 1
/* @(#)root/clib:$Id: snprintf.h 36336 2010-10-13 13:42:06Z rdm $ */
/* Author: Fons Rademakers  10/12/2000 */

/*
   Write formatted text to buffer 'string', using format string 'format'.
   Returns number of characters written, or -1 if truncated.
   Format string is understood as defined in ANSI C.
*/
# 50 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/snprintf.h"
int snprintf(char *string, size_t length, const char *format, ...);
# 36 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/strlcpy.h" 1
/* @(#)root/clib:$Id: strlcpy.h 36336 2010-10-13 13:42:06Z rdm $ */
/* Author: Fons Rademakers  20/9/2010 */

/*
   Inlcude file for strlcpy and strlcat. They are in string.h on systems
   that have these function (BSD based systems).
*/
# 41 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/strlcpy.h"
size_t strlcpy(char *dst, const char *src, size_t siz);
size_t strlcat(char *dst, const char *src, size_t siz);
# 37 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h" 2



//---- forward declared class types --------------------------------------------

class TClass;
class TBuffer;
class TDirectory;
class TMemberInspector;
class TObject;
class TNamed;
class TRootIOCtor;
class TCollection;
class TFileMergeInfo;
class TString;

//---- types -------------------------------------------------------------------

typedef char Char_t; //Signed Character 1 byte (char)
typedef unsigned char UChar_t; //Unsigned Character 1 byte (unsigned char)
typedef short Short_t; //Signed Short integer 2 bytes (short)
typedef unsigned short UShort_t; //Unsigned Short integer 2 bytes (unsigned short)




typedef int Int_t; //Signed integer 4 bytes (int)
typedef unsigned int UInt_t; //Unsigned integer 4 bytes (unsigned int)


typedef int Seek_t; //File pointer (int)
typedef long Long_t; //Signed long integer 8 bytes (long)
typedef unsigned long ULong_t; //Unsigned long integer 8 bytes (unsigned long)





typedef float Float_t; //Float 4 bytes (float)
typedef float Float16_t; //Float 4 bytes written with a truncated mantissa
typedef double Double_t; //Double 8 bytes
typedef double Double32_t; //Double 8 bytes in memory, written as a 4 bytes float
typedef char Text_t; //General string (char)
typedef bool Bool_t; //Boolean (0=false, 1=true) (bool)
typedef unsigned char Byte_t; //Byte (8 bits) (unsigned char)
typedef short Version_t; //Class version identifier (short)
typedef const char Option_t; //Option string (const char)
typedef int Ssiz_t; //String size (int)
typedef float Real_t; //TVector and TMatrix element type (float)




typedef long long Long64_t; //Portable signed long integer 8 bytes
typedef unsigned long long ULong64_t;//Portable unsigned long integer 8 bytes

typedef double Axis_t; //Axis values type (double)
typedef double Stat_t; //Statistics type (double)

typedef short Font_t; //Font number (short)
typedef short Style_t; //Style number (short)
typedef short Marker_t; //Marker number (short)
typedef short Width_t; //Line width (short)
typedef short Color_t; //Color number (short)
typedef short SCoord_t; //Screen coordinates (short)
typedef double Coord_t; //Pad world coordinates (double)
typedef float Angle_t; //Graphics angle (float)
typedef float Size_t; //Attribute size (float)

enum EColor { kWhite =0, kBlack =1, kGray=920,
              kRed =632, kGreen =416, kBlue=600, kYellow=400, kMagenta=616, kCyan=432,
              kOrange=800, kSpring=820, kTeal=840, kAzure =860, kViolet =880, kPink=900 };

// There is several streamer concepts.
class TClassStreamer; // Streamer functor for a class
class TMemberStreamer; // Streamer functor for a data member
typedef void (*ClassStreamerFunc_t)(TBuffer&, void*); // Streamer function for a class
typedef void (*MemberStreamerFunc_t)(TBuffer&, void*, Int_t); // Streamer function for a data member

// This class is used to implement proxy around collection classes.
class TVirtualCollectionProxy;

typedef void (*VoidFuncPtr_t)(); //pointer to void function


//---- constants ---------------------------------------------------------------
# 134 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h"
const Bool_t kTRUE = true;
const Bool_t kFALSE = false;

const Int_t kMaxUChar = 256;
const Int_t kMaxChar = kMaxUChar >> 1;
const Int_t kMinChar = -kMaxChar - 1;

const Int_t kMaxUShort = 65534;
const Int_t kMaxShort = kMaxUShort >> 1;
const Int_t kMinShort = -kMaxShort - 1;

const UInt_t kMaxUInt = UInt_t(~0);
const Int_t kMaxInt = Int_t(kMaxUInt >> 1);
const Int_t kMinInt = -kMaxInt - 1;

const ULong_t kMaxULong = ULong_t(~0);
const Long_t kMaxLong = Long_t(kMaxULong >> 1);
const Long_t kMinLong = -kMaxLong - 1;

const ULong64_t kMaxULong64 = ULong64_t(~0LL);
const Long64_t kMaxLong64 = Long64_t(kMaxULong64 >> 1);
const Long64_t kMinLong64 = -kMaxLong64 - 1;

const size_t kBitsPerByte = 8;
const Ssiz_t kNPOS = ~(Ssiz_t)0;


//--- bit manipulation ---------------------------------------------------------







//---- debug global ------------------------------------------------------------

extern Int_t gDebug;


//---- ClassDef macros ---------------------------------------------------------

typedef void (*ShowMembersFunc_t)(void *obj, TMemberInspector &R__insp);
class TVirtualIsAProxy;
typedef TClass *(*IsAGlobalFunc_t)(const TClass*, const void *obj);

// TBuffer.h declares and implements the following 2 operators
template <class Tmpl> TBuffer &operator>>(TBuffer &buf, Tmpl *&obj);
template <class Tmpl> TBuffer &operator<<(TBuffer &buf, const Tmpl *obj);

// This might get used if we implement setting a class version.
// template <class RootClass> Short_t GetClassVersion(RootClass *);

namespace ROOT {

   class TGenericClassInfo;
   typedef void *(*NewFunc_t)(void *);
   typedef void *(*NewArrFunc_t)(Long_t size, void *arena);
   typedef void (*DelFunc_t)(void *);
   typedef void (*DelArrFunc_t)(void *);
   typedef void (*DesFunc_t)(void *);
   typedef void (*DirAutoAdd_t)(void *, TDirectory *);
   typedef Long64_t (*MergeFunc_t)(void *, TCollection *, TFileMergeInfo *);
   typedef void (*ResetAfterMergeFunc_t)(void *, TFileMergeInfo *);

   template <class RootClass> Short_t SetClassVersion(RootClass *);

   extern TClass *CreateClass(const char *cname, Version_t id,
                              const type_info &info, TVirtualIsAProxy *isa,
                              ShowMembersFunc_t show,
                              const char *dfil, const char *ifil,
                              Int_t dl, Int_t il);
   extern void AddClass(const char *cname, Version_t id, const type_info &info,
                        VoidFuncPtr_t dict, Int_t pragmabits);
   extern void RemoveClass(const char *cname);
   extern void ResetClassVersion(TClass*, const char*, Short_t);

   extern TNamed *RegisterClassTemplate(const char *name,
                                        const char *file, Int_t line);
# 225 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h"
   class TInitBehavior {
      // This class defines the interface for the class registration and
      // the TClass creation. To modify the default behavior, one would
      // inherit from this class and overload ROOT::DefineBehavior().
      // See TQObject.h and table/inc/Ttypes.h for examples.
   public:
      virtual ~TInitBehavior() { }
      virtual void Register(const char *cname, Version_t id, const type_info &info,
                            VoidFuncPtr_t dict, Int_t pragmabits) const = 0;
      virtual void Unregister(const char *classname) const = 0;
      virtual TClass *CreateClass(const char *cname, Version_t id,
                                  const type_info &info, TVirtualIsAProxy *isa,
                                  ShowMembersFunc_t show,
                                  const char *dfil, const char *ifil,
                                  Int_t dl, Int_t il) const = 0;
   };

   class TDefaultInitBehavior : public TInitBehavior {
   public:
      virtual void Register(const char *cname, Version_t id, const type_info &info,
                            VoidFuncPtr_t dict, Int_t pragmabits) const {
         ROOT::AddClass(cname, id, info, dict, pragmabits);
      }
      virtual void Unregister(const char *classname) const {
         ROOT::RemoveClass(classname);
      }
      virtual TClass *CreateClass(const char *cname, Version_t id,
                                  const type_info &info, TVirtualIsAProxy *isa,
                                  ShowMembersFunc_t show,
                                  const char *dfil, const char *ifil,
                                  Int_t dl, Int_t il) const {
         return ROOT::CreateClass(cname, id, info, isa, show, dfil, ifil, dl, il);
      }
   };

   const TInitBehavior *DefineBehavior(void * /*parent_type*/,
                                       void * /*actual_type*/);

} // End of namespace ROOT

// The macros below use TGenericClassInfo, so let's ensure it is included

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TGenericClassInfo.h" 1
// @(#)root/base:$Id: TGenericClassInfo.h 39611 2011-06-08 19:35:17Z pcanal $
// Author: Philippe Canal   23/2/02

/*************************************************************************
 * Copyright (C) 1995-2002, Rene Brun, Fons Rademakers and al.           *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/




# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/vector" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_vector" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <vector.dll>
#pragma include_noerr <vectorbool.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/vector

#pragma ifndef PREC_STL_VECTOR
#pragma define PREC_STL_VECTOR
#pragma link off global PREC_STL_VECTOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from ANSI/ISO C++ 1997/Nov draft 
// Got some ideas from Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <iterator.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/iterator

#pragma ifndef PREC_STL_ITERATOR
#pragma define PREC_STL_ITERATOR
#pragma link off global PREC_STL_ITERATOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from STL HP implementation 1994
// Imported from STL SGI implementation 1997 
// Imported from ANSI/ISO C++ draft Nov 1997
// Modified by Masaharu Goto
// May need improvement for the latest standard


////////////////////////////////////////////////////////////////////////
// iterator_tag
////////////////////////////////////////////////////////////////////////
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag {};
struct bidirectional_iterator_tag {};
struct random_access_iterator_tag {};

////////////////////////////////////////////////////////////////////////
// iterator template
////////////////////////////////////////////////////////////////////////
template <class T, class Distance> struct input_iterator {};
struct output_iterator {};
template <class T, class Distance> struct forward_iterator {};
template <class T, class Distance> struct bidirectional_iterator {};
template <class T, class Distance> struct random_access_iterator {};

#pragma link off class output_iterator;







////////////////////////////////////////////////////////////////////////
// iterator_category overloaded function
////////////////////////////////////////////////////////////////////////
template <class T, class Distance>
inline input_iterator_tag
iterator_category(const input_iterator<T, Distance>&) {
    return input_iterator_tag();
}

inline output_iterator_tag iterator_category(const output_iterator&) {
    return output_iterator_tag();
}

#pragma link off function iterator_category(const output_iterator&);


template <class T, class Distance>
inline forward_iterator_tag
iterator_category(const forward_iterator<T, Distance>&) {
    return forward_iterator_tag();
}

template <class T, class Distance>
inline bidirectional_iterator_tag
iterator_category(const bidirectional_iterator<T, Distance>&) {
    return bidirectional_iterator_tag();
}

template <class T, class Distance>
inline random_access_iterator_tag
iterator_category(const random_access_iterator<T, Distance>&) {
    return random_access_iterator_tag();
}

template <class T>
inline random_access_iterator_tag
iterator_category(const T*) {
    return random_access_iterator_tag();
}


// iterator_traits, iterator and reverse_iterator template may not be
// needed for precompiled library interface 

////////////////////////////////////////////////////////////////////////
// iterator_traits
////////////////////////////////////////////////////////////////////////

template <class Iterator>
struct iterator_traits {
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type value_type;
  typedef typename Iterator::difference_type difference_type;
  typedef typename Iterator::pointer pointer;
  typedef typename Iterator::reference reference;
};

// template partial specialization, implement in cint5.15.14 1587
template <class T>
struct iterator_traits<T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
};

// incomplete implementation in cint5.15.14 1587, need some fix
// iterator_traits<const int*> is changed as iterator_traits<const int* const>
// or something, but cint5.15.14 can not handle this well
template <class T>
struct iterator_traits<const T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef const T* pointer;
  typedef const T& reference;
};

////////////////////////////////////////////////////////////////////////
// iterator
////////////////////////////////////////////////////////////////////////
template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator {
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
  typedef Category iterator_category;
};


////////////////////////////////////////////////////////////////////////
// reverse_iterator
////////////////////////////////////////////////////////////////////////






template <class Iterator>
class reverse_iterator
# 166 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
{




 public:
# 181 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
   typedef Iterator::pointer pointer;
   typedef Iterator::reference reference;
   typedef ptrdiff_t difference_type;


   reverse_iterator();
   //reverse_iterator(Iterator x);



   Iterator base() const; // explicit
   reference operator*() const;
   pointer operator->() const;
   reverse_iterator& operator++();
   reverse_iterator operator++(int);
   reverse_iterator& operator--();
   reverse_iterator operator--(int);
   reverse_iterator operator+ (difference_type n) const;
   reverse_iterator& operator+=(difference_type n);
   reverse_iterator operator- (difference_type n) const;
   reverse_iterator& operator-=(difference_type n);
   reference operator[](difference_type n) const;
};
# 932 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
// for g++ 3.1,3.2
namespace __gnu_cxx
{
  // This iterator adapter is 'normal' in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                    difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparaison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  // _GLIBCPP_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
     const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
} // namespace __gnu_cxx







#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 2
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <memory.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/memory

#pragma ifndef PREC_STL_MEMORY
#pragma define PREC_STL_MEMORY
#pragma link off global PREC_STL_MEMORY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/stddef.h" 1





typedef long ptrdiff_t;

typedef unsigned int wchar_t;
# 21 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory" 2






//////////////////////////////////////////////////////////////////////


template <class _Tp>
class allocator {
  //typedef alloc _Alloc;          // The underlying allocator.
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  typedef typename _Tp* pointer;
  typedef const typename _Tp * const_pointer;




  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() ;
  allocator(const allocator&) ;
  //template <class _Tp1> allocator(const allocator<_Tp1>&) ;
  ~allocator() ;

  pointer address(reference __x) const ;
  const_pointer address(const_reference __x) const ;

  // __n is permitted to be 0.  The C++ standard says nothing about what
  // the return value is when __n == 0.
  _Tp* allocate(size_type __n, const void* = 0) ;

  // __p is not permitted to be a null pointer.
  void deallocate(pointer __p, size_type __n);

  size_type max_size() const ;

  void construct(pointer __p, const _Tp& __val) ;
  void destroy(pointer __p) ;
};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;
  typedef void value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };
};
//////////////////////////////////////////////////////////////////////
# 205 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////

/**********************************************************************
* auto_ptr
**********************************************************************/
template <class X> class auto_ptr {
private:
  X* ptr;
  //template<class Y> struct auto_ptr_ref { };
public:
  typedef X element_type;
  explicit auto_ptr(X* p = 0) : ptr(p) {}
  auto_ptr(auto_ptr& a) {ptr=a.ptr;}

  // this implementation may not be correct
  template <class T> auto_ptr(auto_ptr<T>& a) {ptr=a.release();}
# 229 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  auto_ptr& operator=(auto_ptr& a) {
    if (a.ptr != ptr) {
      delete ptr;
      ptr = a.ptr;
    }
    return(*this);
  }

  // this implementation may not be correct
  template <class T> auto_ptr& operator=(auto_ptr<T>& a) {
    if (a.ptr != ptr) {
       delete ptr;
       ptr = a.release();
    }
    return(*this);
  }

  ~auto_ptr() { delete ptr; }

  X& operator*() const { return *ptr; }
  X* operator->() const { return ptr; }
  X* get() const { return ptr; }
  X* release() { X *old = ptr; ptr = 0; return 0; }
# 262 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  // auto_ptr conversions
  //auto_ptr(auto_ptr_ref<X>& x) { }
  //template<class Y> operator auto_ptr_ref<Y>() { return auto_ptr_ref<Y>(); }
  //template<class Y> operator auto_ptr<Y>() { return auto_ptr<T>(); }
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 2
# 28 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <utility.dll>


#pragma include_noerr <pair.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/utility

#pragma ifndef PREC_STL_UTILITY
#pragma define PREC_STL_UTILITY
#pragma link off global PREC_STL_UTILITY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

template <class T1, class T2>
struct pair {
  T1 first;
  T2 second;
  pair() : first(T1()), second(T2()) {}
  pair(const T1& a, const T2& b) : first(a), second(b) {}
 private:
  pair& operator=(const pair& x){first=x.first;second=x.second;return *this;}
};

#pragma endif
# 17 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 2
# 29 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector" 2
# 37 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
template<class T,class Allocator=std::allocator<T> >
# 49 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
class vector {
 public:
  typedef T value_type;


  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
# 218 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
  class iterator {
   public:
     typedef vector::pointer pointer;
     typedef vector::const_pointer const_pointer;
     typedef vector::reference reference;
     typedef vector::const_reference const_reference;
     typedef vector::size_type size_type;
     typedef vector::difference_type difference_type;

      iterator();
      explicit iterator(const pointer& __i) ;
      // Allow iterator to const_iterator conversion
      template<typename _Iter> inline iterator(const iterator& __i);

      // Forward iterator requirements
      reference operator*() const ;
      pointer operator->() const ;
      iterator& operator++();
      iterator operator++(int) ;

      // Bidirectional iterator requirements
      iterator& operator--() ;
      iterator operator--(int) ;

      // Random access iterator requirements
      reference operator[](const difference_type& __n) const;
      iterator& operator+=(const difference_type& __n);
      iterator operator+(const difference_type& __n) const;
      iterator& operator-=(const difference_type& __n);
      iterator operator-(const difference_type& __n) const;
      const pointer& base() const ;

      iterator operator=(const iterator& x) ;

  };

  friend bool operator==(const vector::iterator& x,const vector::iterator& y)const;
  friend bool operator!=(const vector::iterator& x,const vector::iterator& y)const;
  friend bool operator<(const vector::iterator& x,const vector::iterator& y)const;
  friend bool operator>(const vector::iterator& x,const vector::iterator& y)const;
  friend bool operator<=(const vector::iterator& x,const vector::iterator& y)const;
  friend bool operator>=(const vector::iterator& x,const vector::iterator& y)const;
  friend vector::iterator::difference_type operator-(const vector::iterator& x,const vector::iterator& y)const;
  friend vector::iterator operator+(const vector::iterator::difference_type x,const vector::iterator& y)const;

  typedef const iterator const_iterator;
# 355 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
  typedef reverse_iterator<const_iterator> const_reverse_iterator;
  typedef reverse_iterator<iterator> reverse_iterator;
# 398 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
  friend bool operator==(const vector::reverse_iterator& x
                        ,const vector::reverse_iterator& y) const;
  friend bool operator!=(const vector::reverse_iterator& x
                        ,const vector::reverse_iterator& y) const;






  friend bool operator==(vector::const_iterator& x
                        ,vector::const_iterator& y) const;
  friend bool operator!=(vector::const_iterator& x
                        ,vector::const_iterator& y) const;
# 422 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
  reference at(size_type n);
  const_reference at(size_type n) const;

  iterator begin(void) ;
  iterator end(void) ;
  reverse_iterator rbegin(void) ;
  reverse_iterator rend(void) ;






  size_type size(void) const ;
  size_type max_size(void) const ;
  void resize(size_type sz) ;
  void resize(size_type sz, T c) ;
  size_type capacity(void) const ;
  bool empty(void) const ;
  reference operator[](size_type n) ;
  const_reference operator[](size_type n) const;
  vector(void) ;
  vector(size_type n,const T& value=T()) ;
  vector(const vector& x) ;
  vector(const_iterator first,const_iterator last) ;
  ~vector(void) ;
  vector& operator=(const vector& x);
  void reserve(size_type n) ;
  T& front(void) ;
  T& back(void) ;
  void push_back(const T& x) ;
  void swap(vector& x);
  iterator insert(iterator position,const T& x);
  void insert(iterator position,const_iterator first,const_iterator last);
  void insert(iterator position,size_type n,const T& x);
  void pop_back(void) ;
  void erase(iterator position) ;
  void erase(iterator first,iterator last) ;
  void clear() ;


  friend bool operator==(const vector& x, const vector& y);
  friend bool operator< (const vector& x, const vector& y);
  friend bool operator!=(const vector& x, const vector& y);
  friend bool operator> (const vector& x, const vector& y);
  friend bool operator>=(const vector& x, const vector& y);
  friend bool operator<=(const vector& x, const vector& y);



  // specialized algorithms:






#pragma ifndef G__NOALGORITHM

  // Generic algorithm


  // input iter
  friend vector::iterator
    find(vector::iterator first,vector::iterator last,const T& value);
  // forward iter
  friend vector::iterator
    find_end(vector::iterator first1,vector::iterator last1,
      vector::iterator first2,vector::iterator last2);
  friend vector::iterator
    find_first_of(vector::iterator first1,vector::iterator last1,
           vector::iterator first2,vector::iterator last2);
  friend vector::iterator
    adjacent_find(vector::iterator first,vector::iterator last);
  // input iter

  friend vector::difference_type
    count(vector::iterator first,vector::iterator last,const T& value);






  friend bool
    equal(vector::iterator first1,vector::iterator last1,
          vector::iterator first2);
  // forward iter
  friend vector::iterator
    search(vector::iterator first1,vector::iterator last1,
           vector::iterator first2,vector::iterator last2);
  friend vector::iterator
    search_n(vector::iterator first,vector::iterator last
             ,vector::size_type count,const T& value);
  // input and output iter -> forward iter
  friend vector::iterator
    copy(vector::iterator first,vector::iterator last,
         vector::iterator result);
  // bidirectional iter
  friend vector::iterator
    copy_backward(vector::iterator first,vector::iterator last,
                  vector::iterator result);
  // just value_type
  friend void swap(T& a,T& b);
  // forward iter
  friend vector::iterator
    swap_ranges(vector::iterator first1,vector::iterator last1,
                vector::iterator first2);
  friend void iter_swap(vector::iterator a,vector::iterator b);
  friend void replace(vector::iterator first,vector::iterator last,
                      const T& old_value,const T& new_value);
  // input, output iter -> forward iter
  friend vector::iterator
    replace_copy(vector::iterator first,vector::iterator last,
                 vector::iterator result,
                 const T& old_value,const T& new_value);
  // forward iter
  friend void
    fill(vector::iterator first,vector::iterator last,const T& value);

  friend void
    fill_n(vector::iterator first,vector::size_type n,const T& value);

  friend vector::iterator
    remove(vector::iterator first,vector::iterator last,const T& value);
  // input,output iter -> forward iter
  friend vector::iterator
    remove_copy(vector::iterator first,vector::iterator last,
                vector::iterator result,const T& value);
  friend vector::iterator
    unique(vector::iterator first,vector::iterator last);
  friend vector::iterator
    unique_copy(vector::iterator first,vector::iterator last,
                vector::iterator result);
  friend void reverse(vector::iterator first,vector::iterator last);
  friend vector::iterator
     reverse_copy(vector::iterator first,vector::iterator last,
                  vector::iterator result);
  // forward iter

  friend void rotate(vector::iterator first,vector::iterator mid,
                     vector::iterator last);

  // forward iter
  friend vector::iterator
    rotate_copy(vector::iterator first,vector::iterator mid,
                vector::iterator last,vector::iterator result);
  // randomaccess iter
  friend void random_shuffle(vector::iterator first,vector::iterator last);
  // randomaccess iter
  friend void sort(vector::iterator first,vector::iterator last);
  friend void stable_sort(vector::iterator first,vector::iterator last);
  friend void partial_sort(vector::iterator first,vector::iterator mid,
                           vector::iterator last);
  friend vector::iterator
    partial_sort_copy(vector::iterator first,vector::iterator last,
                      vector::iterator result_first,
                      vector::iterator result_last);
  friend void nth_element(vector::iterator first,vector::iterator nth,
                          vector::iterator last);
  // forward iter
  friend vector::iterator
    lower_bound(vector::iterator first,vector::iterator last,const T& value);
  friend vector::iterator
    upper_bound(vector::iterator first,vector::iterator last,const T& value);




  friend bool binary_search(vector::iterator first,vector::iterator last,
                            const T& value);
  friend vector::iterator merge(vector::iterator first1,vector::iterator last1,
                                vector::iterator first2,vector::iterator last2,
                                vector::iterator result);
  friend void inplace_merge(vector::iterator first,vector::iterator middle,
                            vector::iterator last);
  friend bool includes(vector::iterator first1,vector::iterator last1,
                       vector::iterator first2,vector::iterator last2);
  friend vector::iterator
    set_union(vector::iterator first1,vector::iterator last1,
              vector::iterator first2,vector::iterator last2,
              vector::iterator result);
  friend vector::iterator
    set_intersection(vector::iterator first1,vector::iterator last1,
                     vector::iterator first2,vector::iterator last2,
                     vector::iterator result);
  friend vector::iterator
    set_difference(vector::iterator first1,vector::iterator last1,
                   vector::iterator first2,vector::iterator last2,
                   vector::iterator result);
  friend vector::iterator
    set_symmetric_difference(vector::iterator first1,vector::iterator last1,
                             vector::iterator first2,vector::iterator last2,
                             vector::iterator result);
  // random access
  friend void push_heap(vector::iterator first,vector::iterator last);
  friend void pop_heap(vector::iterator first,vector::iterator last);
  friend void make_heap(vector::iterator first,vector::iterator last);
  friend void sort_heap(vector::iterator first,vector::iterator last);
  // min,max, just value_type
  friend const T& min(const T& a,const T& b);
  friend const T& max(const T& a,const T& b);
  // forward iter
  friend vector::iterator
    min_element(vector::iterator first,vector::iterator last);
  friend vector::iterator
    max_element(vector::iterator first,vector::iterator last);
  // input iter
  friend bool
    lexicographical_compare(vector::iterator first1,vector::iterator last1,
                            vector::iterator first2,vector::iterator last2);
  // bidirectional iter
  friend bool next_permutation(vector::iterator first,vector::iterator last);
  friend bool prev_permutation(vector::iterator first,vector::iterator last);
# 662 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
#pragma endif

  // iterator_category resolution
  //friend random_access_iterator_tag iterator_category(vector::iterator x);

};
# 837 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
#pragma endif
# 15 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_vector" 2
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/vector" 2
}
# 16 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TGenericClassInfo.h" 2
//#ifndef ROOT_TSchemaHelper
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TSchemaHelper.h" 1
// @(#)root/core:$Id: TSchemaHelper.h 43515 2012-03-27 21:15:53Z pcanal $
// author: Lukasz Janyst <ljanyst@cern.ch>

/*************************************************************************
 * Copyright (C) 1995-2010, Rene Brun, Fons Rademakers and al.           *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/

// This include must be outside of the code guard because
// Rtypes.h includes TGenericClassInfo.h which includes
// TSchemaHelper.h (this header file) and really need the
// definition of ROOT::TSchemaHelper.   So in this case,
// we need the indirect #include to really do the declaration
// and the direct #include to be a noop.







# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/string" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_string" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// string





#pragma include_noerr <string.dll>




# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/string" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/string

#pragma ifndef PREC_STL_STRING
#pragma define PREC_STL_STRING
#pragma link off global PREC_STL_STRING;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// string class wrapper , by Masaharu Goto
// Template is on purposely avoided.


# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iostream" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iostream.h" 1
/* /% C++ %/ */
/***********************************************************************
 * cint (C/C++ interpreter)
 ************************************************************************
 * I/O stream header file iostream.h
 ************************************************************************
 * Description:
 *  CINT iostream header file
 ************************************************************************
 * Copyright(c) 1995~1999  Masaharu Goto 
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/



/*********************************************************************
* Try initializaing precompiled iostream library
*********************************************************************/
#pragma setstream
#pragma ifdef G__IOSTREAM_H

#pragma ifdef G__TMPLTIOS
typedef ios_base ios;
#pragma else
typedef ios ios_base;
#pragma endif

#pragma ifndef G__KCC
#pragma include <iosenum.h>

#pragma ifndef G__SSTREAM_H
typedef ostrstream ostringstream;
typedef istrstream istringstream;
//typedef strstream stringstream;  // problem, 
#pragma else
typedef ostringstream ostrstream;
typedef istringstream istrstream;
typedef stringstream strstream;
#pragma endif

#pragma endif

#pragma endif

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/bool.h" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

/* 
   not needed anymore since v5.16.23,
   left for backward compatibility of possible user #includes
*/
# 48 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iostream.h" 2

/*********************************************************************
* Use fake iostream only if precompiled version does not exist.
*********************************************************************/
#pragma if !defined(G__IOSTREAM_H)


#pragma security level0



/*********************************************************************
* ios
*
*********************************************************************/
typedef long streamoff;
typedef long streampos;
//class io_state;
class streambuf;
class fstreambase;
typedef long SZ_T;
typedef SZ_T streamsize;

class ios {
 public:
  typedef int iostate;
  enum io_state {
    goodbit = 0x00,
    badbit = 0x01,
    eofbit = 0x02,
    failbit = 0x04
  };
  typedef int openmode;
  enum open_mode {
    app = 0x01,
    binary = 0x02,
    in = 0x04,
    out = 0x08,
    trunc = 0x10,
    ate = 0x20
  };
  typedef int seekdir;
  enum seek_dir {
    beg = 0x0,
    cur = 0x1,
    end = 0x2
  };
  typedef int fmtflags;
  enum fmt_flags {
    boolalpha = 0x0001,
    dec = 0x0002,
    fixed = 0x0004,
    hex = 0x0008,
    internal = 0x0010,
    left = 0x0020,
    oct = 0x0040,
    right = 0x0080,
    scientific = 0x0100,
    showbase = 0x0200,
    showpoint = 0x0400,
    showpos = 0x0800,
    skipws = 0x1000,
    unitbuf = 0x2000,
    uppercase = 0x4000,
    adjustfield = left | right | internal,
    basefield = dec | oct | hex,
    floatfield = scientific | fixed
  };
  enum event {
    erase_event = 0x0001,
    imbue_event = 0x0002,
    copyfmt_event = 0x0004
  };

  ios() { x_width=0; }
  streamsize width(streamsize wide) { x_width=wide; }
 protected:
  int x_width;
};


/*********************************************************************
* ostream
*
*********************************************************************/

class ostream : /* virtual */ public ios {
 FILE *fout;
      public:
 ostream(FILE *setfout) { fout=setfout; }
 ostream(char *fname) ;
 ~ostream() ;
 void close() { if(fout) fclose(fout); fout=0;}
 void flush() { if(fout) fflush(fout); }
 FILE *fp() { return(fout); }
 int rdstate() ;

 ostream& operator <<(char c);
 ostream& operator <<(char *s);
 ostream& operator <<(long i);
 ostream& operator <<(unsigned long i);
 ostream& operator <<(double d);
 ostream& operator <<(void *p);
 ostream& form(char *format ...);
};

ostream::~ostream()
{
  if(fout!=stderr && fout!=stdout && fout!=0) {
    fclose(fout);
  }
}

ostream::ostream(char *fname)
{
  fout = fopen(fname,"w");
  if(fout==0) {
    fprintf(stderr,"%s can not open\n",fname);
  }
}

ostream& ostream::operator <<(char c)
{
  if(x_width) {
    int init=0;
    if(isprint(c)) init=1;
    for(int i=init;i<x_width;i++) fputc(' ',fout);
    x_width=0;
  }
  fprintf(fout,"%c",c);
  return(*this);
}

ostream& ostream::operator <<(char *s)
{
  if(x_width &&(!s || x_width>strlen(s))) {
    if(s) for(int i=strlen(s);i<x_width;i++) fputc(' ',fout);
    else for(int i=0;i<x_width;i++) fputc(' ',fout);
    x_width=0;
  }
  fprintf(fout,"%s",s);
  return(*this);
}

ostream& ostream::operator <<(long x)
{
  if(x_width) {
    char buf[50];
    sprintf(buf,"%d",x);
    if(x_width>strlen(buf))
      for(int i=strlen(buf);i<x_width;i++) fputc(' ',fout);
    x_width=0;
  }
  fprintf(fout,"%d",x);
  return(*this);
}

ostream& ostream::operator <<(unsigned long x)
{
  if(x_width) {
    char buf[50];
    sprintf(buf,"%u",x);
    if(x_width>strlen(buf))
      for(int i=strlen(buf);i<x_width;i++) fputc(' ',fout);
    x_width=0;
  }
  fprintf(fout,"%u",x);
  return(*this);
}

ostream& ostream::operator <<(double d)
{
  if(x_width) {
    char buf[50];
    sprintf(buf,"%g",d);
    if(x_width>strlen(buf))
      for(int i=strlen(buf);i<x_width;i++) fputc(' ',fout);
    x_width=0;
  }
  fprintf(fout,"%g",d);
  return(*this);
}

ostream& ostream::operator <<(void *p)
{
  if(x_width) {
    char buf[50];
    sprintf(buf,"0x%x",p);
    if(x_width>strlen(buf))
      for(int i=strlen(buf);i<x_width;i++) fputc(' ',fout);
    x_width=0;
  }
  printf("0x%x",p);
  return(*this);
}

int ostream::rdstate()
{
  if(fout) return(0);
  else return(1);
}

/* instanciation of cout,cerr */
ostream cout=ostream(stdout);
ostream cerr=ostream(stderr);


/*********************************************************************
* istream
*
*********************************************************************/

class istream : /* virtual */ public ios {
  FILE *fin;
  ostream *tie;
public:
  istream(FILE *setfin) { fin = setfin; tie=(ostream*)0; }
  istream(char *fname);
  ~istream();
  void close() { if(fin) fclose(fin); fin=0;}
  ostream& tie(ostream& cx);
  FILE *fp() { return(fin); }
  int rdstate();

  istream& operator >>(char& c);
  istream& operator >>(char *s);
  istream& operator >>(short& s);
  istream& operator >>(int& i);
  istream& operator >>(long& i);
  istream& operator >>(unsigned char& c);
  istream& operator >>(unsigned short& s);
  istream& operator >>(unsigned int& i);
  istream& operator >>(unsigned long& i);
  istream& operator >>(double& d);
  istream& operator >>(float& d);
};

istream::~istream()
{
  if(fin!=stdin && fin!=0) {
    fclose(fin);
  }
}

istream::istream(char *fname)
{
  fin = fopen(fname,"r");
  if(fin==0) {
    fprintf(stderr,"%s can not open\n",fname);
  }
  tie=(ostream*)0;
}


ostream& istream::tie(ostream& cx)

{
  ostream *tmp;
  tmp=tie;
  tie = &cx;
  return(*tmp);
}

istream& istream::operator >>(char& c)
{
  if(tie) tie->flush();
  c=fgetc(fin);
  return(*this);
}

istream& istream::operator >>(char *s)
{
  if(tie) tie->flush();
  fscanf(fin,"%s",s);
  return(*this);
}

istream& istream::operator >>(short& s)
{
  if(tie) tie->flush();
  fscanf(fin,"%hd",&s);
  return(*this);
}

istream& istream::operator >>(int& i)
{
  if(tie) tie->flush();
  fscanf(fin,"%d",&i);
  return(*this);
}

istream& istream::operator >>(long& i)
{
  if(tie) tie->flush();
  fscanf(fin,"%ld",&i);
  return(*this);
}

istream& istream::operator >>(unsigned char& c)
{
  int i;
  if(tie) tie->flush();
  fscanf(fin,"%u",&i);
  c = i;
  return(*this);
}
istream& istream::operator >>(unsigned short& s)
{
  if(tie) tie->flush();
  fscanf(fin,"%hu",&s);
  return(*this);
}
istream& istream::operator >>(unsigned int& i)
{
  if(tie) tie->flush();
  fscanf(fin,"%u",&i);
  return(*this);
}
istream& istream::operator >>(unsigned long& i)
{
  if(tie) tie->flush();
  fscanf(fin,"%lu",&i);
  return(*this);
}

istream& istream::operator >>(float& f)
{
  if(tie) tie->flush();
  fscanf(fin,"%g",&f);
  return(*this);
}

istream& istream::operator >>(double& d)
{
  if(tie) tie->flush();
  fscanf(fin,"%lg",&d);
  return(*this);
}

int istream::rdstate()
{
  int cx;
  if(!fin) return(1);
  cx = fgetc(fin);
  fseek(fin,-1,(1));
  if(EOF==cx) return(1);
  return(0);
}

/* instanciation of cin */
istream cin=istream(stdin);

/*********************************************************************
* iostream
*
*********************************************************************/
class iostream : public istream , public ostream {
 public:
  iostream(FILE *setfin) : istream(setfin), ostream(setfin) { }
  iostream(char *fname) : istream(fname), ostream(fname) { }
};


/*********************************************************************
* ofstream, ifstream 
*
*********************************************************************/

class fstream;

class ofstream : public ostream {
 public:
  ofstream(FILE* setfin) : ostream(setfin) { }
  ofstream(char* fname) : ostream(fname) { }
};

class ifstream : public istream {
 public:
  ifstream(FILE* setfin) : istream(setfin) { }
  ifstream(char* fname) : istream(fname) { }
};

class iofstream : public iostream {
 public:
  iofstream(FILE* setfin) : iostream(setfin) { }
  iofstream(char* fname) : iostream(fname) { }
};


ostream& flush(ostream& i) {i.flush(); return(i);}
ostream& endl(ostream& i) {return i << '\n' << flush;}
ostream& ends(ostream& i) {return i << '\0';}
istream& ws(istream& i) {
  fprintf(stderr,"Limitation: ws,WS manipurator not supported\n");
  return(i);
}
istream& WS(istream& i) {
  fprintf(stderr,"Limitation: ws,WS manipurator not supported\n");
  return(i);
}

#pragma endif

ostream& ostream::form(char *format ...) {
  char temp[1024];
  return(*this<<G__charformatter(0,temp,1024));
}

/*********************************************************************
* iostream manipurator emulation
*
*  Following description must be deleted when pointer to compiled 
* function is fully supported.
*********************************************************************/
struct G__CINT_IOFLAGS {
   G__CINT_IOFLAGS(int f = 0, int m = 0): flag(f), mask(m) {}
#pragma ifndef G__TMPLTIOS
   typedef ios ios_base;
#pragma endif
   int flag, mask;
};
class G__CINT_ENDL { int dmy; } endl;
class G__CINT_ENDS { int dmy; } ends;
class G__CINT_FLUSH { int dmy; } flush;
class G__CINT_ws { int dmy; } ws;
class G__CINT_WS { int dmy; } WS;



G__CINT_IOFLAGS hex(ios_base::hex, ios_base::basefield);;
G__CINT_IOFLAGS oct(ios_base::oct, ios_base::basefield);;
G__CINT_IOFLAGS dec(ios_base::dec, ios_base::basefield);;
G__CINT_IOFLAGS scientific(ios_base::scientific, ios_base::floatfield);;
G__CINT_IOFLAGS fixed(ios_base::fixed, ios_base::floatfield);;
/*
Better not, or "left" will become a CINT reserved variable.
G__DECL_IOFM(left,adjustfield);
G__DECL_IOFM(right,adjustfield);
G__DECL_IOFM(internal,adjustfield);
*/




G__CINT_IOFLAGS boolalpha(ios_base::boolalpha, ios_base::boolalpha);;
G__CINT_IOFLAGS showbase(ios_base::showbase, ios_base::showbase);;
G__CINT_IOFLAGS showpoint(ios_base::showpoint, ios_base::showpoint);;
G__CINT_IOFLAGS showpos(ios_base::showpos, ios_base::showpos);;
G__CINT_IOFLAGS skipws(ios_base::skipws, ios_base::skipws);;
G__CINT_IOFLAGS unitbuf(ios_base::unitbuf, ios_base::unitbuf);;
G__CINT_IOFLAGS uppercase(ios_base::uppercase, ios_base::uppercase);;


/*
class G__CINT_HEX { int dmy; } hex;
class G__CINT_DEC { int dmy; } dec;
class G__CINT_OCT { int dmy; } oct;
class G__CINT_OCT { int dmy; } showpoint;
class G__CINT_SCIENTIFIC { int dmy; } scientific;
class G__CINT_FIXED { int dmy; } fixed;
*/
class G__CINT_NOSUPPORT { int dmy; } ;
# 11 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iostream" 2
}
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/_iostream" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// include/_iostream

std::ostream& operator<<(std::ostream& ostr,std::G__CINT_ENDL& i)
 {return(std::endl(ostr));}
std::ostream& operator<<(std::ostream& ostr,std::G__CINT_ENDS& i)
 {return(std::ends(ostr));}
std::ostream& operator<<(std::ostream& ostr,std::G__CINT_FLUSH& i)
 {return(std::flush(ostr));}

std::istream& operator>>(std::istream& istr,std::G__CINT_ws& i)
 {return(std::ws(istr));}
std::istream& operator>>(std::istream& istr,std::G__CINT_WS& i)
 {return(std::WS(istr));}


std::ostream& operator<<(std::ostream& ostr,std::G__CINT_IOFLAGS& f) {
   ostr.setf(f.flag, f.mask);
  return ostr;
}
std::istream& operator>>(std::istream& istr,std::G__CINT_IOFLAGS& f) {
  istr.setf(f.flag, f.mask);
  return istr;
}

std::ostream& operator<<(std::ostream& ostr,std::G__CINT_NOSUPPORT& i) {
  fprintf(stderr,"Limitation: dec,hex,oct manipurator not supported\n");
  return(ostr);
}
std::istream& operator<<(std::istream& istr,std::G__CINT_NOSUPPORT& i) {
  fprintf(stderr,"Limitation: dec,hex,oct manipurator not supported\n");
  return(istr);
}


std::ostream& operator<<(std::ostream& ostr,long long i) {
  char buf[200];
#pragma ifndef G__TMPLTIOS
  if (ostr.flags() & ios::hex)
#pragma else
  if (ostr.flags() & ios_base::hex)
#pragma endif
     sprintf(buf,"%llx",i);
  else
     sprintf(buf,"%lld",i);
  ostr << buf ;
  return(ostr);
}
std::ostream& operator<<(std::ostream& ostr,unsigned long long i) {
  char buf[200];
#pragma ifndef G__TMPLTIOS
  if (ostr.flags() & ios::hex)
#pragma else
  if (ostr.flags() & ios_base::hex)
#pragma endif
     sprintf(buf,"%llx",i);
  else
     sprintf(buf,"%llu",i);
  ostr << buf ;
  return(ostr);
}
std::ostream& operator<<(std::ostream& ostr,long double i) {
  char buf[200];
  sprintf(buf,"%Lg",i);
  ostr << buf ;
  return(ostr);
}
std::istream& operator>>(std::istream& istr,long long &i) {
  char buf[200];
  istr >> buf ;
  sscanf(buf,"%lld",&i);
  return(istr);
}
std::istream& operator>>(std::istream& istr,unsigned long long &i) {
  char buf[200];
  istr >> buf ;
#pragma ifndef G__TMPLTIOS
  if (ostr.flags() & ios::hex)
#pragma else
  if (ostr.flags() & ios_base::hex)
#pragma endif
     sscanf(buf,"%llx",&i);
  else
     sscanf(buf,"%llu",&i);
  return(istr);
}
std::istream& operator>>(std::istream& istr,long double &i) {
  char buf[200];
  istr >> buf ;
  sscanf(buf,"%Lg",&i);
  return(istr);
}


// Value evaluation
//template<class T> int G__ateval(const T* x) {return(0);}
//template<class T> int G__ateval(const T& x) {return(0);}
int G__ateval(const char* const &x) {return(0);}
//int G__ateval(const void* const &x) {return(0);}
int G__ateval(double x) {return(0);}
int G__ateval(float x) {return(0);}
int G__ateval(bool x) {return(0);}
int G__ateval(char x) {return(0);}
int G__ateval(short x) {return(0);}
int G__ateval(int x) {return(0);}
int G__ateval(long x) {return(0);}
int G__ateval(unsigned char x) {return(0);}
int G__ateval(unsigned short x) {return(0);}
int G__ateval(unsigned int x) {return(0);}
int G__ateval(unsigned long x) {return(0);}
# 127 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/_iostream"
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iomanip.h" 1
/* /% C++ %/ */
/***********************************************************************
 * cint (C/C++ interpreter)
 ************************************************************************
 * I/O manipulator header for iomanip.h
 ************************************************************************
 * Description:
 *  CINT IOMANIP header file
 ************************************************************************
 * Author                  Masaharu Goto 
 * Copyright(c) 1995~1999  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/




# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iostream.h" 1
/* /% C++ %/ */
/***********************************************************************
 * cint (C/C++ interpreter)
 ************************************************************************
 * I/O stream header file iostream.h
 ************************************************************************
 * Description:
 *  CINT iostream header file
 ************************************************************************
 * Copyright(c) 1995~1999  Masaharu Goto 
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
# 21 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iomanip.h" 2
# 59 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iomanip.h"
/*********************************************************************
* flat implementation of iomanip
*********************************************************************/

////////////////////////////////////////////////////////////////////////
class setw {
 public:
  int i;
  setw(int in) {i=in;}
} ;
ostream& operator<<(ostream& ostr,setw& i) {
 ostr.width(i.i);
 return(ostr);
}

////////////////////////////////////////////////////////////////////////
class setfill {
 public:
  int i;
  setfill(int in) {i=in;}
} ;
ostream& operator<<(ostream& ostr,setfill& i) {
 ostr.fill(i.i);
 return(ostr);
}

////////////////////////////////////////////////////////////////////////
class setiosflags {
 public:
  int i;
  setiosflags(int in) {i=in;}
} ;
ostream& operator<<(ostream& ostr,setiosflags& i) {
 ostr.setf(i.i);
 return(ostr);
}

////////////////////////////////////////////////////////////////////////
class resetiosflags {
 public:
  int i;
  resetiosflags(int in) {i=in;}
} ;
ostream& operator<<(ostream& ostr,resetiosflags& i) {
 ostr.unsetf(i.i);
 return(ostr);
}

////////////////////////////////////////////////////////////////////////
class setprecision {
 public:
  int i;
  setprecision(int in) {i=in;}
} ;
ostream& operator<<(ostream& ostr,setprecision& i) {
 ostr.precision(i.i);
 return(ostr);
}


////////////////////////////////////////////////////////////////////////
class setbase {
 public:
  int i;
  setbase(int in) {i=in;}
} ;
ostream& operator<<(ostream& ostr,setbase& i) {
#pragma ifndef G__TMPLTIOS
 if(8==i.i) ostr.flags(ios::oct);
 else if(10==i.i) ostr.flags(ios::dec);
 else if(16==i.i) ostr.flags(ios::hex);
#pragma else
 if(8==i.i) ostr.flags(ios_base::oct);
 else if(10==i.i) ostr.flags(ios_base::dec);
 else if(16==i.i) ostr.flags(ios_base::hex);
#pragma endif
 return(ostr);
}
istream& operator>>(istream& istr,setbase& i) {
#pragma ifndef G__TMPLTIOS
 if(8==i.i) istr.flags(ios::oct);
 else if(10==i.i) istr.flags(ios::dec);
 else if(16==i.i) istr.flags(ios::hex);
#pragma else
 if(8==i.i) istr.flags(ios_base::oct);
 else if(10==i.i) istr.flags(ios_base::dec);
 else if(16==i.i) istr.flags(ios_base::hex);
#pragma endif
 return(istr);
}

////////////////////////////////////////////////////////////////////////
# 161 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iomanip.h"
////////////////////////////////////////////////////////////////////////
# 127 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/_iostream" 2
# 12 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iostream" 2
# 26 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/string" 2


// for reverse_iterator
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <iterator.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/iterator

#pragma ifndef PREC_STL_ITERATOR
#pragma define PREC_STL_ITERATOR
#pragma link off global PREC_STL_ITERATOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from STL HP implementation 1994
// Imported from STL SGI implementation 1997 
// Imported from ANSI/ISO C++ draft Nov 1997
// Modified by Masaharu Goto
// May need improvement for the latest standard


////////////////////////////////////////////////////////////////////////
// iterator_tag
////////////////////////////////////////////////////////////////////////
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag {};
struct bidirectional_iterator_tag {};
struct random_access_iterator_tag {};

////////////////////////////////////////////////////////////////////////
// iterator template
////////////////////////////////////////////////////////////////////////
template <class T, class Distance> struct input_iterator {};
struct output_iterator {};
template <class T, class Distance> struct forward_iterator {};
template <class T, class Distance> struct bidirectional_iterator {};
template <class T, class Distance> struct random_access_iterator {};

#pragma link off class output_iterator;







////////////////////////////////////////////////////////////////////////
// iterator_category overloaded function
////////////////////////////////////////////////////////////////////////
template <class T, class Distance>
inline input_iterator_tag
iterator_category(const input_iterator<T, Distance>&) {
    return input_iterator_tag();
}

inline output_iterator_tag iterator_category(const output_iterator&) {
    return output_iterator_tag();
}

#pragma link off function iterator_category(const output_iterator&);


template <class T, class Distance>
inline forward_iterator_tag
iterator_category(const forward_iterator<T, Distance>&) {
    return forward_iterator_tag();
}

template <class T, class Distance>
inline bidirectional_iterator_tag
iterator_category(const bidirectional_iterator<T, Distance>&) {
    return bidirectional_iterator_tag();
}

template <class T, class Distance>
inline random_access_iterator_tag
iterator_category(const random_access_iterator<T, Distance>&) {
    return random_access_iterator_tag();
}

template <class T>
inline random_access_iterator_tag
iterator_category(const T*) {
    return random_access_iterator_tag();
}


// iterator_traits, iterator and reverse_iterator template may not be
// needed for precompiled library interface 

////////////////////////////////////////////////////////////////////////
// iterator_traits
////////////////////////////////////////////////////////////////////////

template <class Iterator>
struct iterator_traits {
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type value_type;
  typedef typename Iterator::difference_type difference_type;
  typedef typename Iterator::pointer pointer;
  typedef typename Iterator::reference reference;
};

// template partial specialization, implement in cint5.15.14 1587
template <class T>
struct iterator_traits<T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
};

// incomplete implementation in cint5.15.14 1587, need some fix
// iterator_traits<const int*> is changed as iterator_traits<const int* const>
// or something, but cint5.15.14 can not handle this well
template <class T>
struct iterator_traits<const T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef const T* pointer;
  typedef const T& reference;
};

////////////////////////////////////////////////////////////////////////
// iterator
////////////////////////////////////////////////////////////////////////
template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator {
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
  typedef Category iterator_category;
};


////////////////////////////////////////////////////////////////////////
// reverse_iterator
////////////////////////////////////////////////////////////////////////






template <class Iterator>
class reverse_iterator
# 166 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
{




 public:
# 181 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
   typedef Iterator::pointer pointer;
   typedef Iterator::reference reference;
   typedef ptrdiff_t difference_type;


   reverse_iterator();
   //reverse_iterator(Iterator x);



   Iterator base() const; // explicit
   reference operator*() const;
   pointer operator->() const;
   reverse_iterator& operator++();
   reverse_iterator operator++(int);
   reverse_iterator& operator--();
   reverse_iterator operator--(int);
   reverse_iterator operator+ (difference_type n) const;
   reverse_iterator& operator+=(difference_type n);
   reverse_iterator operator- (difference_type n) const;
   reverse_iterator& operator-=(difference_type n);
   reference operator[](difference_type n) const;
};
# 932 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
// for g++ 3.1,3.2
namespace __gnu_cxx
{
  // This iterator adapter is 'normal' in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                    difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparaison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  // _GLIBCPP_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
     const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
} // namespace __gnu_cxx







#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 2
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/iterator" 2
}
# 30 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/string" 2
# 38 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/string"
//////////////////////////////////////////////////////////////////////////
class string {
 public:
  typedef char value_type;
  typedef char* pointer;
  typedef const char* const_pointer;
  typedef char& reference;
  typedef const char& const_reference;
  typedef ptrdiff_t difference_type;
  typedef size_t size_type;
  typedef int traits_type;
# 62 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/string"
  class iterator {
   public:
      iterator();
      explicit iterator(const pointer& __i) ;
      // Allow iterator to const_iterator conversion
      template<typename _Iter> inline iterator(const iterator& __i);

      // Forward iterator requirements
      reference operator*() const ;
      pointer operator->() const ;
      iterator& operator++();
      iterator operator++(int) ;

      // Bidirectional iterator requirements
      iterator& operator--() ;
      iterator operator--(int) ;

      // Random access iterator requirements
      reference operator[](const difference_type& __n) const;
      iterator& operator+=(const difference_type& __n);
      iterator operator+(const difference_type& __n) const;
      iterator& operator-=(const difference_type& __n);
      iterator operator-(const difference_type& __n) const;
      const pointer& base() const ;
  };
  typedef const iterator const_iterator;
# 183 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/string"
   typedef std::reverse_iterator<iterator> reverse_iterator;
   typedef std::reverse_iterator<const_iterator> const_reverse_iterator;



  static const size_t npos = -1;



  string() ;
  //string(size_t size,capacity cap) ;
  string(const string& str) ;
  string(const string& str,size_t pos,size_t n) ;
  string(const char* s,size_t n) ;
  string(const char* s) ;
  string(size_t rep, char c);
  //string(const vector<char>& vec);
  ~string() ;
  string& operator=(const string& str);
  string& operator=(const char* s);
  string& operator=(char c);
  string& operator+=(const string& rhs);
  string& operator+=(const char* s);
  string& operator+=(char c);
  //vector<char> operator vector<char>(void) const;
  string& append(const string& str);
  string& append(const string& str,size_t pos,size_t n);
  string& append(const char* s,size_t n);
  string& append(const char* s);
  string& append(size_t rep, char c);
  string& assign(const string& str);
  string& assign(const string& str,size_t pos,size_t n);
  string& assign(const char* s,size_t n);
  string& assign(const char* s);
  string& assign(size_t rep, char c);
  string& insert(size_t pos1,const string& str);
  string& insert(size_t pos1,const string& str,size_t pos2,size_t n);
  string& insert(size_t pos,const char* s,size_t n);
  string& insert(size_t pos,const char* s);
  string& insert(size_t pos,size_t rep,char c);
  //string& remove(size_t pos=0,size_t n=npos);
  string& replace(size_t pos1,size_t n1,const string& str);
  string& replace(size_t pos1,size_t n1,const string& str,size_t pos2,size_t n2);
  string& replace(size_t pos,size_t n1,const char* s,size_t n2);
  string& replace(size_t pos,size_t n1,const char* s);
  string& replace(size_t pos,size_t n,size_t rep,char c);
  //char get_at(size_t pos) const;
  //void put_at(size_t pos,char c);
  const char& operator[](size_t pos) const;
  char& operator[](size_t pos);
  const char& at(size_t pos) const;
  char& at(size_t pos);
  const char* c_str(void) const;
  const char* data(void) const;
  size_t length(void) const;
  void resize(size_t n,char c);
  void resize(size_t n);
  int size();
  //size_t reserve(void) const;
  void reserve(size_t res_arg);
  size_t copy(char* s,size_t n,size_t pos=0) /* const */;
  size_t find(const string& str,size_t pos=0) const;
  size_t find(const char* s,size_t pos,size_t n) const;
  size_t find(const char* s,size_t pos=0) const;
  size_t find(char c,size_t pos=0) const;
  size_t rfind(const string& str,size_t pos=npos) const;
  size_t rfind(const char* s,size_t pos,size_t n) const;
  size_t rfind(const char* s,size_t pos=npos) const;
  size_t rfind(char c,size_t pos=npos) const;
  size_t find_first_of(const string& str,size_t pos=0) const;
  size_t find_first_of(const char* s,size_t pos,size_t n) const;
  size_t find_first_of(const char* s,size_t pos=0) const;
  size_t find_first_of(char c,size_t pos=0) const;
  size_t find_last_of(const string& str,size_t pos=npos) const;
  size_t find_last_of(const char* s,size_t pos,size_t n) const;
  size_t find_last_of(const char* s,size_t pos=npos) const;
  size_t find_last_of(char c,size_t pos=npos) const;
  size_t find_first_not_of(const string& str,size_t pos=0) const;
  size_t find_first_not_of(const char* s,size_t pos,size_t n) const;
  size_t find_first_not_of(const char* s,size_t pos=0) const;
  size_t find_first_not_of(char c,size_t pos=0) const;
  size_t find_last_not_of(const string& str,size_t pos=npos) const;
  size_t find_last_not_of(const char* s,size_t pos,size_t n) const;
  size_t find_last_not_of(const char* s,size_t pos=npos) const;
  size_t find_last_not_of(char c,size_t pos=npos) const;
  string substr(size_t pos=0,size_t n=npos) const;
  int compare(const string& str) const;
  //int compare(size_type pos1,size_type n1,const string& str,size_type n2) const;
  int compare(const char* s) const ;
  //int compare(size_type pos1,size_type n1,const char* s,size_type n2=npos)const;
  //operator char*() ;

  string& erase(size_t pos=0, size_t n=npos);
  iterator erase(iterator pos);
  iterator erase(iterator first, iterator last);
# 291 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/string"
};

bool operator==(const string& a,const string& b) ;
bool operator!=(const string& a,const string& b) ;
bool operator<(const string& a,const string& b) ;
bool operator>(const string& a,const string& b) ;
bool operator<=(const string& a,const string& b) ;
bool operator>=(const string& a,const string& b) ;
string operator+(const string& a,const string& b) ;
string operator+(char a,const string& b) ;
string operator+(const string& a,char b) ;

//#ifdef G__ROOT
bool operator==(const string& a,const char *b) ;
bool operator!=(const string& a,const char *b) ;
bool operator<(const string& a,const char *b) ;
bool operator>(const string& a,const char *b) ;
bool operator<=(const string& a,const char *b) ;
bool operator>=(const string& a,const char *b) ;
string operator+(const string& a,const char *b) ;

bool operator==(const char *a,const string& b) ;
bool operator!=(const char *a,const string& b) ;
bool operator<(const char *a,const string& b) ;
bool operator>(const char *a,const string& b) ;
bool operator<=(const char *a,const string& b) ;
bool operator>=(const char *a,const string& b) ;
string operator+(const char *a,const string& b) ;
//#endif

typedef string cstring;

void swap(string& lhs,string& rhs);
istream& operator>>(istream& is, string& st);
ostream& operator<<(ostream& is, const string& st);
istream& getline(istream& is,string& st);
istream& getline(istream& is,string& st,char delim);



bool operator==(const string::iterator& _Left, const string::iterator& _Right);
bool operator!=(const string::iterator& _Left, const string::iterator& _Right);


#pragma endif
# 20 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_string" 2
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/string" 2
}
# 26 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TSchemaHelper.h" 2

namespace ROOT
{
   struct TSchemaHelper
   {
      TSchemaHelper(): fTarget(), fSourceClass(),
       fSource(), fCode(), fVersion(), fChecksum(),
       fInclude(), fEmbed(kTRUE), fFunctionPtr( 0 ),
       fAttributes() {}
      std::string fTarget;
      std::string fSourceClass;
      std::string fSource;
      std::string fCode;
      std::string fVersion;
      std::string fChecksum;
      std::string fInclude;
      Bool_t fEmbed;
      void* fFunctionPtr;
      std::string fAttributes;

      TSchemaHelper(const TSchemaHelper &tsh) :
       fTarget(tsh.fTarget), fSourceClass(tsh.fSourceClass),
       fSource(tsh.fSource), fCode(tsh.fCode), fVersion(tsh.fVersion),fChecksum(tsh.fChecksum),
       fInclude(tsh.fInclude), fEmbed(tsh.fEmbed), fFunctionPtr(tsh.fFunctionPtr),
       fAttributes(tsh.fAttributes) {}

      TSchemaHelper& operator=(const TSchemaHelper &) {return *this;} // Not implemented
   };
}
# 18 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TGenericClassInfo.h" 2
//#endif
//#ifndef ROOT_Rtypes
//#inlcude "Rtypes.h"
//#endif

// Forward declarations
class TVirtualIsAProxy;
//class TClass;
//class TClassStreamer;
//class TVirtualCollectionProxy;
//class TCollectionProxyInfo;


namespace ROOT {

   class TCollectionProxyInfo;

   class TGenericClassInfo {
      // This class in not inlined because it is used is non time critical
      // section (the dictionaries) and inline would lead to too much
      // repetition of the code (once per class!).

      const TInitBehavior *fAction;
      TClass *fClass;
      const char *fClassName;
      const char *fDeclFileName;
      Int_t fDeclFileLine;
      VoidFuncPtr_t fDictionary;
      const type_info &fInfo;
      const char *fImplFileName;
      Int_t fImplFileLine;
      TVirtualIsAProxy *fIsA;
      ShowMembersFunc_t fShowMembers;
      Int_t fVersion;
      MergeFunc_t fMerge;
      ResetAfterMergeFunc_t fResetAfterMerge;
      NewFunc_t fNew;
      NewArrFunc_t fNewArray;
      DelFunc_t fDelete;
      DelArrFunc_t fDeleteArray;
      DesFunc_t fDestructor;
      DirAutoAdd_t fDirAutoAdd;
      TClassStreamer *fStreamer;
      ClassStreamerFunc_t fStreamerFunc;
      TVirtualCollectionProxy *fCollectionProxy;
      Int_t fSizeof;
      TCollectionProxyInfo *fCollectionProxyInfo;
      TCollectionProxyInfo *fCollectionStreamerInfo;
      std::vector<ROOT::TSchemaHelper> fReadRules;
      std::vector<ROOT::TSchemaHelper> fReadRawRules;

   public:
      TGenericClassInfo(const char *fullClassname,
                       const char *declFileName, Int_t declFileLine,
                       const type_info &info, const TInitBehavior *action,
                       ShowMembersFunc_t showmembers, VoidFuncPtr_t dictionary,
                       TVirtualIsAProxy *isa, Int_t pragmabits, Int_t sizof);

      TGenericClassInfo(const char *fullClassname, Int_t version,
                       const char *declFileName, Int_t declFileLine,
                       const type_info &info, const TInitBehavior *action,
                       ShowMembersFunc_t showmembers, VoidFuncPtr_t dictionary,
                       TVirtualIsAProxy *isa, Int_t pragmabits, Int_t sizof);

      TGenericClassInfo(const char *fullClassname, Int_t version,
                       const char *declFileName, Int_t declFileLine,
                       const type_info &info, const TInitBehavior *action,
                       VoidFuncPtr_t dictionary,
                       TVirtualIsAProxy *isa, Int_t pragmabits, Int_t sizof);

      TGenericClassInfo(const char *fullClassname, Int_t version,
                        const char *declFileName, Int_t declFileLine,
                        const TInitBehavior *action,
                        VoidFuncPtr_t dictionary, Int_t pragmabits);

      void Init(Int_t pragmabits);
      ~TGenericClassInfo();

      const TInitBehavior &GetAction() const;
      TClass *GetClass();
      const char *GetClassName() const;
      TCollectionProxyInfo *GetCollectionProxyInfo() const;
      TCollectionProxyInfo *GetCollectionStreamerInfo() const;
      const char *GetDeclFileName() const;
      Int_t GetDeclFileLine() const;
      DelFunc_t GetDelete() const;
      DelArrFunc_t GetDeleteArray() const;
      DesFunc_t GetDestructor() const;
      DirAutoAdd_t GetDirectoryAutoAdd() const;
      const char *GetImplFileName();
      Int_t GetImplFileLine();
      const type_info &GetInfo() const;
      TVirtualIsAProxy *GetIsA() const;
      NewFunc_t GetNew() const;
      NewArrFunc_t GetNewArray() const;
      const std::vector<ROOT::TSchemaHelper> &GetReadRawRules() const;
      const std::vector<ROOT::TSchemaHelper> &GetReadRules() const;
      ShowMembersFunc_t GetShowMembers() const;
      Int_t GetVersion() const;

      TClass *IsA(const void *obj);

      Short_t AdoptStreamer(TClassStreamer*);
      Short_t AdoptCollectionProxy(TVirtualCollectionProxy*);
      void AdoptCollectionProxyInfo(TCollectionProxyInfo*);
      void AdoptCollectionStreamerInfo(TCollectionProxyInfo*);
      Int_t SetDeclFile(const char *file, Int_t line);
      void SetDelete(DelFunc_t deleteFunc);
      void SetDeleteArray(DelArrFunc_t deleteArrayFunc);
      void SetDestructor(DesFunc_t destructorFunc);
      void SetDirectoryAutoAdd(DirAutoAdd_t dirAutoAdd);
      void SetFromTemplate();
      Int_t SetImplFile(const char *file, Int_t line);
      void SetMerge(MergeFunc_t);
      void SetResetAfterMerge(ResetAfterMergeFunc_t);
      void SetNew(NewFunc_t newFunc);
      void SetNewArray(NewArrFunc_t newArrayFunc);
      void SetReadRawRules( const std::vector<ROOT::TSchemaHelper>& rules );
      void SetReadRules( const std::vector<ROOT::TSchemaHelper>& rules );
      Short_t SetStreamer(ClassStreamerFunc_t);
      void SetStreamerFunc(ClassStreamerFunc_t);
      Short_t SetVersion(Short_t version);

      //   protected:
   private:
      void CreateRuleSet( std::vector<ROOT::TSchemaHelper>& vect, Bool_t ProcessReadRules );
      TGenericClassInfo(const TGenericClassInfo&); // Not implemented
      TGenericClassInfo& operator=(const TGenericClassInfo&); // Not implemented

   private:
      TGenericClassInfo();

   };

}
# 268 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h" 2


// Common part of ClassDef definition.
// DeclFileLine() is not part of it since CINT uses that as trigger for
// the class comment string.
# 289 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h"
// Version without any virtual functions.
# 366 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h"
// Macro for Namespace
# 384 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h"
//---- ClassDefT macros for templates with one template argument ---------------
// ClassDefT  corresponds to ClassDef
// ClassDefT2 goes in the same header as ClassDefT but must be
//            outside the class scope
// ClassImpT  corresponds to ClassImp


// This ClassDefT is stricly redundant and is kept only for
// backward compatibility. Using #define ClassDef ClassDefT is confusing
// the CINT parser.
# 438 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h"
//---- ClassDefT macros for templates with two template arguments --------------
// ClassDef2T2 goes in the same header as ClassDefT but must be
//             outside the class scope
// ClassImp2T  corresponds to ClassImpT





//---- ClassDefT macros for templates with three template arguments ------------
// ClassDef3T2 goes in the same header as ClassDefT but must be
//             outside the class scope
// ClassImp3T  corresponds to ClassImpT





//---- Macro to set the class version of non instrumented classes --------------
# 32 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TObject.h" 2


# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TStorage.h" 1
// @(#)root/base:$Id: TStorage.h 27683 2009-03-03 20:15:49Z pcanal $
// Author: Fons Rademakers   29/07/95

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/





//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TStorage                                                             //
//                                                                      //
// Storage manager.                                                     //
//                                                                      //
//////////////////////////////////////////////////////////////////////////





typedef void (*FreeHookFun_t)(void*, void *addr, size_t);
typedef void *(*ReAllocFun_t)(void*, size_t);
typedef void *(*ReAllocCFun_t)(void*, size_t, size_t);
typedef char *(*ReAllocCharFun_t)(char*, size_t, size_t);


class TStorage {

private:
   static ULong_t fgHeapBegin; // begin address of heap
   static ULong_t fgHeapEnd; // end address of heap
   static size_t fgMaxBlockSize; // largest block allocated
   static FreeHookFun_t fgFreeHook; // function called on free
   static void *fgFreeHookData; // data used by this function
   static ReAllocFun_t fgReAllocHook; // custom ReAlloc
   static ReAllocCFun_t fgReAllocCHook; // custom ReAlloc with length check
   static Bool_t fgHasCustomNewDelete; // true if using ROOT's new/delete

public:
   virtual ~TStorage() { }

   static ULong_t GetHeapBegin();
   static ULong_t GetHeapEnd();
   static FreeHookFun_t GetFreeHook();
   static void *GetFreeHookData();
   static size_t GetMaxBlockSize();
   static void *Alloc(size_t size);
   static void Dealloc(void *ptr);
   static void *ReAlloc(void *vp, size_t size);
   static void *ReAlloc(void *vp, size_t size, size_t oldsize);
   static char *ReAllocChar(char *vp, size_t size, size_t oldsize);
   static Int_t *ReAllocInt(Int_t *vp, size_t size, size_t oldsize);
   static void *ObjectAlloc(size_t size);
   static void *ObjectAlloc(size_t size, void *vp);
   static void ObjectDealloc(void *vp);
   static void ObjectDealloc(void *vp, void *ptr);

   static void EnterStat(size_t size, void *p);
   static void RemoveStat(void *p);
   static void PrintStatistics();
   static void SetMaxBlockSize(size_t size);
   static void SetFreeHook(FreeHookFun_t func, void *data);
   static void SetReAllocHooks(ReAllocFun_t func1, ReAllocCFun_t func2);
   static void SetCustomNewDelete();
   static void EnableStatistics(int size= -1, int ix= -1);

   static Bool_t HasCustomNewDelete();

   // only valid after call to a TStorage allocating method
   static void AddToHeap(ULong_t begin, ULong_t end);
   static Bool_t IsOnHeap(void *p);

   private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 0; } static void Dictionary(); virtual TClass *IsA() const { return TStorage::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { TStorage::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TStorage.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 80; } //Storage manager class
};


inline void TStorage::AddToHeap(ULong_t begin, ULong_t end)
   { if (begin < fgHeapBegin) fgHeapBegin = begin;
     if (end > fgHeapEnd) fgHeapEnd = end; }

inline Bool_t TStorage::IsOnHeap(void *p)
   { return (ULong_t)p >= fgHeapBegin && (ULong_t)p < fgHeapEnd; }

inline size_t TStorage::GetMaxBlockSize() { return fgMaxBlockSize; }

inline void TStorage::SetMaxBlockSize(size_t size) { fgMaxBlockSize = size; }

inline FreeHookFun_t TStorage::GetFreeHook() { return fgFreeHook; }
# 35 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TObject.h" 2


# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TVersionCheck.h" 1
// @(#)root/base:$Id: TVersionCheck.h 20877 2007-11-19 11:17:07Z rdm $
// Author: Fons Rademakers   9/5/2007

/*************************************************************************
 * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/




//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TVersionCheck                                                        //
//                                                                      //
// Used to check if the shared library or plugin is compatible with     //
// the current version of ROOT.                                         //
//                                                                      //
//////////////////////////////////////////////////////////////////////////





class TVersionCheck {
public:
   TVersionCheck(int versionCode); // implemented in TSystem.cxx
};
# 38 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TObject.h" 2


# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Riosfwd.h" 1
// @(#)root/base:$Id: Riosfwd.h 20877 2007-11-19 11:17:07Z rdm $
// Author: Fons Rademakers   23/1/02

/*************************************************************************
 * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/





//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Riosfwd                                                              //
//                                                                      //
// This headers is only supposed to be used in header files.            //
// Never in sources, in source files use the companion Riostream.h.     //
//                                                                      //
//////////////////////////////////////////////////////////////////////////
# 33 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Riosfwd.h"
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iosfwd" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iosfwd.h" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/


# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iostream.h" 1
/* /% C++ %/ */
/***********************************************************************
 * cint (C/C++ interpreter)
 ************************************************************************
 * I/O stream header file iostream.h
 ************************************************************************
 * Description:
 *  CINT iostream header file
 ************************************************************************
 * Copyright(c) 1995~1999  Masaharu Goto 
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
# 11 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iosfwd.h" 2
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iosfwd" 2
}
# 34 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Riosfwd.h" 2

using std::istream;
using std::ostream;
using std::fstream;
using std::ifstream;
using std::ofstream;
# 41 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TObject.h" 2

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/stdarg.h" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
/****************************************************************
* stdarg.h
*****************************************************************/



struct va_list {
  void* libp;
  int ip;
} ;
# 43 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TObject.h" 2





class TList;
class TBrowser;
class TBuffer;
class TObjArray;
class TMethod;
class TTimer;


class TObject {

private:
   UInt_t fUniqueID; //object unique identifier
   UInt_t fBits; //bit field status word

   static Long_t fgDtorOnly; //object for which to call dtor only (i.e. no delete)
   static Bool_t fgObjectStat; //if true keep track of objects in TObjectTable

protected:
   void MakeZombie() { fBits |= kZombie; }
   virtual void DoError(int level, const char *location, const char *fmt, va_list va) const;

public:
   //----- Global bits (can be set for any object and should not be reused).
   //----- Bits 0 - 13 are reserved as global bits. Bits 14 - 23 can be used
   //----- in different class hierarchies (make sure there is no overlap in
   //----- any given hierarchy).
   enum EStatusBits {
      kCanDelete = (1ULL << (0)), // if object in a list can be deleted
      kMustCleanup = (1ULL << (3)), // if object destructor must call RecursiveRemove()
      kObjInCanvas = (1ULL << (3)), // for backward compatibility only, use kMustCleanup
      kIsReferenced = (1ULL << (4)), // if object is referenced by a TRef or TRefArray
      kHasUUID = (1ULL << (5)), // if object has a TUUID (its fUniqueID=UUIDNumber)
      kCannotPick = (1ULL << (6)), // if object in a pad cannot be picked
      kNoContextMenu = (1ULL << (8)), // if object does not want context menu
      kInvalidObject = (1ULL << (13)) // if object ctor succeeded but object should not be used
   };

   //----- Private bits, clients can only test but not change them
   enum {
      kIsOnHeap = 0x01000000, // object is on heap
      kNotDeleted = 0x02000000, // object has not been deleted
      kZombie = 0x04000000, // object ctor failed
      kBitMask = 0x00ffffff
   };

   //----- Write() options
   enum {
      kSingleKey = (1ULL << (0)), // write collection with single key
      kOverwrite = (1ULL << (1)), // overwrite existing object with same name
      kWriteDelete = (1ULL << (2)) // write object, then delete previous key with same name
   };

   TObject();
   TObject(const TObject &object);
   TObject &operator=(const TObject &rhs);
   virtual ~TObject();

   virtual void AppendPad(Option_t *option="");
   virtual void Browse(TBrowser *b);
   virtual const char *ClassName() const;
   virtual void Clear(Option_t * /*option*/ ="") { }
   virtual TObject *Clone(const char *newname="") const;
   virtual Int_t Compare(const TObject *obj) const;
   virtual void Copy(TObject &object) const;
   virtual void Delete(Option_t *option=""); // *MENU*
   virtual Int_t DistancetoPrimitive(Int_t px, Int_t py);
   virtual void Draw(Option_t *option="");
   virtual void DrawClass() const; // *MENU*
   virtual TObject *DrawClone(Option_t *option="") const; // *MENU*
   virtual void Dump() const; // *MENU*
   virtual void Execute(const char *method, const char *params, Int_t *error=0);
   virtual void Execute(TMethod *method, TObjArray *params, Int_t *error=0);
   virtual void ExecuteEvent(Int_t event, Int_t px, Int_t py);
   virtual TObject *FindObject(const char *name) const;
   virtual TObject *FindObject(const TObject *obj) const;
   virtual Option_t *GetDrawOption() const;
   virtual UInt_t GetUniqueID() const;
   virtual const char *GetName() const;
   virtual const char *GetIconName() const;
   virtual Option_t *GetOption() const { return ""; }
   virtual char *GetObjectInfo(Int_t px, Int_t py) const;
   virtual const char *GetTitle() const;
   virtual Bool_t HandleTimer(TTimer *timer);
   virtual ULong_t Hash() const;
   virtual Bool_t InheritsFrom(const char *classname) const;
   virtual Bool_t InheritsFrom(const TClass *cl) const;
   virtual void Inspect() const; // *MENU*
   virtual Bool_t IsFolder() const;
   virtual Bool_t IsEqual(const TObject *obj) const;
   virtual Bool_t IsSortable() const { return kFALSE; }
           Bool_t IsOnHeap() const { return TestBit(kIsOnHeap); }
           Bool_t IsZombie() const { return TestBit(kZombie); }
   virtual Bool_t Notify();
   virtual void ls(Option_t *option="") const;
   virtual void Paint(Option_t *option="");
   virtual void Pop();
   virtual void Print(Option_t *option="") const;
   virtual Int_t Read(const char *name);
   virtual void RecursiveRemove(TObject *obj);
   virtual void SaveAs(const char *filename="",Option_t *option="") const; // *MENU*
   virtual void SavePrimitive(ostream &out, Option_t *option = "");
   virtual void SetDrawOption(Option_t *option=""); // *MENU*
   virtual void SetUniqueID(UInt_t uid);
   virtual void UseCurrentStyle();
   virtual Int_t Write(const char *name=0, Int_t option=0, Int_t bufsize=0);
   virtual Int_t Write(const char *name=0, Int_t option=0, Int_t bufsize=0) const;

   //----- operators
   void *operator new(size_t sz) { return TStorage::ObjectAlloc(sz); }
   void *operator new[](size_t sz) { return TStorage::ObjectAlloc(sz); }
   void *operator new(size_t sz, void *vp) { return TStorage::ObjectAlloc(sz, vp); }
   void *operator new[](size_t sz, void *vp) { return TStorage::ObjectAlloc(sz, vp); }
   void operator delete(void *ptr);
   void operator delete[](void *ptr);

   void operator delete(void *ptr, void *vp);
   void operator delete[](void *ptr, void *vp);


   //----- bit manipulation
   void SetBit(UInt_t f, Bool_t set);
   void SetBit(UInt_t f) { fBits |= f & kBitMask; }
   void ResetBit(UInt_t f) { fBits &= ~(f & kBitMask); }
   Bool_t TestBit(UInt_t f) const { return (Bool_t) ((fBits & f) != 0); }
   Int_t TestBits(UInt_t f) const { return (Int_t) (fBits & f); }
   void InvertBit(UInt_t f) { fBits ^= f & kBitMask; }

   //---- error handling
   virtual void Info(const char *method, const char *msgfmt, ...) const



   ;
   virtual void Warning(const char *method, const char *msgfmt, ...) const



   ;
   virtual void Error(const char *method, const char *msgfmt, ...) const



   ;
   virtual void SysError(const char *method, const char *msgfmt, ...) const



   ;
   virtual void Fatal(const char *method, const char *msgfmt, ...) const



   ;

   void AbstractMethod(const char *method) const;
   void MayNotUse(const char *method) const;
   void Obsolete(const char *method, const char *asOfVers, const char *removedFromVers) const;

   //---- static functions
   static Long_t GetDtorOnly();
   static void SetDtorOnly(void *obj);
   static Bool_t GetObjectStat();
   static void SetObjectStat(Bool_t stat);

   private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return TObject::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { TObject::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TObject.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 212; } //Basic ROOT object
};

// Global bits (can be set for any object and should not be reused).
// Only here for backward compatibility reasons.
// For detailed description see TObject::EStatusBits above.
enum EObjBits {
   kCanDelete = TObject::kCanDelete,
   kMustCleanup = TObject::kMustCleanup,
   kObjInCanvas = TObject::kObjInCanvas,
   kIsReferenced = TObject::kIsReferenced,
   kHasUUID = TObject::kHasUUID,
   kCannotPick = TObject::kCannotPick,
   kNoContextMenu = TObject::kNoContextMenu,
   kInvalidObject = TObject::kInvalidObject
};


# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TBuffer.h" 1
// @(#)root/base:$Id: TBuffer.h 40872 2011-09-13 21:33:33Z pcanal $
// Author: Rene Brun, Philippe Canal, Fons Rademakers   04/05/96

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/





//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TBuffer                                                              //
//                                                                      //
// Buffer base class used for serializing objects.                      //
//                                                                      //
//////////////////////////////////////////////////////////////////////////





class TVirtualStreamerInfo;
class TStreamerElement;
class TClass;
class TString;
class TProcessID;
class TClonesArray;
class TRefTable;
class TVirtualArray;
namespace TStreamerInfoActions {
   class TActionSequence;
}

class TBuffer : public TObject {

protected:
   typedef std::vector<TVirtualArray*> CacheList_t;

   Bool_t fMode; //Read or write mode
   Int_t fVersion; //Buffer format version
   Int_t fBufSize; //Size of buffer
   char *fBuffer; //Buffer used to store objects
   char *fBufCur; //Current position in buffer
   char *fBufMax; //End of buffer
   TObject *fParent; //Pointer to parent object owning this buffer
   ReAllocCharFun_t fReAllocFunc; //! Realloc function to be used when extending the buffer.
   CacheList_t fCacheStack; //Stack of pointers to the cache where to temporarily store the value of 'missing' data members

   // Default ctor
   TBuffer() : TObject(), fMode(0), fVersion(0), fBufSize(0), fBuffer(0),
     fBufCur(0), fBufMax(0), fParent(0), fReAllocFunc(0), fCacheStack(0,(TVirtualArray*)0) {}

   // TBuffer objects cannot be copied or assigned
   TBuffer(const TBuffer &); // not implemented
   void operator=(const TBuffer &); // not implemented

   Int_t Read(const char *name) { return TObject::Read(name); }
   Int_t Write(const char *name, Int_t opt, Int_t bufs)
                              { return TObject::Write(name, opt, bufs); }
   Int_t Write(const char *name, Int_t opt, Int_t bufs) const
                              { return TObject::Write(name, opt, bufs); }

public:
   enum EMode { kRead = 0, kWrite = 1 };
   enum { kIsOwner = (1ULL << (16)) }; //if set TBuffer owns fBuffer
   enum { kCannotHandleMemberWiseStreaming = (1ULL << (17))}; //if set TClonesArray should not use member wise streaming
   enum { kInitialSize = 1024, kMinimalSize = 128 };

   TBuffer(EMode mode);
   TBuffer(EMode mode, Int_t bufsiz);
   TBuffer(EMode mode, Int_t bufsiz, void *buf, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0);
   virtual ~TBuffer();

   Int_t GetBufferVersion() const { return fVersion; }
   Bool_t IsReading() const { return (fMode & kWrite) == 0; }
   Bool_t IsWriting() const { return (fMode & kWrite) != 0; }
   void SetReadMode();
   void SetWriteMode();
   void SetBuffer(void *buf, UInt_t bufsiz = 0, Bool_t adopt = kTRUE, ReAllocCharFun_t reallocfunc = 0);
   ReAllocCharFun_t GetReAllocFunc() const;
   void SetReAllocFunc(ReAllocCharFun_t reallocfunc = 0);
   void SetBufferOffset(Int_t offset = 0) { fBufCur = fBuffer+offset; }
   void SetParent(TObject *parent);
   TObject *GetParent() const;
   char *Buffer() const { return fBuffer; }
   Int_t BufferSize() const { return fBufSize; }
   void DetachBuffer() { fBuffer = 0; }
   Int_t Length() const { return (Int_t)(fBufCur - fBuffer); }
   void Expand(Int_t newsize, Bool_t copy = kTRUE); // expand buffer to newsize
   void AutoExpand(Int_t size_needed); // expand buffer to newsize

   virtual Bool_t CheckObject(const TObject *obj) = 0;
   virtual Bool_t CheckObject(const void *obj, const TClass *ptrClass) = 0;

   virtual Int_t ReadBuf(void *buf, Int_t max) = 0;
   virtual void WriteBuf(const void *buf, Int_t max) = 0;

   virtual char *ReadString(char *s, Int_t max) = 0;
   virtual void WriteString(const char *s) = 0;

   virtual Int_t GetVersionOwner() const = 0;
   virtual Int_t GetMapCount() const = 0;
   virtual void GetMappedObject(UInt_t tag, void* &ptr, TClass* &ClassPtr) const = 0;
   virtual void MapObject(const TObject *obj, UInt_t offset = 1) = 0;
   virtual void MapObject(const void *obj, const TClass *cl, UInt_t offset = 1) = 0;
   virtual void Reset() = 0;
   virtual void InitMap() = 0;
   virtual void ResetMap() = 0;
   virtual void SetReadParam(Int_t mapsize) = 0;
   virtual void SetWriteParam(Int_t mapsize) = 0;

   virtual Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass *clss) = 0;
   virtual Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const char *classname) = 0;
   virtual void SetByteCount(UInt_t cntpos, Bool_t packInVersion = kFALSE)= 0;

   virtual void SkipVersion(const TClass *cl = 0) = 0;
   virtual Version_t ReadVersion(UInt_t *start = 0, UInt_t *bcnt = 0, const TClass *cl = 0) = 0;
   virtual Version_t ReadVersionForMemberWise(const TClass *cl = 0) = 0;
   virtual UInt_t WriteVersion(const TClass *cl, Bool_t useBcnt = kFALSE) = 0;
   virtual UInt_t WriteVersionMemberWise(const TClass *cl, Bool_t useBcnt = kFALSE) = 0;

   virtual void *ReadObjectAny(const TClass* cast) = 0;
   virtual void SkipObjectAny() = 0;

   virtual void TagStreamerInfo(TVirtualStreamerInfo* info) = 0;
   virtual void IncrementLevel(TVirtualStreamerInfo* info) = 0;
   virtual void SetStreamerElementNumber(Int_t) = 0;
   virtual void DecrementLevel(TVirtualStreamerInfo*) = 0;

   virtual void ClassBegin(const TClass*, Version_t = -1) = 0;
   virtual void ClassEnd(const TClass*) = 0;
   virtual void ClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1) = 0;
   virtual TVirtualStreamerInfo *GetInfo() = 0;

   virtual TVirtualArray *PeekDataCache() const;
   virtual TVirtualArray *PopDataCache();
   virtual void PushDataCache(TVirtualArray *);

   virtual TClass *ReadClass(const TClass *cl = 0, UInt_t *objTag = 0) = 0;
   virtual void WriteClass(const TClass *cl) = 0;

   virtual TObject *ReadObject(const TClass *cl) = 0;
   virtual void WriteObject(const TObject *obj) = 0;

   virtual Int_t WriteObjectAny(const void *obj, const TClass *ptrClass) = 0;

   virtual UShort_t GetPidOffset() const = 0;
   virtual void SetPidOffset(UShort_t offset) = 0;
   virtual Int_t GetBufferDisplacement() const = 0;
   virtual void SetBufferDisplacement() = 0;
   virtual void SetBufferDisplacement(Int_t skipped) = 0;

   // basic types and arrays of basic types
   virtual void ReadFloat16 (Float_t *f, TStreamerElement *ele=0) = 0;
   virtual void WriteFloat16(Float_t *f, TStreamerElement *ele=0) = 0;
   virtual void ReadDouble32 (Double_t *d, TStreamerElement *ele=0) = 0;
   virtual void WriteDouble32(Double_t *d, TStreamerElement *ele=0) = 0;
   virtual void ReadWithFactor(Float_t *ptr, Double_t factor, Double_t minvalue) = 0;
   virtual void ReadWithNbits(Float_t *ptr, Int_t nbits) = 0;
   virtual void ReadWithFactor(Double_t *ptr, Double_t factor, Double_t minvalue) = 0;
   virtual void ReadWithNbits(Double_t *ptr, Int_t nbits) = 0;

   virtual Int_t ReadArray(Bool_t *&b) = 0;
   virtual Int_t ReadArray(Char_t *&c) = 0;
   virtual Int_t ReadArray(UChar_t *&c) = 0;
   virtual Int_t ReadArray(Short_t *&h) = 0;
   virtual Int_t ReadArray(UShort_t *&h) = 0;
   virtual Int_t ReadArray(Int_t *&i) = 0;
   virtual Int_t ReadArray(UInt_t *&i) = 0;
   virtual Int_t ReadArray(Long_t *&l) = 0;
   virtual Int_t ReadArray(ULong_t *&l) = 0;
   virtual Int_t ReadArray(Long64_t *&l) = 0;
   virtual Int_t ReadArray(ULong64_t *&l) = 0;
   virtual Int_t ReadArray(Float_t *&f) = 0;
   virtual Int_t ReadArray(Double_t *&d) = 0;
   virtual Int_t ReadArrayFloat16(Float_t *&f, TStreamerElement *ele=0) = 0;
   virtual Int_t ReadArrayDouble32(Double_t *&d, TStreamerElement *ele=0) = 0;

   virtual Int_t ReadStaticArray(Bool_t *b) = 0;
   virtual Int_t ReadStaticArray(Char_t *c) = 0;
   virtual Int_t ReadStaticArray(UChar_t *c) = 0;
   virtual Int_t ReadStaticArray(Short_t *h) = 0;
   virtual Int_t ReadStaticArray(UShort_t *h) = 0;
   virtual Int_t ReadStaticArray(Int_t *i) = 0;
   virtual Int_t ReadStaticArray(UInt_t *i) = 0;
   virtual Int_t ReadStaticArray(Long_t *l) = 0;
   virtual Int_t ReadStaticArray(ULong_t *l) = 0;
   virtual Int_t ReadStaticArray(Long64_t *l) = 0;
   virtual Int_t ReadStaticArray(ULong64_t *l) = 0;
   virtual Int_t ReadStaticArray(Float_t *f) = 0;
   virtual Int_t ReadStaticArray(Double_t *d) = 0;
   virtual Int_t ReadStaticArrayFloat16(Float_t *f, TStreamerElement *ele=0) = 0;
   virtual Int_t ReadStaticArrayDouble32(Double_t *d, TStreamerElement *ele=0) = 0;

   virtual void ReadFastArray(Bool_t *b, Int_t n) = 0;
   virtual void ReadFastArray(Char_t *c, Int_t n) = 0;
   virtual void ReadFastArrayString(Char_t *c, Int_t n) = 0;
   virtual void ReadFastArray(UChar_t *c, Int_t n) = 0;
   virtual void ReadFastArray(Short_t *h, Int_t n) = 0;
   virtual void ReadFastArray(UShort_t *h, Int_t n) = 0;
   virtual void ReadFastArray(Int_t *i, Int_t n) = 0;
   virtual void ReadFastArray(UInt_t *i, Int_t n) = 0;
   virtual void ReadFastArray(Long_t *l, Int_t n) = 0;
   virtual void ReadFastArray(ULong_t *l, Int_t n) = 0;
   virtual void ReadFastArray(Long64_t *l, Int_t n) = 0;
   virtual void ReadFastArray(ULong64_t *l, Int_t n) = 0;
   virtual void ReadFastArray(Float_t *f, Int_t n) = 0;
   virtual void ReadFastArray(Double_t *d, Int_t n) = 0;
   virtual void ReadFastArrayFloat16(Float_t *f, Int_t n, TStreamerElement *ele=0) = 0;
   virtual void ReadFastArrayDouble32(Double_t *d, Int_t n, TStreamerElement *ele=0) = 0;
   virtual void ReadFastArray(void *start , const TClass *cl, Int_t n=1, TMemberStreamer *s=0, const TClass *onFileClass=0) = 0;
   virtual void ReadFastArray(void **startp, const TClass *cl, Int_t n=1, Bool_t isPreAlloc=kFALSE, TMemberStreamer *s=0, const TClass *onFileClass=0) = 0;

   virtual void WriteArray(const Bool_t *b, Int_t n) = 0;
   virtual void WriteArray(const Char_t *c, Int_t n) = 0;
   virtual void WriteArray(const UChar_t *c, Int_t n) = 0;
   virtual void WriteArray(const Short_t *h, Int_t n) = 0;
   virtual void WriteArray(const UShort_t *h, Int_t n) = 0;
   virtual void WriteArray(const Int_t *i, Int_t n) = 0;
   virtual void WriteArray(const UInt_t *i, Int_t n) = 0;
   virtual void WriteArray(const Long_t *l, Int_t n) = 0;
   virtual void WriteArray(const ULong_t *l, Int_t n) = 0;
   virtual void WriteArray(const Long64_t *l, Int_t n) = 0;
   virtual void WriteArray(const ULong64_t *l, Int_t n) = 0;
   virtual void WriteArray(const Float_t *f, Int_t n) = 0;
   virtual void WriteArray(const Double_t *d, Int_t n) = 0;
   virtual void WriteArrayFloat16(const Float_t *f, Int_t n, TStreamerElement *ele=0) = 0;
   virtual void WriteArrayDouble32(const Double_t *d, Int_t n, TStreamerElement *ele=0) = 0;

   virtual void WriteFastArray(const Bool_t *b, Int_t n) = 0;
   virtual void WriteFastArray(const Char_t *c, Int_t n) = 0;
   virtual void WriteFastArrayString(const Char_t *c, Int_t n) = 0;
   virtual void WriteFastArray(const UChar_t *c, Int_t n) = 0;
   virtual void WriteFastArray(const Short_t *h, Int_t n) = 0;
   virtual void WriteFastArray(const UShort_t *h, Int_t n) = 0;
   virtual void WriteFastArray(const Int_t *i, Int_t n) = 0;
   virtual void WriteFastArray(const UInt_t *i, Int_t n) = 0;
   virtual void WriteFastArray(const Long_t *l, Int_t n) = 0;
   virtual void WriteFastArray(const ULong_t *l, Int_t n) = 0;
   virtual void WriteFastArray(const Long64_t *l, Int_t n) = 0;
   virtual void WriteFastArray(const ULong64_t *l, Int_t n) = 0;
   virtual void WriteFastArray(const Float_t *f, Int_t n) = 0;
   virtual void WriteFastArray(const Double_t *d, Int_t n) = 0;
   virtual void WriteFastArrayFloat16(const Float_t *f, Int_t n, TStreamerElement *ele=0) = 0;
   virtual void WriteFastArrayDouble32(const Double_t *d, Int_t n, TStreamerElement *ele=0) = 0;
   virtual void WriteFastArray(void *start, const TClass *cl, Int_t n=1, TMemberStreamer *s=0) = 0;
   virtual Int_t WriteFastArray(void **startp, const TClass *cl, Int_t n=1, Bool_t isPreAlloc=kFALSE, TMemberStreamer *s=0) = 0;

   virtual void StreamObject(void *obj, const type_info &typeinfo, const TClass* onFileClass = 0 ) = 0;
   virtual void StreamObject(void *obj, const char *className, const TClass* onFileClass = 0 ) = 0;
   virtual void StreamObject(void *obj, const TClass *cl, const TClass* onFileClass = 0 ) = 0;
   virtual void StreamObject(TObject *obj) = 0;

   virtual void ReadBool(Bool_t &b) = 0;
   virtual void ReadChar(Char_t &c) = 0;
   virtual void ReadUChar(UChar_t &c) = 0;
   virtual void ReadShort(Short_t &s) = 0;
   virtual void ReadUShort(UShort_t &s) = 0;
   virtual void ReadInt(Int_t &i) = 0;
   virtual void ReadUInt(UInt_t &i) = 0;
   virtual void ReadLong(Long_t &l) = 0;
   virtual void ReadULong(ULong_t &l) = 0;
   virtual void ReadLong64(Long64_t &l) = 0;
   virtual void ReadULong64(ULong64_t &l) = 0;
   virtual void ReadFloat(Float_t &f) = 0;
   virtual void ReadDouble(Double_t &d) = 0;
   virtual void ReadCharP(Char_t *c) = 0;
   virtual void ReadTString(TString &s) = 0;

   virtual void WriteBool(Bool_t b) = 0;
   virtual void WriteChar(Char_t c) = 0;
   virtual void WriteUChar(UChar_t c) = 0;
   virtual void WriteShort(Short_t s) = 0;
   virtual void WriteUShort(UShort_t s) = 0;
   virtual void WriteInt(Int_t i) = 0;
   virtual void WriteUInt(UInt_t i) = 0;
   virtual void WriteLong(Long_t l) = 0;
   virtual void WriteULong(ULong_t l) = 0;
   virtual void WriteLong64(Long64_t l) = 0;
   virtual void WriteULong64(ULong64_t l) = 0;
   virtual void WriteFloat(Float_t f) = 0;
   virtual void WriteDouble(Double_t d) = 0;
   virtual void WriteCharP(const Char_t *c) = 0;
   virtual void WriteTString(const TString &s) = 0;

   // Special basic ROOT objects and collections
   virtual TProcessID *GetLastProcessID(TRefTable *reftable) const = 0;
   virtual UInt_t GetTRefExecId() = 0;
   virtual TProcessID *ReadProcessID(UShort_t pidf) = 0;
   virtual UShort_t WriteProcessID(TProcessID *pid) = 0;

   // Utilities for TStreamerInfo
   virtual void ForceWriteInfo(TVirtualStreamerInfo *info, Bool_t force) = 0;
   virtual void ForceWriteInfoClones(TClonesArray *a) = 0;
   virtual Int_t ReadClones (TClonesArray *a, Int_t nobjects, Version_t objvers) = 0;
   virtual Int_t WriteClones(TClonesArray *a, Int_t nobjects) = 0;

   // Utilities for TClass
   virtual Int_t ReadClassEmulated(const TClass *cl, void *object, const TClass *onfile_class = 0) = 0;
   virtual Int_t ReadClassBuffer(const TClass *cl, void *pointer, const TClass *onfile_class = 0) = 0;
   virtual Int_t ReadClassBuffer(const TClass *cl, void *pointer, Int_t version, UInt_t start, UInt_t count, const TClass *onfile_class = 0) = 0;
   virtual Int_t WriteClassBuffer(const TClass *cl, void *pointer) = 0;

   // Utilites to streamer using sequences.
   virtual Int_t ApplySequence(const TStreamerInfoActions::TActionSequence &sequence, void *object) = 0;
   virtual Int_t ApplySequenceVecPtr(const TStreamerInfoActions::TActionSequence &sequence, void *start_collection, void *end_collection) = 0;
   virtual Int_t ApplySequence(const TStreamerInfoActions::TActionSequence &sequence, void *start_collection, void *end_collection) = 0;

   static TClass *GetClass(const type_info &typeinfo);
   static TClass *GetClass(const char *className);

   private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 0; } static void Dictionary(); virtual TClass *IsA() const { return TBuffer::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { TBuffer::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TBuffer.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 318; } //Buffer base class used for serializing objects
};

//---------------------- TBuffer default external operators --------------------

inline TBuffer &operator>>(TBuffer &buf, Bool_t &b) { buf.ReadBool(b); return buf; }
inline TBuffer &operator>>(TBuffer &buf, Char_t &c) { buf.ReadChar(c); return buf; }
inline TBuffer &operator>>(TBuffer &buf, UChar_t &c) { buf.ReadUChar(c); return buf; }
inline TBuffer &operator>>(TBuffer &buf, Short_t &s) { buf.ReadShort(s); return buf; }
inline TBuffer &operator>>(TBuffer &buf, UShort_t &s) { buf.ReadUShort(s); return buf; }
inline TBuffer &operator>>(TBuffer &buf, Int_t &i) { buf.ReadInt(i); return buf; }
inline TBuffer &operator>>(TBuffer &buf, UInt_t &i) { buf.ReadUInt(i); return buf; }
inline TBuffer &operator>>(TBuffer &buf, Long_t &l) { buf.ReadLong(l); return buf; }
inline TBuffer &operator>>(TBuffer &buf, ULong_t &l) { buf.ReadULong(l); return buf; }
inline TBuffer &operator>>(TBuffer &buf, Long64_t &l) { buf.ReadLong64(l); return buf; }
inline TBuffer &operator>>(TBuffer &buf, ULong64_t &l){ buf.ReadULong64(l);return buf; }
inline TBuffer &operator>>(TBuffer &buf, Float_t &f) { buf.ReadFloat(f); return buf; }
inline TBuffer &operator>>(TBuffer &buf, Double_t &d) { buf.ReadDouble(d); return buf; }
inline TBuffer &operator>>(TBuffer &buf, Char_t *c) { buf.ReadCharP(c); return buf; }
inline TBuffer &operator>>(TBuffer &buf, TString &s) { buf.ReadTString(s);return buf; }

inline TBuffer &operator<<(TBuffer &buf, Bool_t b) { buf.WriteBool(b); return buf; }
inline TBuffer &operator<<(TBuffer &buf, Char_t c) { buf.WriteChar(c); return buf; }
inline TBuffer &operator<<(TBuffer &buf, UChar_t c) { buf.WriteUChar(c); return buf; }
inline TBuffer &operator<<(TBuffer &buf, Short_t s) { buf.WriteShort(s); return buf; }
inline TBuffer &operator<<(TBuffer &buf, UShort_t s) { buf.WriteUShort(s); return buf; }
inline TBuffer &operator<<(TBuffer &buf, Int_t i) { buf.WriteInt(i); return buf; }
inline TBuffer &operator<<(TBuffer &buf, UInt_t i) { buf.WriteUInt(i); return buf; }
inline TBuffer &operator<<(TBuffer &buf, Long_t l) { buf.WriteLong(l); return buf; }
inline TBuffer &operator<<(TBuffer &buf, ULong_t l) { buf.WriteULong(l); return buf; }
inline TBuffer &operator<<(TBuffer &buf, Long64_t l) { buf.WriteLong64(l); return buf; }
inline TBuffer &operator<<(TBuffer &buf, ULong64_t l){ buf.WriteULong64(l);return buf; }
inline TBuffer &operator<<(TBuffer &buf, Float_t f) { buf.WriteFloat(f); return buf; }
inline TBuffer &operator<<(TBuffer &buf, Double_t d) { buf.WriteDouble(d); return buf; }
inline TBuffer &operator<<(TBuffer &buf, const Char_t *c) { buf.WriteCharP(c); return buf; }
inline TBuffer &operator<<(TBuffer &buf, const TString &s) { buf.WriteTString(s);return buf; }
# 385 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TBuffer.h"
template <class Tmpl> TBuffer &operator>>(TBuffer &buf, Tmpl *&obj);
template <class Tmpl> TBuffer &operator<<(TBuffer &buf, Tmpl *&obj);






inline TBuffer &operator<<(TBuffer &buf, const TObject *obj)
   { buf.WriteObjectAny(obj, TObject::Class()); return buf; }
# 231 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TObject.h" 2
# 2 "/tmp/rootcint_85GekZ.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TMemberInspector.h" 1
// @(#)root/base:$Id: TMemberInspector.h 43276 2012-03-07 17:13:42Z pcanal $
// Author: Fons Rademakers   15/07/96

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/




//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TMemberInspector                                                     //
//                                                                      //
// Abstract base class for accessing the datamembers of a class.        //
// Classes derived from this class can be given as argument to the      //
// ShowMembers() methods of ROOT classes. This feature facilitates      //
// the writing of class browsers and inspectors.                        //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h" 1
/* @(#)root/base:$Id: Rtypes.h 43708 2012-04-12 10:19:00Z axel $ */

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TMemberInspector.h" 2

class TObject;
class TClass;

class TMemberInspector {
private:
   class TParentBuf;
   TParentBuf* fParent; // current inspection "path"

   TMemberInspector(const TMemberInspector&); // Not implemented.
   TMemberInspector &operator=(const TMemberInspector&); // Not implemented.

public:
   TMemberInspector();
   virtual ~TMemberInspector();

   virtual void Inspect(TClass *cl, const char *parent, const char *name, const void *addr) = 0;

   const char* GetParent() const;
   Ssiz_t GetParentLen() const;
   void AddToParent(const char* name);
   void RemoveFromParent(Ssiz_t startingAt);

   template <class T>
   void InspectMember(T& obj, const char* name) {
      Ssiz_t len = GetParentLen();
      AddToParent(name);
      obj.ShowMembers(*this);
      RemoveFromParent(len);
   }

   void InspectMember(TObject& obj, const char* name);
   void InspectMember(const char* topclassname, void* pobj, const char* name,
                      Bool_t transient);
   void InspectMember(TClass* cl, void* pobj, const char* name);

   void GenericShowMembers(const char *topClassName, void *obj,
                           Bool_t transientMember);

   private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 0; } static void Dictionary(); virtual TClass *IsA() const { return TMemberInspector::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { TMemberInspector::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TMemberInspector.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 66; } //ABC for inspecting class data members
};
# 3 "/tmp/rootcint_85GekZ.h" 2
# 1 "/scratch/condor/dir_19652/./RooStepBernstein.cxx" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitModels                                                     *
 * @(#)root/roofit:$Id: RooBernstein.cxx 45779 2012-08-31 15:44:51Z moneta $
 * Authors:                                                                  *
 *   Kyle Cranmer
 *                                                                           *
 *****************************************************************************/

//////////////////////////////////////////////////////////////////////////////
//
// BEGIN_HTML
// Bernstein basis polynomials are positive-definite in the range [0,1].
// In this implementation, we extend [0,1] to be the range of the parameter.
// There are n+1 Bernstein basis polynomials of degree n.
// Thus, by providing N coefficients that are positive-definite, there 
// is a natural way to have well bahaved polynomail PDFs.
// For any n, the n+1 basis polynomials 'form a partition of unity', eg.
//  they sum to one for all values of x. See
// http://www.idav.ucdavis.edu/education/CAGDNotes/Bernstein-Polynomials.pdf
// Step function piece means that for x < value f(x) = 0 and for
// x >= value: f(x) = RooBernstein
// END_HTML
//

# 1 "/scratch/condor/dir_19652/./RooStepBernstein.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitModels                                                     *
 *    File: $Id: RooStepBernstein.h 28259 2009-04-16 16:21:16Z wouter $
 * Authors:                                                                  *
 *   Kyle Cranmer (L. Gray for step function piece)
 *                                                                           *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsPdf.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooAbsPdf.h,v 1.90 2007/07/21 21:32:52 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsReal.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooAbsReal.h,v 1.75 2007/07/13 21:50:24 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsArg.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooAbsArg.h,v 1.93 2007/07/16 21:04:28 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/assert.h" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
/****************************************************************
* assert.h
*****************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsArg.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TNamed.h" 1
// @(#)root/base:$Id: TNamed.h 20877 2007-11-19 11:17:07Z rdm $
// Author: Rene Brun   26/12/94

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/





//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TNamed                                                               //
//                                                                      //
// The basis for a named object (name, title).                          //
//                                                                      //
//////////////////////////////////////////////////////////////////////////






# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TString.h" 1
// @(#)root/base:$Id: TString.h 43133 2012-02-27 09:50:10Z rdm $
// Author: Fons Rademakers   04/08/95

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/





//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TString                                                              //
//                                                                      //
// Basic string class.                                                  //
//                                                                      //
// Cannot be stored in a TCollection... use TObjString instead.         //
//                                                                      //
//////////////////////////////////////////////////////////////////////////
# 36 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TString.h"
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TMathBase.h" 1
// @(#)root/base:$Id: TMathBase.h 20877 2007-11-19 11:17:07Z rdm $
// Authors: Rene Brun, Fons Rademakers   29/07/95

/*************************************************************************
 * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/





//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TMath Base functions                                                 //
//                                                                      //
// Define the functions Min, Max, Abs, Sign, Range for all types.       //
// NB: These functions are unfortunately not available in a portable    //
// way in std::.                                                        //
//                                                                      //
// More functions are defined in TMath.h. TMathBase.h is designed to be //
// a stable file and used in place of TMath.h in the ROOT miniCore.     //
//                                                                      //
//////////////////////////////////////////////////////////////////////////





namespace TMath {

   // Abs
   inline Short_t Abs(Short_t d);
   inline Int_t Abs(Int_t d);
   inline Long_t Abs(Long_t d);
   inline Long64_t Abs(Long64_t d);
   inline Float_t Abs(Float_t d);
   inline Double_t Abs(Double_t d);

   // Even/Odd
   inline Bool_t Even(Long_t a);
   inline Bool_t Odd(Long_t a);

   // Sign
   inline Short_t Sign(Short_t a, Short_t b);
   inline Int_t Sign(Int_t a, Int_t b);
   inline Long_t Sign(Long_t a, Long_t b);
   inline Long64_t Sign(Long64_t a, Long64_t b);
   inline Float_t Sign(Float_t a, Float_t b);
   inline Double_t Sign(Double_t a, Double_t b);

   // Min, Max of two scalars
   inline Short_t Min(Short_t a, Short_t b);
   inline UShort_t Min(UShort_t a, UShort_t b);
   inline Int_t Min(Int_t a, Int_t b);
   inline UInt_t Min(UInt_t a, UInt_t b);
   inline Long_t Min(Long_t a, Long_t b);
   inline ULong_t Min(ULong_t a, ULong_t b);
   inline Long64_t Min(Long64_t a, Long64_t b);
   inline ULong64_t Min(ULong64_t a, ULong64_t b);
   inline Float_t Min(Float_t a, Float_t b);
   inline Double_t Min(Double_t a, Double_t b);

   inline Short_t Max(Short_t a, Short_t b);
   inline UShort_t Max(UShort_t a, UShort_t b);
   inline Int_t Max(Int_t a, Int_t b);
   inline UInt_t Max(UInt_t a, UInt_t b);
   inline Long_t Max(Long_t a, Long_t b);
   inline ULong_t Max(ULong_t a, ULong_t b);
   inline Long64_t Max(Long64_t a, Long64_t b);
   inline ULong64_t Max(ULong64_t a, ULong64_t b);
   inline Float_t Max(Float_t a, Float_t b);
   inline Double_t Max(Double_t a, Double_t b);

   // Range
   inline Short_t Range(Short_t lb, Short_t ub, Short_t x);
   inline Int_t Range(Int_t lb, Int_t ub, Int_t x);
   inline Long_t Range(Long_t lb, Long_t ub, Long_t x);
   inline ULong_t Range(ULong_t lb, ULong_t ub, ULong_t x);
   inline Double_t Range(Double_t lb, Double_t ub, Double_t x);

   //NextPrime is used by the Core classes.
   Long_t NextPrime(Long_t x); // Least prime number greater than x
}


//---- Even/odd ----------------------------------------------------------------

inline Bool_t TMath::Even(Long_t a)
   { return ! (a & 1); }

inline Bool_t TMath::Odd(Long_t a)
   { return (a & 1); }

//---- Abs ---------------------------------------------------------------------

inline Short_t TMath::Abs(Short_t d)
   { return (d >= 0) ? d : -d; }

inline Int_t TMath::Abs(Int_t d)
   { return (d >= 0) ? d : -d; }

inline Long_t TMath::Abs(Long_t d)
   { return (d >= 0) ? d : -d; }

inline Long64_t TMath::Abs(Long64_t d)
   { return (d >= 0) ? d : -d; }

inline Float_t TMath::Abs(Float_t d)
   { return (d >= 0) ? d : -d; }

inline Double_t TMath::Abs(Double_t d)
   { return (d >= 0) ? d : -d; }

//---- Sign --------------------------------------------------------------------

inline Short_t TMath::Sign(Short_t a, Short_t b)
   { return (b >= 0) ? Abs(a) : -Abs(a); }

inline Int_t TMath::Sign(Int_t a, Int_t b)
   { return (b >= 0) ? Abs(a) : -Abs(a); }

inline Long_t TMath::Sign(Long_t a, Long_t b)
   { return (b >= 0) ? Abs(a) : -Abs(a); }

inline Long64_t TMath::Sign(Long64_t a, Long64_t b)
   { return (b >= 0) ? Abs(a) : -Abs(a); }

inline Float_t TMath::Sign(Float_t a, Float_t b)
   { return (b >= 0) ? Abs(a) : -Abs(a); }

inline Double_t TMath::Sign(Double_t a, Double_t b)
   { return (b >= 0) ? Abs(a) : -Abs(a); }

//---- Min ---------------------------------------------------------------------

inline Short_t TMath::Min(Short_t a, Short_t b)
   { return a <= b ? a : b; }

inline UShort_t TMath::Min(UShort_t a, UShort_t b)
   { return a <= b ? a : b; }

inline Int_t TMath::Min(Int_t a, Int_t b)
   { return a <= b ? a : b; }

inline UInt_t TMath::Min(UInt_t a, UInt_t b)
   { return a <= b ? a : b; }

inline Long_t TMath::Min(Long_t a, Long_t b)
   { return a <= b ? a : b; }

inline ULong_t TMath::Min(ULong_t a, ULong_t b)
   { return a <= b ? a : b; }

inline Long64_t TMath::Min(Long64_t a, Long64_t b)
   { return a <= b ? a : b; }

inline ULong64_t TMath::Min(ULong64_t a, ULong64_t b)
   { return a <= b ? a : b; }

inline Float_t TMath::Min(Float_t a, Float_t b)
   { return a <= b ? a : b; }

inline Double_t TMath::Min(Double_t a, Double_t b)
   { return a <= b ? a : b; }

//---- Max ---------------------------------------------------------------------

inline Short_t TMath::Max(Short_t a, Short_t b)
   { return a >= b ? a : b; }

inline UShort_t TMath::Max(UShort_t a, UShort_t b)
   { return a >= b ? a : b; }

inline Int_t TMath::Max(Int_t a, Int_t b)
   { return a >= b ? a : b; }

inline UInt_t TMath::Max(UInt_t a, UInt_t b)
   { return a >= b ? a : b; }

inline Long_t TMath::Max(Long_t a, Long_t b)
   { return a >= b ? a : b; }

inline ULong_t TMath::Max(ULong_t a, ULong_t b)
   { return a >= b ? a : b; }

inline Long64_t TMath::Max(Long64_t a, Long64_t b)
   { return a >= b ? a : b; }

inline ULong64_t TMath::Max(ULong64_t a, ULong64_t b)
   { return a >= b ? a : b; }

inline Float_t TMath::Max(Float_t a, Float_t b)
   { return a >= b ? a : b; }

inline Double_t TMath::Max(Double_t a, Double_t b)
   { return a >= b ? a : b; }

//---- Range -------------------------------------------------------------------

inline Short_t TMath::Range(Short_t lb, Short_t ub, Short_t x)
   { return x < lb ? lb : (x > ub ? ub : x); }

inline Int_t TMath::Range(Int_t lb, Int_t ub, Int_t x)
   { return x < lb ? lb : (x > ub ? ub : x); }

inline Long_t TMath::Range(Long_t lb, Long_t ub, Long_t x)
   { return x < lb ? lb : (x > ub ? ub : x); }

inline ULong_t TMath::Range(ULong_t lb, ULong_t ub, ULong_t x)
   { return x < lb ? lb : (x > ub ? ub : x); }

inline Double_t TMath::Range(Double_t lb, Double_t ub, Double_t x)
   { return x < lb ? lb : (x > ub ? ub : x); }
# 37 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TString.h" 2


# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/stdarg.h" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
/****************************************************************
* stdarg.h
*****************************************************************/
# 40 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TString.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/string" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_string" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// string
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/string" 2
}
# 41 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TString.h" 2





class TRegexp;
class TPRegexp;
class TString;
class TSubString;
class TObjArray;
class TVirtualMutex;

extern TVirtualMutex *gStringMutex;

TString operator+(const TString &s1, const TString &s2);
TString operator+(const TString &s, const char *cs);
TString operator+(const char *cs, const TString &s);
TString operator+(const TString &s, char c);
TString operator+(const TString &s, Long_t i);
TString operator+(const TString &s, ULong_t i);
TString operator+(const TString &s, Long64_t i);
TString operator+(const TString &s, ULong64_t i);
TString operator+(char c, const TString &s);
TString operator+(Long_t i, const TString &s);
TString operator+(ULong_t i, const TString &s);
TString operator+(Long64_t i, const TString &s);
TString operator+(ULong64_t i, const TString &s);
Bool_t operator==(const TString &s1, const TString &s2);
Bool_t operator==(const TString &s1, const char *s2);
Bool_t operator==(const TSubString &s1, const TSubString &s2);
Bool_t operator==(const TSubString &s1, const TString &s2);
Bool_t operator==(const TSubString &s1, const char *s2);


//////////////////////////////////////////////////////////////////////////
//                                                                      //
//  TSubString                                                          //
//                                                                      //
//  The TSubString class allows selected elements to be addressed.      //
//  There are no public constructors.                                   //
//                                                                      //
//////////////////////////////////////////////////////////////////////////
class TSubString {

friend class TStringLong;
friend class TString;

friend Bool_t operator==(const TSubString &s1, const TSubString &s2);
friend Bool_t operator==(const TSubString &s1, const TString &s2);
friend Bool_t operator==(const TSubString &s1, const char *s2);

private:
   TString &fStr; // Referenced string
   Ssiz_t fBegin; // Index of starting character
   Ssiz_t fExtent; // Length of TSubString

   // NB: the only constructor is private
   TSubString(const TString &s, Ssiz_t start, Ssiz_t len);

protected:
   void SubStringError(Ssiz_t, Ssiz_t, Ssiz_t) const;
   void AssertElement(Ssiz_t i) const; // Verifies i is valid index

public:
   TSubString(const TSubString &s)
     : fStr(s.fStr), fBegin(s.fBegin), fExtent(s.fExtent) { }

   TSubString &operator=(const char *s); // Assignment from a char*
   TSubString &operator=(const TString &s); // Assignment from a TString
   TSubString &operator=(const TSubString &s); // Assignment from a TSubString
   char &operator()(Ssiz_t i); // Index with optional bounds checking
   char &operator[](Ssiz_t i); // Index with bounds checking
   char operator()(Ssiz_t i) const; // Index with optional bounds checking
   char operator[](Ssiz_t i) const; // Index with bounds checking

   const char *Data() const;
   Ssiz_t Length() const { return fExtent; }
   Ssiz_t Start() const { return fBegin; }
   TString& String() { return fStr; }
   void ToLower(); // Convert self to lower-case
   void ToUpper(); // Convert self to upper-case

   // For detecting null substrings
   Bool_t IsNull() const { return fBegin == kNPOS; }
   int operator!() const { return fBegin == kNPOS; }
};


//////////////////////////////////////////////////////////////////////////
//                                                                      //
//  TString                                                             //
//                                                                      //
//////////////////////////////////////////////////////////////////////////
class TString {

friend class TStringLong;
friend class TSubString;

friend TString operator+(const TString &s1, const TString &s2);
friend TString operator+(const TString &s, const char *cs);
friend TString operator+(const char *cs, const TString &s);
friend TString operator+(const TString &s, char c);
friend TString operator+(const TString &s, Long_t i);
friend TString operator+(const TString &s, ULong_t i);
friend TString operator+(const TString &s, Long64_t i);
friend TString operator+(const TString &s, ULong64_t i);
friend TString operator+(char c, const TString &s);
friend TString operator+(Long_t i, const TString &s);
friend TString operator+(ULong_t i, const TString &s);
friend TString operator+(Long64_t i, const TString &s);
friend TString operator+(ULong64_t i, const TString &s);
friend Bool_t operator==(const TString &s1, const TString &s2);
friend Bool_t operator==(const TString &s1, const char *s2);

private:

   enum { kShortMask = 0x01, kLongMask = 0x1 };




   struct LongStr_t
   {
      Ssiz_t fCap; // Max string length (including null)
      Ssiz_t fSize; // String length (excluding null)
      char *fData; // Long string data
   };

   enum { kMinCap = (sizeof(LongStr_t) - 1)/sizeof(char) > 2 ?
                    (sizeof(LongStr_t) - 1)/sizeof(char) : 2 };

   struct ShortStr_t
   {
      unsigned char fSize; // String length (excluding null)
      char fData[kMinCap]; // Short string data
   };

   union UStr_t { LongStr_t fL; ShortStr_t fS; };

   enum { kNwords = sizeof(UStr_t) / sizeof(Ssiz_t)};

   struct RawStr_t
   {
      Ssiz_t fWords[kNwords];
   };

   struct Rep_t
   {
      union
      {
         LongStr_t fLong;
         ShortStr_t fShort;
         RawStr_t fRaw;
      };
   };

protected:




   // Special concatenation constructor
   TString(const char *a1, Ssiz_t n1, const char *a2, Ssiz_t n2);
   void AssertElement(Ssiz_t nc) const; // Index in range
   void Clobber(Ssiz_t nc); // Remove old contents
   void InitChar(char c); // Initialize from char

   enum { kAlignment = 16 };
   static Ssiz_t Align(Ssiz_t s) { return (s + (kAlignment-1)) & ~(kAlignment-1); }
   static Ssiz_t Recommend(Ssiz_t s) { return (s < kMinCap ? kMinCap : Align(s+1)) - 1; }
   static Ssiz_t AdjustCapacity(Ssiz_t oldCap, Ssiz_t newCap);

private:
   Bool_t IsLong() const { return Bool_t(fRep.fShort.fSize & kShortMask); }

   void SetShortSize(Ssiz_t s) { fRep.fShort.fSize = (unsigned char)(s << 1); }
   Ssiz_t GetShortSize() const { return fRep.fShort.fSize >> 1; }




   void SetLongSize(Ssiz_t s) { fRep.fLong.fSize = s; }
   Ssiz_t GetLongSize() const { return fRep.fLong.fSize; }
   void SetSize(Ssiz_t s) { IsLong() ? SetLongSize(s) : SetShortSize(s); }
   void SetLongCap(Ssiz_t s) { fRep.fLong.fCap = kLongMask | s; }
   Ssiz_t GetLongCap() const { return fRep.fLong.fCap & ~kLongMask; }
   void SetLongPointer(char *p) { fRep.fLong.fData = p; }
   char *GetLongPointer() { return fRep.fLong.fData; }
   const char *GetLongPointer() const { return fRep.fLong.fData; }
   char *GetShortPointer() { return fRep.fShort.fData; }
   const char *GetShortPointer() const { return fRep.fShort.fData; }
   char *GetPointer() { return IsLong() ? GetLongPointer() : GetShortPointer(); }
   const char *GetPointer() const { return IsLong() ? GetLongPointer() : GetShortPointer(); }

   static Ssiz_t MaxSize() { return kMaxInt - 1; }



   void UnLink() const { if (IsLong()) delete [] fRep.fLong.fData; }
   void Zero() {
      Ssiz_t (&a)[kNwords] = fRep.fRaw.fWords;
      for (UInt_t i = 0; i < kNwords; ++i)
         a[i] = 0;
   }
   char *Init(Ssiz_t capacity, Ssiz_t nchar);
   void Clone(Ssiz_t nc); // Make self a distinct copy w. capacity nc
   void FormImp(const char *fmt, va_list ap);
   UInt_t HashCase() const;
   UInt_t HashFoldCase() const;

public:
   enum EStripType { kLeading = 0x1, kTrailing = 0x2, kBoth = 0x3 };
   enum ECaseCompare { kExact, kIgnoreCase };

   TString(); // Null string
   explicit TString(Ssiz_t ic); // Suggested capacity
   TString(const TString &s); // Copy constructor
   TString(const char *s); // Copy to embedded null
   TString(const char *s, Ssiz_t n); // Copy past any embedded nulls
   TString(const std::string &s);
   TString(char c);
   TString(char c, Ssiz_t s);
   TString(const TSubString &sub);

   virtual ~TString();

   // ROOT I/O interface
   virtual void FillBuffer(char *&buffer) const;
   virtual void ReadBuffer(char *&buffer);
   virtual Int_t Sizeof() const;

   static TString *ReadString(TBuffer &b, const TClass *clReq);
   static void WriteString(TBuffer &b, const TString *a);

   friend TBuffer &operator<<(TBuffer &b, const TString *obj);

   // C I/O interface
   Bool_t Gets(FILE *fp, Bool_t chop=kTRUE);
   void Puts(FILE *fp);

   // Type conversion
   operator const char*() const { return GetPointer(); }

   // Assignment
   TString &operator=(char s); // Replace string
   TString &operator=(const char *s);
   TString &operator=(const TString &s);
   TString &operator=(const std::string &s);
   TString &operator=(const TSubString &s);
   TString &operator+=(const char *s); // Append string
   TString &operator+=(const TString &s);
   TString &operator+=(char c);
   TString &operator+=(Short_t i);
   TString &operator+=(UShort_t i);
   TString &operator+=(Int_t i);
   TString &operator+=(UInt_t i);
   TString &operator+=(Long_t i);
   TString &operator+=(ULong_t i);
   TString &operator+=(Float_t f);
   TString &operator+=(Double_t f);
   TString &operator+=(Long64_t i);
   TString &operator+=(ULong64_t i);

   // Indexing operators
   char &operator[](Ssiz_t i); // Indexing with bounds checking
   char &operator()(Ssiz_t i); // Indexing with optional bounds checking
   char operator[](Ssiz_t i) const;
   char operator()(Ssiz_t i) const;
   TSubString operator()(Ssiz_t start, Ssiz_t len) const; // Sub-string operator
   TSubString operator()(const TRegexp &re) const; // Match the RE
   TSubString operator()(const TRegexp &re, Ssiz_t start) const;
   TSubString operator()(TPRegexp &re) const; // Match the Perl compatible Regular Expression
   TSubString operator()(TPRegexp &re, Ssiz_t start) const;
   TSubString SubString(const char *pat, Ssiz_t start = 0,
                           ECaseCompare cmp = kExact) const;

   // Non-static member functions
   TString &Append(const char *cs);
   TString &Append(const char *cs, Ssiz_t n);
   TString &Append(const TString &s);
   TString &Append(const TString &s, Ssiz_t n);
   TString &Append(char c, Ssiz_t rep = 1); // Append c rep times
   Int_t Atoi() const;
   Long64_t Atoll() const;
   Double_t Atof() const;
   Bool_t BeginsWith(const char *s, ECaseCompare cmp = kExact) const;
   Bool_t BeginsWith(const TString &pat, ECaseCompare cmp = kExact) const;
   Ssiz_t Capacity() const { return (IsLong() ? GetLongCap() : kMinCap) - 1; }
   Ssiz_t Capacity(Ssiz_t n);
   TString &Chop();
   void Clear();
   int CompareTo(const char *cs, ECaseCompare cmp = kExact) const;
   int CompareTo(const TString &st, ECaseCompare cmp = kExact) const;
   Bool_t Contains(const char *pat, ECaseCompare cmp = kExact) const;
   Bool_t Contains(const TString &pat, ECaseCompare cmp = kExact) const;
   Bool_t Contains(const TRegexp &pat) const;
   Bool_t Contains(TPRegexp &pat) const;
   Int_t CountChar(Int_t c) const;
   TString Copy() const;
   const char *Data() const { return GetPointer(); }
   Bool_t EndsWith(const char *pat, ECaseCompare cmp = kExact) const;
   Bool_t EqualTo(const char *cs, ECaseCompare cmp = kExact) const;
   Bool_t EqualTo(const TString &st, ECaseCompare cmp = kExact) const;
   Ssiz_t First(char c) const;
   Ssiz_t First(const char *cs) const;
   void Form(const char *fmt, ...)



   ;
   UInt_t Hash(ECaseCompare cmp = kExact) const;
   Ssiz_t Index(const char *pat, Ssiz_t i = 0,
                      ECaseCompare cmp = kExact) const;
   Ssiz_t Index(const TString &s, Ssiz_t i = 0,
                      ECaseCompare cmp = kExact) const;
   Ssiz_t Index(const char *pat, Ssiz_t patlen, Ssiz_t i,
                      ECaseCompare cmp) const;
   Ssiz_t Index(const TString &s, Ssiz_t patlen, Ssiz_t i,
                      ECaseCompare cmp) const;
   Ssiz_t Index(const TRegexp &pat, Ssiz_t i = 0) const;
   Ssiz_t Index(const TRegexp &pat, Ssiz_t *ext, Ssiz_t i = 0) const;
   Ssiz_t Index(TPRegexp &pat, Ssiz_t i = 0) const;
   Ssiz_t Index(TPRegexp &pat, Ssiz_t *ext, Ssiz_t i = 0) const;
   TString &Insert(Ssiz_t pos, const char *s);
   TString &Insert(Ssiz_t pos, const char *s, Ssiz_t extent);
   TString &Insert(Ssiz_t pos, const TString &s);
   TString &Insert(Ssiz_t pos, const TString &s, Ssiz_t extent);
   Bool_t IsAscii() const;
   Bool_t IsAlpha() const;
   Bool_t IsAlnum() const;
   Bool_t IsDigit() const;
   Bool_t IsFloat() const;
   Bool_t IsHex() const;
   Bool_t IsBin() const;
   Bool_t IsOct() const;
   Bool_t IsDec() const;
   Bool_t IsInBaseN(Int_t base) const;
   Bool_t IsNull() const { return Length() == 0; }
   Bool_t IsWhitespace() const { return (Length() == CountChar(' ')); }
   Ssiz_t Last(char c) const;
   Ssiz_t Length() const { return IsLong() ? GetLongSize() : GetShortSize(); }
   Bool_t MaybeRegexp() const;
   Bool_t MaybeWildcard() const;
   TString MD5() const;
   TString &Prepend(const char *cs); // Prepend a character string
   TString &Prepend(const char *cs, Ssiz_t n);
   TString &Prepend(const TString &s);
   TString &Prepend(const TString &s, Ssiz_t n);
   TString &Prepend(char c, Ssiz_t rep = 1); // Prepend c rep times
   istream &ReadFile(istream &str); // Read to EOF or null character
   istream &ReadLine(istream &str,
                         Bool_t skipWhite = kTRUE); // Read to EOF or newline
   istream &ReadString(istream &str); // Read to EOF or null character
   istream &ReadToDelim(istream &str, char delim = '\n'); // Read to EOF or delimitor
   istream &ReadToken(istream &str); // Read separated by white space
   TString &Remove(Ssiz_t pos); // Remove pos to end of string
   TString &Remove(Ssiz_t pos, Ssiz_t n); // Remove n chars starting at pos
   TString &Remove(EStripType s, char c); // Like Strip() but changing string directly
   TString &Replace(Ssiz_t pos, Ssiz_t n, const char *s);
   TString &Replace(Ssiz_t pos, Ssiz_t n, const char *s, Ssiz_t ns);
   TString &Replace(Ssiz_t pos, Ssiz_t n, const TString &s);
   TString &Replace(Ssiz_t pos, Ssiz_t n1, const TString &s, Ssiz_t n2);
   TString &ReplaceAll(const TString &s1, const TString &s2); // Find&Replace all s1 with s2 if any
   TString &ReplaceAll(const TString &s1, const char *s2); // Find&Replace all s1 with s2 if any
   TString &ReplaceAll(const char *s1, const TString &s2); // Find&Replace all s1 with s2 if any
   TString &ReplaceAll(const char *s1, const char *s2); // Find&Replace all s1 with s2 if any
   TString &ReplaceAll(const char *s1, Ssiz_t ls1, const char *s2, Ssiz_t ls2); // Find&Replace all s1 with s2 if any
   void Resize(Ssiz_t n); // Truncate or add blanks as necessary
   TSubString Strip(EStripType s = kTrailing, char c = ' ') const;
   void ToLower(); // Change self to lower-case
   void ToUpper(); // Change self to upper-case
   TObjArray *Tokenize(const TString &delim) const;
   Bool_t Tokenize(TString &tok, Ssiz_t &from, const char *delim = " ") const;

   // Static member functions
   static UInt_t Hash(const void *txt, Int_t ntxt); // Calculates hash index from any char string.
   static Ssiz_t InitialCapacity(Ssiz_t ic = 15); // Initial allocation capacity
   static Ssiz_t MaxWaste(Ssiz_t mw = 15); // Max empty space before reclaim
   static Ssiz_t ResizeIncrement(Ssiz_t ri = 16); // Resizing increment
   static Ssiz_t GetInitialCapacity();
   static Ssiz_t GetResizeIncrement();
   static Ssiz_t GetMaxWaste();
   static TString Itoa ( Int_t value, Int_t base); // Converts int to string with respect to the base specified (2-36)
   static TString UItoa ( UInt_t value, Int_t base);
   static TString LLtoa ( Long64_t value, Int_t base);
   static TString ULLtoa (ULong64_t value, Int_t base);
   static TString BaseConvert(const TString& s_in, Int_t base_in, Int_t base_out); // Converts string from base base_in to base base_out (supported bases 2-36)
   static TString Format(const char *fmt, ...)



   ;

   private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 2; } static void Dictionary(); virtual TClass *IsA() const { return TString::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { TString::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TString.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 434; } //Basic string class
};

// Related global functions
istream &operator>>(istream &str, TString &s);
ostream &operator<<(ostream &str, const TString &s);



TBuffer &operator>>(TBuffer &buf, TString *&sp);

TString ToLower(const TString &s); // Return lower-case version of argument
TString ToUpper(const TString &s); // Return upper-case version of argument

inline UInt_t Hash(const TString &s) { return s.Hash(); }
inline UInt_t Hash(const TString *s) { return s->Hash(); }
       UInt_t Hash(const char *s);

extern char *Form(const char *fmt, ...) // format in circular buffer



;
extern void Printf(const char *fmt, ...) // format and print



;
extern char *Strip(const char *str, char c = ' '); // strip c off str, free with delete []
extern char *StrDup(const char *str); // duplicate str, free with delete []
extern char *Compress(const char *str); // remove blanks from string, free with delele []
extern int EscChar(const char *src, char *dst, int dstlen, char *specchars,
                     char escchar); // copy from src to dst escaping specchars by escchar
extern int UnEscChar(const char *src, char *dst, int dstlen, char *specchars,
                       char escchar); // copy from src to dst removing escchar from specchars






//////////////////////////////////////////////////////////////////////////
//                                                                      //
//  Inlines                                                             //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

inline TString &TString::Append(const char *cs)
{ return Replace(Length(), 0, cs, cs ? strlen(cs) : 0); }

inline TString &TString::Append(const char *cs, Ssiz_t n)
{ return Replace(Length(), 0, cs, n); }

inline TString &TString::Append(const TString &s)
{ return Replace(Length(), 0, s.Data(), s.Length()); }

inline TString &TString::Append(const TString &s, Ssiz_t n)
{ return Replace(Length(), 0, s.Data(), TMath::Min(n, s.Length())); }

inline TString &TString::operator+=(const char *cs)
{ return Append(cs, cs ? strlen(cs) : 0); }

inline TString &TString::operator+=(const TString &s)
{ return Append(s.Data(), s.Length()); }

inline TString &TString::operator+=(char c)
{ return Append(c); }

inline TString &TString::operator+=(Long_t i)
{ char s[32]; sprintf(s, "%ld", i); return operator+=(s); }

inline TString &TString::operator+=(ULong_t i)
{ char s[32]; sprintf(s, "%lu", i); return operator+=(s); }

inline TString &TString::operator+=(Short_t i)
{ return operator+=((Long_t) i); }

inline TString &TString::operator+=(UShort_t i)
{ return operator+=((ULong_t) i); }

inline TString &TString::operator+=(Int_t i)
{ return operator+=((Long_t) i); }

inline TString &TString::operator+=(UInt_t i)
{ return operator+=((ULong_t) i); }

inline TString &TString::operator+=(Double_t f)
{
   char s[32];
   // coverity[secure_coding] Buffer is large enough: width specified in format
   sprintf(s, "%.17g", f);
   return operator+=(s);
}

inline TString &TString::operator+=(Float_t f)
{ return operator+=((Double_t) f); }

inline TString &TString::operator+=(Long64_t l)
{
   char s[32];
   // coverity[secure_coding] Buffer is large enough (2^64 = 20 digits).
   sprintf(s, "%lld", l);
   return operator+=(s);
}

inline TString &TString::operator+=(ULong64_t ul)
{
   char s[32];
   // coverity[secure_coding] Buffer is large enough (2^64 = 20 digits).
   sprintf(s, "%llu", ul);
   return operator+=(s);
}

inline Bool_t TString::BeginsWith(const char *s, ECaseCompare cmp) const
{ return Index(s, s ? strlen(s) : (Ssiz_t)0, (Ssiz_t)0, cmp) == 0; }

inline Bool_t TString::BeginsWith(const TString &pat, ECaseCompare cmp) const
{ return Index(pat.Data(), pat.Length(), (Ssiz_t)0, cmp) == 0; }

inline Bool_t TString::Contains(const TString &pat, ECaseCompare cmp) const
{ return Index(pat.Data(), pat.Length(), (Ssiz_t)0, cmp) != kNPOS; }

inline Bool_t TString::Contains(const char *s, ECaseCompare cmp) const
{ return Index(s, s ? strlen(s) : 0, (Ssiz_t)0, cmp) != kNPOS; }

inline Bool_t TString::Contains(const TRegexp &pat) const
{ return Index(pat, (Ssiz_t)0) != kNPOS; }

inline Bool_t TString::Contains(TPRegexp &pat) const
{ return Index(pat, (Ssiz_t)0) != kNPOS; }

inline Bool_t TString::EqualTo(const char *cs, ECaseCompare cmp) const
{ return (CompareTo(cs, cmp) == 0) ? kTRUE : kFALSE; }

inline Bool_t TString::EqualTo(const TString &st, ECaseCompare cmp) const
{ return (CompareTo(st, cmp) == 0) ? kTRUE : kFALSE; }

inline Ssiz_t TString::Index(const char *s, Ssiz_t i, ECaseCompare cmp) const
{ return Index(s, s ? strlen(s) : 0, i, cmp); }

inline Ssiz_t TString::Index(const TString &s, Ssiz_t i, ECaseCompare cmp) const
{ return Index(s.Data(), s.Length(), i, cmp); }

inline Ssiz_t TString::Index(const TString &pat, Ssiz_t patlen, Ssiz_t i,
                             ECaseCompare cmp) const
{ return Index(pat.Data(), patlen, i, cmp); }

inline TString &TString::Insert(Ssiz_t pos, const char *cs)
{ return Replace(pos, 0, cs, cs ? strlen(cs) : 0); }

inline TString &TString::Insert(Ssiz_t pos, const char *cs, Ssiz_t n)
{ return Replace(pos, 0, cs, n); }

inline TString &TString::Insert(Ssiz_t pos, const TString &s)
{ return Replace(pos, 0, s.Data(), s.Length()); }

inline TString &TString::Insert(Ssiz_t pos, const TString &s, Ssiz_t n)
{ return Replace(pos, 0, s.Data(), TMath::Min(n, s.Length())); }

inline TString &TString::Prepend(const char *cs)
{ return Replace(0, 0, cs, cs ? strlen(cs) : 0); }

inline TString &TString::Prepend(const char *cs, Ssiz_t n)
{ return Replace(0, 0, cs, n); }

inline TString &TString::Prepend(const TString &s)
{ return Replace(0, 0, s.Data(), s.Length()); }

inline TString &TString::Prepend(const TString &s, Ssiz_t n)
{ return Replace(0, 0, s.Data(), TMath::Min(n, s.Length())); }

inline TString &TString::Remove(Ssiz_t pos)
{ return Replace(pos, TMath::Max(0, Length()-pos), 0, 0); }

inline TString &TString::Remove(Ssiz_t pos, Ssiz_t n)
{ return Replace(pos, n, 0, 0); }

inline TString &TString::Chop()
{ return Remove(TMath::Max(0, Length()-1)); }

inline TString &TString::Replace(Ssiz_t pos, Ssiz_t n, const char *cs)
{ return Replace(pos, n, cs, cs ? strlen(cs) : 0); }

inline TString &TString::Replace(Ssiz_t pos, Ssiz_t n, const TString& s)
{ return Replace(pos, n, s.Data(), s.Length()); }

inline TString &TString::Replace(Ssiz_t pos, Ssiz_t n1, const TString &s,
                                 Ssiz_t n2)
{ return Replace(pos, n1, s.Data(), TMath::Min(s.Length(), n2)); }

inline TString &TString::ReplaceAll(const TString &s1, const TString &s2)
{ return ReplaceAll(s1.Data(), s1.Length(), s2.Data(), s2.Length()) ; }

inline TString &TString::ReplaceAll(const TString &s1, const char *s2)
{ return ReplaceAll(s1.Data(), s1.Length(), s2, s2 ? strlen(s2) : 0); }

inline TString &TString::ReplaceAll(const char *s1, const TString &s2)
{ return ReplaceAll(s1, s1 ? strlen(s1) : 0, s2.Data(), s2.Length()); }

inline TString &TString::ReplaceAll(const char *s1,const char *s2)
{ return ReplaceAll(s1, s1 ? strlen(s1) : 0, s2, s2 ? strlen(s2) : 0); }

inline char &TString::operator()(Ssiz_t i)
{ return GetPointer()[i]; }

inline char TString::operator()(Ssiz_t i) const
{ return GetPointer()[i]; }

inline char &TString::operator[](Ssiz_t i)
{ AssertElement(i); return GetPointer()[i]; }

inline char TString::operator[](Ssiz_t i) const
{ AssertElement(i); return GetPointer()[i]; }

inline const char *TSubString::Data() const
{
   // Return a pointer to the beginning of the substring. Note that the
   // terminating null is in the same place as for the original
   // TString, so this method is not appropriate for converting the
   // TSubString to a string. To do that, construct a TString from the
   // TSubString. For example:
   //
   //   root [0] TString s("hello world")
   //   root [1] TSubString sub=s(0, 5)
   //   root [2] sub.Data()
   //   (const char* 0x857c8b8)"hello world"
   //   root [3] TString substr(sub)
   //   root [4] substr
   //   (class TString)"hello"

   return fStr.Data() + fBegin;
}

// Access to elements of sub-string with bounds checking
inline char TSubString::operator[](Ssiz_t i) const
{ AssertElement(i); return fStr.GetPointer()[fBegin+i]; }

inline char TSubString::operator()(Ssiz_t i) const
{ return fStr.GetPointer()[fBegin+i]; }

inline TSubString &TSubString::operator=(const TSubString &s)
{ fStr = s.fStr; fBegin = s.fBegin; fExtent = s.fExtent; return *this; }


// String Logical operators
inline Bool_t operator==(const TString &s1, const TString &s2)
{
   return ((s1.Length() == s2.Length()) &&
            !memcmp(s1.Data(), s2.Data(), s1.Length()));
}

inline Bool_t operator!=(const TString &s1, const TString &s2)
{ return !(s1 == s2); }

inline Bool_t operator<(const TString &s1, const TString &s2)
{ return s1.CompareTo(s2) < 0; }

inline Bool_t operator>(const TString &s1, const TString &s2)
{ return s1.CompareTo(s2) > 0; }

inline Bool_t operator<=(const TString &s1, const TString &s2)
{ return s1.CompareTo(s2) <= 0; }

inline Bool_t operator>=(const TString &s1, const TString &s2)
{ return s1.CompareTo(s2) >= 0; }

//     Bool_t operator==(const TString &s1, const char *s2);
inline Bool_t operator!=(const TString &s1, const char *s2)
{ return !(s1 == s2); }

inline Bool_t operator<(const TString &s1, const char *s2)
{ return s1.CompareTo(s2) < 0; }

inline Bool_t operator>(const TString &s1, const char *s2)
{ return s1.CompareTo(s2) > 0; }

inline Bool_t operator<=(const TString &s1, const char *s2)
{ return s1.CompareTo(s2) <= 0; }

inline Bool_t operator>=(const TString &s1, const char *s2)
{ return s1.CompareTo(s2) >= 0; }

inline Bool_t operator==(const char *s1, const TString &s2)
{ return (s2 == s1); }

inline Bool_t operator!=(const char *s1, const TString &s2)
{ return !(s2 == s1); }

inline Bool_t operator<(const char *s1, const TString &s2)
{ return s2.CompareTo(s1) > 0; }

inline Bool_t operator>(const char *s1, const TString &s2)
{ return s2.CompareTo(s1) < 0; }

inline Bool_t operator<=(const char *s1, const TString &s2)
{ return s2.CompareTo(s1) >= 0; }

inline Bool_t operator>=(const char *s1, const TString &s2)
{ return s2.CompareTo(s1) <= 0; }

// SubString Logical operators
//     Bool_t operator==(const TSubString &s1, const TSubString &s2);
//     Bool_t operator==(const TSubString &s1, const char *s2);
//     Bool_t operator==(const TSubString &s1, const TString &s2);
inline Bool_t operator==(const TString &s1, const TSubString &s2)
{ return (s2 == s1); }

inline Bool_t operator==(const char *s1, const TSubString &s2)
{ return (s2 == s1); }

inline Bool_t operator!=(const TSubString &s1, const char *s2)
{ return !(s1 == s2); }

inline Bool_t operator!=(const TSubString &s1, const TString &s2)
{ return !(s1 == s2); }

inline Bool_t operator!=(const TSubString &s1, const TSubString &s2)
{ return !(s1 == s2); }

inline Bool_t operator!=(const TString &s1, const TSubString &s2)
{ return !(s2 == s1); }

inline Bool_t operator!=(const char *s1, const TSubString &s2)
{ return !(s2 == s1); }
# 30 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TNamed.h" 2



class TNamed : public TObject {

protected:
   TString fName; //object identifier
   TString fTitle; //object title

public:
   TNamed(): fName(), fTitle() { }
   TNamed(const char *name, const char *title) : fName(name), fTitle(title) { }
   TNamed(const TString &name, const TString &title) : fName(name), fTitle(title) { }
   TNamed(const TNamed &named);
   TNamed& operator=(const TNamed& rhs);
   virtual ~TNamed() { }
   virtual void Clear(Option_t *option ="");
   virtual TObject *Clone(const char *newname="") const;
   virtual Int_t Compare(const TObject *obj) const;
   virtual void Copy(TObject &named) const;
   virtual void FillBuffer(char *&buffer);
   virtual const char *GetName() const { return fName; }
   virtual const char *GetTitle() const { return fTitle; }
   virtual ULong_t Hash() const { return fName.Hash(); }
   virtual Bool_t IsSortable() const { return kTRUE; }
   virtual void SetName(const char *name); // *MENU*
   virtual void SetNameTitle(const char *name, const char *title);
   virtual void SetTitle(const char *title=""); // *MENU*
   virtual void ls(Option_t *option="") const;
   virtual void Print(Option_t *option="") const;
   virtual Int_t Sizeof() const;

   private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return TNamed::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { TNamed::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TNamed.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 62; } //The basis for a named object (name, title)
};
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsArg.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/THashList.h" 1
// @(#)root/cont:$Id: THashList.h 27904 2009-03-20 19:44:39Z pcanal $
// Author: Fons Rademakers   10/08/95

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/





//////////////////////////////////////////////////////////////////////////
//                                                                      //
// THashList                                                            //
//                                                                      //
// THashList implements a hybrid collection class consisting of a       //
// hash table and a list to store TObject's. The hash table is used for //
// quick access and lookup of objects while the list allows the objects //
// to be ordered. The hash value is calculated using the value returned //
// by the TObject's Hash() function. Each class inheriting from TObject //
// can override Hash() as it sees fit.                                  //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TList.h" 1
// @(#)root/cont:$Id: TList.h 43515 2012-03-27 21:15:53Z pcanal $
// Author: Fons Rademakers   10/08/95

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/





//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TList                                                                //
//                                                                      //
// A doubly linked list. All classes inheriting from TObject can be     //
// inserted in a TList.                                                 //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TSeqCollection.h" 1
// @(#)root/cont:$Id: TSeqCollection.h 38082 2011-02-16 00:52:04Z rdm $
// Author: Fons Rademakers   04/08/95

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/





//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TSeqCollection                                                       //
//                                                                      //
// Sequenceable collection abstract base class. TSeqCollection's have   //
// an ordering relation, i.e. there is a first and last element.        //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TCollection.h" 1
// @(#)root/cont:$Id: TCollection.h 43515 2012-03-27 21:15:53Z pcanal $
// Author: Fons Rademakers   13/08/95

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/





//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TCollection                                                          //
//                                                                      //
// Collection abstract base class. This class inherits from TObject     //
// because we want to be able to have collections of collections.       //
//                                                                      //
//////////////////////////////////////////////////////////////////////////






# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TIterator.h" 1
// @(#)root/cont:$Id: TIterator.h 43515 2012-03-27 21:15:53Z pcanal $
// Author: Fons Rademakers   13/08/95

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/





//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TIterator                                                            //
//                                                                      //
// Iterator abstract base class. This base class provides the interface //
// for collection iterators.                                            //
//                                                                      //
//////////////////////////////////////////////////////////////////////////





class TCollection;
class TObject;

class TIterator {

protected:
   TIterator() { }
   TIterator(const TIterator &) { }

public:
   virtual TIterator &operator=(const TIterator &) { return *this; }
   virtual ~TIterator() { }
   virtual const TCollection *GetCollection() const = 0;
   virtual Option_t *GetOption() const { return ""; }
   virtual TObject *Next() = 0;
   virtual void Reset() = 0;
   TObject *operator()() { return Next(); }
   virtual Bool_t operator!=(const TIterator &) const;
   virtual TObject *operator*() const;

   private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 0; } static void Dictionary(); virtual TClass *IsA() const { return TIterator::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { TIterator::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TIterator.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 49; } //Iterator abstract base class
};
# 31 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TCollection.h" 2







class TClass;
class TObjectTable;
class TVirtualMutex;

const Bool_t kIterForward = kTRUE;
const Bool_t kIterBackward = !kIterForward;

extern TVirtualMutex *gCollectionMutex;

class TCollection : public TObject {

private:
   static TCollection *fgCurrentCollection; //used by macro R__FOR_EACH
   static TObjectTable *fgGarbageCollection; //used by garbage collector
   static Bool_t fgEmptyingGarbage; //used by garbage collector
   static Int_t fgGarbageStack; //used by garbage collector

   TCollection(const TCollection &); //private and not-implemented, collections
   void operator=(const TCollection &); //are too complex to be automatically copied

protected:
   enum { kIsOwner = (1ULL << (14)) };

   TString fName; //name of the collection
   Int_t fSize; //number of elements in collection

   TCollection() : fName(), fSize(0) { }

   virtual void PrintCollectionHeader(Option_t* option) const;
   virtual const char* GetCollectionEntryName(TObject* entry) const;
   virtual void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const;

public:
   enum { kInitCapacity = 16, kInitHashTableCapacity = 17 };

   virtual ~TCollection() { }
   virtual void Add(TObject *obj) = 0;
   void AddVector(TObject *obj1, ...);
   virtual void AddAll(const TCollection *col);
   Bool_t AssertClass(TClass *cl) const;
   void Browse(TBrowser *b);
   Int_t Capacity() const { return fSize; }
   virtual void Clear(Option_t *option="") = 0;
   virtual TObject *Clone(const char *newname="") const;
   Int_t Compare(const TObject *obj) const;
   Bool_t Contains(const char *name) const { return FindObject(name) != 0; }
   Bool_t Contains(const TObject *obj) const { return FindObject(obj) != 0; }
   virtual void Delete(Option_t *option="") = 0;
   virtual void Draw(Option_t *option="");
   virtual void Dump() const ;
   virtual TObject *FindObject(const char *name) const;
   TObject *operator()(const char *name) const;
   virtual TObject *FindObject(const TObject *obj) const;
   virtual Int_t GetEntries() const { return GetSize(); }
   virtual const char *GetName() const;
   virtual TObject **GetObjectRef(const TObject *obj) const = 0;
   virtual Int_t GetSize() const { return fSize; }
   virtual Int_t GrowBy(Int_t delta) const;
   ULong_t Hash() const { return fName.Hash(); }
   Bool_t IsArgNull(const char *where, const TObject *obj) const;
   virtual Bool_t IsEmpty() const { return GetSize() <= 0; }
   virtual Bool_t IsFolder() const { return kTRUE; }
   Bool_t IsOwner() const { return TestBit(kIsOwner); }
   Bool_t IsSortable() const { return kTRUE; }
   virtual void ls(Option_t *option="") const ;
   virtual TIterator *MakeIterator(Bool_t dir = kIterForward) const = 0;
   virtual TIterator *MakeReverseIterator() const { return MakeIterator(kIterBackward); }
   virtual void Paint(Option_t *option="");
   virtual void Print(Option_t *option="") const;
   virtual void Print(Option_t *option, Int_t recurse) const;
   virtual void Print(Option_t *option, const char* wildcard, Int_t recurse=1) const;
   virtual void Print(Option_t *option, TPRegexp& regexp, Int_t recurse=1) const;
   virtual void RecursiveRemove(TObject *obj);
   virtual TObject *Remove(TObject *obj) = 0;
   virtual void RemoveAll(TCollection *col);
   void RemoveAll() { Clear(); }
   void SetCurrentCollection();
   void SetName(const char *name) { fName = name; }
   virtual void SetOwner(Bool_t enable = kTRUE);
   virtual Int_t Write(const char *name=0, Int_t option=0, Int_t bufsize=0);
   virtual Int_t Write(const char *name=0, Int_t option=0, Int_t bufsize=0) const;

   static TCollection *GetCurrentCollection();
   static void StartGarbageCollection();
   static void GarbageCollect(TObject *obj);
   static void EmptyGarbageCollection();

   private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 3; } static void Dictionary(); virtual TClass *IsA() const { return TCollection::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { TCollection::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TCollection.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 125; } //Collection abstract base class
};


//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TIter                                                                //
//                                                                      //
// Iterator wrapper. Type of iterator used depends on type of           //
// collection.                                                          //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

class TIter {

private:
   TIterator *fIterator; //collection iterator

protected:
   TIter() : fIterator(0) { }

public:
   TIter(const TCollection *col, Bool_t dir = kIterForward)
         : fIterator(col ? col->MakeIterator(dir) : 0) { }
   TIter(TIterator *it) : fIterator(it) { }
   TIter(const TIter &iter);
   TIter &operator=(const TIter &rhs);
   virtual ~TIter() { { if (fIterator) { delete fIterator; fIterator = 0; } }; }
   TObject *operator()() { return Next(); }
   TObject *Next() { return fIterator ? fIterator->Next() : 0; }
   const TCollection *GetCollection() const { return fIterator ? fIterator->GetCollection() : 0; }
   Option_t *GetOption() const { return fIterator ? fIterator->GetOption() : ""; }
   void Reset() { if (fIterator) fIterator->Reset(); }
   TIter &operator++() { Next(); return *this; }
   Bool_t operator!=(const TIter &aIter) const { return ((*fIterator) != *(aIter.fIterator)); }
   TObject *operator*() const { return *(*fIterator); }
   TIter &Begin();
   static TIter End();

   private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 0; } static void Dictionary(); virtual TClass *IsA() const { return TIter::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { TIter::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TCollection.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 164; } //Iterator wrapper
};

template <class T>
class TIterCategory: public TIter, public std::iterator_traits<typename T::Iterator_t> {

public:
   TIterCategory(const TCollection *col, Bool_t dir = kIterForward) : TIter(col, dir) { }
   TIterCategory(TIterator *it) : TIter(it) { }
   virtual ~TIterCategory() { }
   TIterCategory &Begin() { TIter::Begin(); return *this; }
   static TIterCategory End() { return TIterCategory(static_cast<TIterator*>(0)); }
};


//---- R__FOR_EACH macro -------------------------------------------------------

// Macro to loop over all elements of a list of type "type" while executing
// procedure "proc" on each element
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TSeqCollection.h" 2



class TSeqCollection : public TCollection {

protected:
   Bool_t fSorted; // true if collection has been sorted

   TSeqCollection() : fSorted(kFALSE) { }
   virtual void Changed() { fSorted = kFALSE; }

public:
   virtual ~TSeqCollection() { }
   virtual void Add(TObject *obj) { AddLast(obj); }
   virtual void AddFirst(TObject *obj) = 0;
   virtual void AddLast(TObject *obj) = 0;
   virtual void AddAt(TObject *obj, Int_t idx) = 0;
   virtual void AddAfter(const TObject *after, TObject *obj) = 0;
   virtual void AddBefore(const TObject *before, TObject *obj) = 0;
   virtual void RemoveFirst() { Remove(First()); }
   virtual void RemoveLast() { Remove(Last()); }
   virtual TObject *RemoveAt(Int_t idx) { return Remove(At(idx)); }
   virtual void RemoveAfter(TObject *after) { Remove(After(after)); }
   virtual void RemoveBefore(TObject *before) { Remove(Before(before)); }

   virtual TObject *At(Int_t idx) const = 0;
   virtual TObject *Before(const TObject *obj) const = 0;
   virtual TObject *After(const TObject *obj) const = 0;
   virtual TObject *First() const = 0;
   virtual TObject *Last() const = 0;
   Int_t LastIndex() const { return GetSize() - 1; }
   virtual Int_t GetLast() const;
   virtual Int_t IndexOf(const TObject *obj) const;
   virtual Bool_t IsSorted() const { return fSorted; }
   void UnSort() { fSorted = kFALSE; }
   Long64_t Merge(TCollection *list);

   static Int_t ObjCompare(TObject *a, TObject *b);
   static void QSort(TObject **a, Int_t first, Int_t last);
   static inline void QSort(TObject **a, TObject **b, Int_t first, Int_t last) { QSort(a, 1, &b, first, last); }
   static void QSort(TObject **a, Int_t nBs, TObject ***b, Int_t first, Int_t last);

   private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 0; } static void Dictionary(); virtual TClass *IsA() const { return TSeqCollection::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { TSeqCollection::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TSeqCollection.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 69; } //Sequenceable collection ABC
};
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TList.h" 2





# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <iterator.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/iterator

#pragma ifndef PREC_STL_ITERATOR
#pragma define PREC_STL_ITERATOR
#pragma link off global PREC_STL_ITERATOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from STL HP implementation 1994
// Imported from STL SGI implementation 1997 
// Imported from ANSI/ISO C++ draft Nov 1997
// Modified by Masaharu Goto
// May need improvement for the latest standard


////////////////////////////////////////////////////////////////////////
// iterator_tag
////////////////////////////////////////////////////////////////////////
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag {};
struct bidirectional_iterator_tag {};
struct random_access_iterator_tag {};

////////////////////////////////////////////////////////////////////////
// iterator template
////////////////////////////////////////////////////////////////////////
template <class T, class Distance> struct input_iterator {};
struct output_iterator {};
template <class T, class Distance> struct forward_iterator {};
template <class T, class Distance> struct bidirectional_iterator {};
template <class T, class Distance> struct random_access_iterator {};

#pragma link off class output_iterator;







////////////////////////////////////////////////////////////////////////
// iterator_category overloaded function
////////////////////////////////////////////////////////////////////////
template <class T, class Distance>
inline input_iterator_tag
iterator_category(const input_iterator<T, Distance>&) {
    return input_iterator_tag();
}

inline output_iterator_tag iterator_category(const output_iterator&) {
    return output_iterator_tag();
}

#pragma link off function iterator_category(const output_iterator&);


template <class T, class Distance>
inline forward_iterator_tag
iterator_category(const forward_iterator<T, Distance>&) {
    return forward_iterator_tag();
}

template <class T, class Distance>
inline bidirectional_iterator_tag
iterator_category(const bidirectional_iterator<T, Distance>&) {
    return bidirectional_iterator_tag();
}

template <class T, class Distance>
inline random_access_iterator_tag
iterator_category(const random_access_iterator<T, Distance>&) {
    return random_access_iterator_tag();
}

template <class T>
inline random_access_iterator_tag
iterator_category(const T*) {
    return random_access_iterator_tag();
}


// iterator_traits, iterator and reverse_iterator template may not be
// needed for precompiled library interface 

////////////////////////////////////////////////////////////////////////
// iterator_traits
////////////////////////////////////////////////////////////////////////

template <class Iterator>
struct iterator_traits {
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type value_type;
  typedef typename Iterator::difference_type difference_type;
  typedef typename Iterator::pointer pointer;
  typedef typename Iterator::reference reference;
};

// template partial specialization, implement in cint5.15.14 1587
template <class T>
struct iterator_traits<T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
};

// incomplete implementation in cint5.15.14 1587, need some fix
// iterator_traits<const int*> is changed as iterator_traits<const int* const>
// or something, but cint5.15.14 can not handle this well
template <class T>
struct iterator_traits<const T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef const T* pointer;
  typedef const T& reference;
};

////////////////////////////////////////////////////////////////////////
// iterator
////////////////////////////////////////////////////////////////////////
template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator {
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
  typedef Category iterator_category;
};


////////////////////////////////////////////////////////////////////////
// reverse_iterator
////////////////////////////////////////////////////////////////////////






template <class Iterator>
class reverse_iterator
# 166 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
{




 public:
# 181 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
   typedef Iterator::pointer pointer;
   typedef Iterator::reference reference;
   typedef ptrdiff_t difference_type;


   reverse_iterator();
   //reverse_iterator(Iterator x);



   Iterator base() const; // explicit
   reference operator*() const;
   pointer operator->() const;
   reverse_iterator& operator++();
   reverse_iterator operator++(int);
   reverse_iterator& operator--();
   reverse_iterator operator--(int);
   reverse_iterator operator+ (difference_type n) const;
   reverse_iterator& operator+=(difference_type n);
   reverse_iterator operator- (difference_type n) const;
   reverse_iterator& operator-=(difference_type n);
   reference operator[](difference_type n) const;
};
# 932 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
// for g++ 3.1,3.2
namespace __gnu_cxx
{
  // This iterator adapter is 'normal' in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                    difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparaison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  // _GLIBCPP_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
     const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
} // namespace __gnu_cxx







#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 2
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/iterator" 2
}
# 33 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TList.h" 2


// Prevent -Weffc++ from complaining about the inheritance
// TListIter from std::iterator.
       
# 38 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TList.h" 3


const Bool_t kSortAscending = kTRUE;
const Bool_t kSortDescending = !kSortAscending;

class TObjLink;
class TListIter;


class TList : public TSeqCollection {

friend class TListIter;

protected:
   TObjLink *fFirst; //! pointer to first entry in linked list
   TObjLink *fLast; //! pointer to last entry in linked list
   TObjLink *fCache; //! cache to speedup sequential calling of Before() and After() functions
   Bool_t fAscending; //! sorting order (when calling Sort() or for TSortedList)

   TObjLink *LinkAt(Int_t idx) const;
   TObjLink *FindLink(const TObject *obj, Int_t &idx) const;
   TObjLink **DoSort(TObjLink **head, Int_t n);
   Bool_t LnkCompare(TObjLink *l1, TObjLink *l2);
   virtual TObjLink *NewLink(TObject *obj, TObjLink *prev = 0);
   virtual TObjLink *NewOptLink(TObject *obj, Option_t *opt, TObjLink *prev = 0);
   virtual void DeleteLink(TObjLink *lnk);

private:
   TList(const TList&); // not implemented
   TList& operator=(const TList&); // not implemented

public:
   typedef TListIter Iterator_t;

   TList() : fFirst(0), fLast(0), fCache(0), fAscending(kTRUE) { }
   TList(TObject *) : fFirst(0), fLast(0), fCache(0), fAscending(kTRUE) { } // for backward compatibility, don't use
   virtual ~TList();
   virtual void Clear(Option_t *option="");
   virtual void Delete(Option_t *option="");
   virtual TObject *FindObject(const char *name) const;
   virtual TObject *FindObject(const TObject *obj) const;
   virtual TIterator *MakeIterator(Bool_t dir = kIterForward) const;

   virtual void Add(TObject *obj) { AddLast(obj); }
   virtual void Add(TObject *obj, Option_t *opt) { AddLast(obj, opt); }
   virtual void AddFirst(TObject *obj);
   virtual void AddFirst(TObject *obj, Option_t *opt);
   virtual void AddLast(TObject *obj);
   virtual void AddLast(TObject *obj, Option_t *opt);
   virtual void AddAt(TObject *obj, Int_t idx);
   virtual void AddAfter(const TObject *after, TObject *obj);
   virtual void AddAfter(TObjLink *after, TObject *obj);
   virtual void AddBefore(const TObject *before, TObject *obj);
   virtual void AddBefore(TObjLink *before, TObject *obj);
   virtual TObject *Remove(TObject *obj);
   virtual TObject *Remove(TObjLink *lnk);
   virtual void RemoveLast();
   virtual void RecursiveRemove(TObject *obj);

   virtual TObject *At(Int_t idx) const;
   virtual TObject *After(const TObject *obj) const;
   virtual TObject *Before(const TObject *obj) const;
   virtual TObject *First() const;
   virtual TObjLink *FirstLink() const { return fFirst; }
   virtual TObject **GetObjectRef(const TObject *obj) const;
   virtual TObject *Last() const;
   virtual TObjLink *LastLink() const { return fLast; }

   virtual void Sort(Bool_t order = kSortAscending);
   Bool_t IsAscending() { return fAscending; }

   private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 5; } static void Dictionary(); virtual TClass *IsA() const { return TList::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { TList::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TList.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 109; } //Doubly linked list
};


//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TObjLink                                                             //
//                                                                      //
// Wrapper around a TObject so it can be stored in a TList.             //
//                                                                      //
//////////////////////////////////////////////////////////////////////////
class TObjLink {

friend class TList;

private:
   TObjLink *fNext;
   TObjLink *fPrev;
   TObject *fObject;

   TObjLink(const TObjLink&); // not implemented
   TObjLink& operator=(const TObjLink&); // not implemented

protected:
   TObjLink() : fNext(0), fPrev(0), fObject(0) { fNext = fPrev = this; }

public:
   TObjLink(TObject *obj) : fNext(0), fPrev(0), fObject(obj) { }
   TObjLink(TObject *obj, TObjLink *lnk);
   virtual ~TObjLink() { }

   TObject *GetObject() const { return fObject; }
   TObject **GetObjectRef() { return &fObject; }
   void SetObject(TObject *obj) { fObject = obj; }
   virtual Option_t *GetAddOption() const { return ""; }
   virtual Option_t *GetOption() const { return fObject->GetOption(); }
   virtual void SetOption(Option_t *) { }
   TObjLink *Next() { return fNext; }
   TObjLink *Prev() { return fPrev; }
};


//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TObjOptLink                                                          //
//                                                                      //
// Wrapper around a TObject so it can be stored in a TList including    //
// an option string.                                                    //
//                                                                      //
//////////////////////////////////////////////////////////////////////////
class TObjOptLink : public TObjLink {

private:
   TString fOption;

public:
   TObjOptLink(TObject *obj, Option_t *opt) : TObjLink(obj), fOption(opt) { }
   TObjOptLink(TObject *obj, TObjLink *lnk, Option_t *opt) : TObjLink(obj, lnk), fOption(opt) { }
   ~TObjOptLink() { }
   Option_t *GetAddOption() const { return fOption.Data(); }
   Option_t *GetOption() const { return fOption.Data(); }
   void SetOption(Option_t *option) { fOption = option; }
};


// Preventing warnings with -Weffc++ in GCC since it is a false positive for the TListIter destructor.

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Weffc++"


//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TListIter                                                            //
//                                                                      //
// Iterator of linked list.                                             //
//                                                                      //
//////////////////////////////////////////////////////////////////////////
class TListIter : public TIterator,
                  public std::iterator<std::bidirectional_iterator_tag,
                                       TObject*, std::ptrdiff_t,
                                       const TObject**, const TObject*&> {

protected:
   const TList *fList; //list being iterated
   TObjLink *fCurCursor; //current position in list
   TObjLink *fCursor; //next position in list
   Bool_t fDirection; //iteration direction
   Bool_t fStarted; //iteration started

   TListIter() : fList(0), fCurCursor(0), fCursor(0), fDirection(kIterForward),
                 fStarted(kFALSE) { }

public:
   TListIter(const TList *l, Bool_t dir = kIterForward);
   TListIter(const TListIter &iter);
   ~TListIter() { }
   TIterator &operator=(const TIterator &rhs);
   TListIter &operator=(const TListIter &rhs);

   const TCollection *GetCollection() const { return fList; }
   Option_t *GetOption() const;
   void SetOption(Option_t *option);
   TObject *Next();
   void Reset();
   Bool_t operator!=(const TIterator &aIter) const;
   Bool_t operator!=(const TListIter &aIter) const;
   TObject *operator*() const { return (fCurCursor ? fCurCursor->GetObject() : 0); }

   private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 0; } static void Dictionary(); virtual TClass *IsA() const { return TListIter::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { TListIter::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TList.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 218; } //Linked list iterator
};


#pragma GCC diagnostic pop
# 31 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/THashList.h" 2


class THashTable;


class THashList : public TList {

protected:
   THashTable *fTable; //Hashtable used for quick lookup of objects

private:
   THashList(const THashList&); // not implemented
   THashList& operator=(const THashList&); // not implemented

public:
   THashList(Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);
   THashList(TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);
   virtual ~THashList();
   Float_t AverageCollisions() const;
   void Clear(Option_t *option="");
   void Delete(Option_t *option="");

   TObject *FindObject(const char *name) const;
   TObject *FindObject(const TObject *obj) const;

   TList *GetListForObject(const char *name) const;
   TList *GetListForObject(const TObject *obj) const;

   void AddFirst(TObject *obj);
   void AddFirst(TObject *obj, Option_t *opt);
   void AddLast(TObject *obj);
   void AddLast(TObject *obj, Option_t *opt);
   void AddAt(TObject *obj, Int_t idx);
   void AddAfter(const TObject *after, TObject *obj);
   void AddAfter(TObjLink *after, TObject *obj);
   void AddBefore(const TObject *before, TObject *obj);
   void AddBefore(TObjLink *before, TObject *obj);
   void RecursiveRemove(TObject *obj);
   void Rehash(Int_t newCapacity);
   TObject *Remove(TObject *obj);
   TObject *Remove(TObjLink *lnk);

   private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 0; } static void Dictionary(); virtual TClass *IsA() const { return THashList::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { THashList::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/THashList.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 73; } //Doubly linked list with hashtable for lookup
};
# 22 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsArg.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TRefArray.h" 1
// @(#)root/cont:$Id: TRefArray.h 43515 2012-03-27 21:15:53Z pcanal $
// Author: Rene Brun    02/10/2001

/*************************************************************************
 * Copyright (C) 1995-2001, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/





//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TRefArray                                                            //
//                                                                      //
// An array of references to TObjects.                                  //
// The array expands automatically when adding elements.                //
//                                                                      //
//////////////////////////////////////////////////////////////////////////





# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TProcessID.h" 1
// @(#)root/cont:$Id: TProcessID.h 26606 2008-12-02 20:36:09Z pcanal $
// Author: Rene Brun   28/09/2001

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/





//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TProcessID                                                           //
//                                                                      //
// Process Identifier object                                            //
//                                                                      //
//////////////////////////////////////////////////////////////////////////






# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TObjArray.h" 1
// @(#)root/cont:$Id: TObjArray.h 43515 2012-03-27 21:15:53Z pcanal $
// Author: Fons Rademakers   11/09/95

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/





//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TObjArray                                                            //
//                                                                      //
// An array of TObjects. The array expands automatically when adding    //
// elements (shrinking can be done by hand).                            //
//                                                                      //
//////////////////////////////////////////////////////////////////////////





# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <iterator.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/iterator

#pragma ifndef PREC_STL_ITERATOR
#pragma define PREC_STL_ITERATOR
#pragma link off global PREC_STL_ITERATOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from STL HP implementation 1994
// Imported from STL SGI implementation 1997 
// Imported from ANSI/ISO C++ draft Nov 1997
// Modified by Masaharu Goto
// May need improvement for the latest standard


////////////////////////////////////////////////////////////////////////
// iterator_tag
////////////////////////////////////////////////////////////////////////
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag {};
struct bidirectional_iterator_tag {};
struct random_access_iterator_tag {};

////////////////////////////////////////////////////////////////////////
// iterator template
////////////////////////////////////////////////////////////////////////
template <class T, class Distance> struct input_iterator {};
struct output_iterator {};
template <class T, class Distance> struct forward_iterator {};
template <class T, class Distance> struct bidirectional_iterator {};
template <class T, class Distance> struct random_access_iterator {};

#pragma link off class output_iterator;







////////////////////////////////////////////////////////////////////////
// iterator_category overloaded function
////////////////////////////////////////////////////////////////////////
template <class T, class Distance>
inline input_iterator_tag
iterator_category(const input_iterator<T, Distance>&) {
    return input_iterator_tag();
}

inline output_iterator_tag iterator_category(const output_iterator&) {
    return output_iterator_tag();
}

#pragma link off function iterator_category(const output_iterator&);


template <class T, class Distance>
inline forward_iterator_tag
iterator_category(const forward_iterator<T, Distance>&) {
    return forward_iterator_tag();
}

template <class T, class Distance>
inline bidirectional_iterator_tag
iterator_category(const bidirectional_iterator<T, Distance>&) {
    return bidirectional_iterator_tag();
}

template <class T, class Distance>
inline random_access_iterator_tag
iterator_category(const random_access_iterator<T, Distance>&) {
    return random_access_iterator_tag();
}

template <class T>
inline random_access_iterator_tag
iterator_category(const T*) {
    return random_access_iterator_tag();
}


// iterator_traits, iterator and reverse_iterator template may not be
// needed for precompiled library interface 

////////////////////////////////////////////////////////////////////////
// iterator_traits
////////////////////////////////////////////////////////////////////////

template <class Iterator>
struct iterator_traits {
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type value_type;
  typedef typename Iterator::difference_type difference_type;
  typedef typename Iterator::pointer pointer;
  typedef typename Iterator::reference reference;
};

// template partial specialization, implement in cint5.15.14 1587
template <class T>
struct iterator_traits<T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
};

// incomplete implementation in cint5.15.14 1587, need some fix
// iterator_traits<const int*> is changed as iterator_traits<const int* const>
// or something, but cint5.15.14 can not handle this well
template <class T>
struct iterator_traits<const T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef const T* pointer;
  typedef const T& reference;
};

////////////////////////////////////////////////////////////////////////
// iterator
////////////////////////////////////////////////////////////////////////
template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator {
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
  typedef Category iterator_category;
};


////////////////////////////////////////////////////////////////////////
// reverse_iterator
////////////////////////////////////////////////////////////////////////






template <class Iterator>
class reverse_iterator
# 166 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
{




 public:
# 181 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
   typedef Iterator::pointer pointer;
   typedef Iterator::reference reference;
   typedef ptrdiff_t difference_type;


   reverse_iterator();
   //reverse_iterator(Iterator x);



   Iterator base() const; // explicit
   reference operator*() const;
   pointer operator->() const;
   reverse_iterator& operator++();
   reverse_iterator operator++(int);
   reverse_iterator& operator--();
   reverse_iterator operator--(int);
   reverse_iterator operator+ (difference_type n) const;
   reverse_iterator& operator+=(difference_type n);
   reverse_iterator operator- (difference_type n) const;
   reverse_iterator& operator-=(difference_type n);
   reference operator[](difference_type n) const;
};
# 932 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
// for g++ 3.1,3.2
namespace __gnu_cxx
{
  // This iterator adapter is 'normal' in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                    difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparaison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  // _GLIBCPP_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
     const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
} // namespace __gnu_cxx







#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 2
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/iterator" 2
}
# 30 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TObjArray.h" 2


// Prevent -Weffc++ from complaining about the inheritance
// TObjArrayIter from std::iterator.
       
# 35 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TObjArray.h" 3


class TObjArrayIter;

class TObjArray : public TSeqCollection {

friend class TObjArrayIter;
friend class TClonesArray;

protected:
   TObject **fCont; //!Array contents
   Int_t fLowerBound; //Lower bound of the array
   Int_t fLast; //Last element in array containing an object

   Bool_t BoundsOk(const char *where, Int_t at) const;
   void Init(Int_t s, Int_t lowerBound);
   Bool_t OutOfBoundsError(const char *where, Int_t i) const;
   Int_t GetAbsLast() const;

public:
   typedef TObjArrayIter Iterator_t;

   TObjArray(Int_t s = TCollection::kInitCapacity, Int_t lowerBound = 0);
   TObjArray(const TObjArray &a);
   virtual ~TObjArray();
   TObjArray& operator=(const TObjArray&);
   virtual void Clear(Option_t *option="");
   virtual void Compress();
   virtual void Delete(Option_t *option="");
   virtual void Expand(Int_t newSize); // expand or shrink an array
   Int_t GetEntries() const;
   Int_t GetEntriesFast() const {
      return GetAbsLast() + 1; //only OK when no gaps
   }
   Int_t GetLast() const;
   TObject **GetObjectRef() const { return fCont; };
   TObject **GetObjectRef(const TObject *obj) const;
   Bool_t IsEmpty() const { return GetAbsLast() == -1; }
   TIterator *MakeIterator(Bool_t dir = kIterForward) const;

   void Add(TObject *obj) { AddLast(obj); }
   virtual void AddFirst(TObject *obj);
   virtual void AddLast(TObject *obj);
   virtual void AddAt(TObject *obj, Int_t idx);
   virtual void AddAtAndExpand(TObject *obj, Int_t idx);
   virtual Int_t AddAtFree(TObject *obj);
   virtual void AddAfter(const TObject *after, TObject *obj);
   virtual void AddBefore(const TObject *before, TObject *obj);
   virtual TObject *FindObject(const char *name) const;
   virtual TObject *FindObject(const TObject *obj) const;
   virtual TObject *RemoveAt(Int_t idx);
   virtual TObject *Remove(TObject *obj);
   virtual void RemoveRange(Int_t idx1, Int_t idx2);
   virtual void RecursiveRemove(TObject *obj);

   TObject *At(Int_t idx) const;
   TObject *UncheckedAt(Int_t i) const { return fCont[i-fLowerBound]; }
   TObject *Before(const TObject *obj) const;
   TObject *After(const TObject *obj) const;
   TObject *First() const;
   TObject *Last() const;
   virtual TObject *&operator[](Int_t i);
   virtual TObject *operator[](Int_t i) const;
   Int_t LowerBound() const { return fLowerBound; }
   Int_t IndexOf(const TObject *obj) const;
   void SetLast(Int_t last);

   virtual void Randomize(Int_t ntimes=1);
   virtual void Sort(Int_t upto = kMaxInt);
   virtual Int_t BinarySearch(TObject *obj, Int_t upto = kMaxInt); // the TObjArray has to be sorted, -1 == not found !!

   private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 3; } static void Dictionary(); virtual TClass *IsA() const { return TObjArray::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { TObjArray::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TObjArray.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 106; } //An array of objects
};


// Preventing warnings with -Weffc++ in GCC since it is a false positive for the TObjArrayIter destructor.

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Weffc++"


//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TObjArrayIter                                                        //
//                                                                      //
// Iterator of object array.                                            //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

class TObjArrayIter : public TIterator,
                      public std::iterator<std::bidirectional_iterator_tag, // TODO: ideally it should be a  randomaccess_iterator_tag
                                           TObject*, std::ptrdiff_t,
                                           const TObject**, const TObject*&> {

private:
   const TObjArray *fArray; //array being iterated
   Int_t fCurCursor; //current position in array
   Int_t fCursor; //next position in array
   Bool_t fDirection; //iteration direction

   TObjArrayIter() : fArray(0), fCurCursor(0), fCursor(0), fDirection(kIterForward) { }

public:
   TObjArrayIter(const TObjArray *arr, Bool_t dir = kIterForward);
   TObjArrayIter(const TObjArrayIter &iter);
   ~TObjArrayIter() { }
   TIterator &operator=(const TIterator &rhs);
   TObjArrayIter &operator=(const TObjArrayIter &rhs);

   const TCollection *GetCollection() const { return fArray; }
   TObject *Next();
   void Reset();
   Bool_t operator!=(const TIterator &aIter) const;
   Bool_t operator!=(const TObjArrayIter &aIter) const;
   TObject *operator*() const;

   private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 0; } static void Dictionary(); virtual TClass *IsA() const { return TObjArrayIter::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { TObjArrayIter::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TObjArray.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 151; } //Object array iterator
};


#pragma GCC diagnostic pop


//---- inlines -----------------------------------------------------------------

inline Bool_t TObjArray::BoundsOk(const char *where, Int_t at) const
{
   return (at < fLowerBound || at-fLowerBound >= fSize)
                  ? OutOfBoundsError(where, at)
                  : kTRUE;
}

inline TObject *TObjArray::At(Int_t i) const
{
   // Return the object at position i. Returns 0 if i is out of bounds.
   int j = i-fLowerBound;
   if (j >= 0 && j < fSize) return fCont[j];
   BoundsOk("At", i);
   return 0;
}
# 30 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TProcessID.h" 2


class TExMap;

class TProcessID : public TNamed {

private:
   TProcessID(const TProcessID &ref); // TProcessID are not copiable.
   TProcessID& operator=(const TProcessID &ref); // TProcessID are not copiable.

protected:
   Int_t fCount; //!Reference count to this object (from TFile)
   TObjArray *fObjects; //!Array pointing to the referenced objects

   static TProcessID *fgPID; //Pointer to current session ProcessID
   static TObjArray *fgPIDs; //Table of ProcessIDs
   static TExMap *fgObjPIDs; //Table pointer to pids
   static UInt_t fgNumber; //Referenced objects count

public:
   TProcessID();
   virtual ~TProcessID();
   void CheckInit();
   virtual void Clear(Option_t *option="");
   Int_t DecrementCount();
   Int_t IncrementCount();
   Int_t GetCount() const {return fCount;}
   TObjArray *GetObjects() const {return fObjects;}
   TObject *GetObjectWithID(UInt_t uid);
   void PutObjectWithID(TObject *obj, UInt_t uid=0);
   virtual void RecursiveRemove(TObject *obj);

   static TProcessID *AddProcessID();
   static UInt_t AssignID(TObject *obj);
   static void Cleanup();
   static UInt_t GetNProcessIDs();
   static TProcessID *GetPID();
   static TObjArray *GetPIDs();
   static TProcessID *GetProcessID(UShort_t pid);
   static TProcessID *GetProcessWithUID(const TObject *obj);
   static TProcessID *GetProcessWithUID(UInt_t uid,const void *obj);
   static TProcessID *GetSessionProcessID();
   static UInt_t GetObjectCount();
   static Bool_t IsValid(TProcessID *pid);
   static void SetObjectCount(UInt_t number);

   private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return TProcessID::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { TProcessID::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TProcessID.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 76; } //Process Unique Identifier in time and space
};
# 30 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TRefArray.h" 2


# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <iterator.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/iterator

#pragma ifndef PREC_STL_ITERATOR
#pragma define PREC_STL_ITERATOR
#pragma link off global PREC_STL_ITERATOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from STL HP implementation 1994
// Imported from STL SGI implementation 1997 
// Imported from ANSI/ISO C++ draft Nov 1997
// Modified by Masaharu Goto
// May need improvement for the latest standard


////////////////////////////////////////////////////////////////////////
// iterator_tag
////////////////////////////////////////////////////////////////////////
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag {};
struct bidirectional_iterator_tag {};
struct random_access_iterator_tag {};

////////////////////////////////////////////////////////////////////////
// iterator template
////////////////////////////////////////////////////////////////////////
template <class T, class Distance> struct input_iterator {};
struct output_iterator {};
template <class T, class Distance> struct forward_iterator {};
template <class T, class Distance> struct bidirectional_iterator {};
template <class T, class Distance> struct random_access_iterator {};

#pragma link off class output_iterator;







////////////////////////////////////////////////////////////////////////
// iterator_category overloaded function
////////////////////////////////////////////////////////////////////////
template <class T, class Distance>
inline input_iterator_tag
iterator_category(const input_iterator<T, Distance>&) {
    return input_iterator_tag();
}

inline output_iterator_tag iterator_category(const output_iterator&) {
    return output_iterator_tag();
}

#pragma link off function iterator_category(const output_iterator&);


template <class T, class Distance>
inline forward_iterator_tag
iterator_category(const forward_iterator<T, Distance>&) {
    return forward_iterator_tag();
}

template <class T, class Distance>
inline bidirectional_iterator_tag
iterator_category(const bidirectional_iterator<T, Distance>&) {
    return bidirectional_iterator_tag();
}

template <class T, class Distance>
inline random_access_iterator_tag
iterator_category(const random_access_iterator<T, Distance>&) {
    return random_access_iterator_tag();
}

template <class T>
inline random_access_iterator_tag
iterator_category(const T*) {
    return random_access_iterator_tag();
}


// iterator_traits, iterator and reverse_iterator template may not be
// needed for precompiled library interface 

////////////////////////////////////////////////////////////////////////
// iterator_traits
////////////////////////////////////////////////////////////////////////

template <class Iterator>
struct iterator_traits {
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type value_type;
  typedef typename Iterator::difference_type difference_type;
  typedef typename Iterator::pointer pointer;
  typedef typename Iterator::reference reference;
};

// template partial specialization, implement in cint5.15.14 1587
template <class T>
struct iterator_traits<T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
};

// incomplete implementation in cint5.15.14 1587, need some fix
// iterator_traits<const int*> is changed as iterator_traits<const int* const>
// or something, but cint5.15.14 can not handle this well
template <class T>
struct iterator_traits<const T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef const T* pointer;
  typedef const T& reference;
};

////////////////////////////////////////////////////////////////////////
// iterator
////////////////////////////////////////////////////////////////////////
template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator {
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
  typedef Category iterator_category;
};


////////////////////////////////////////////////////////////////////////
// reverse_iterator
////////////////////////////////////////////////////////////////////////






template <class Iterator>
class reverse_iterator
# 166 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
{




 public:
# 181 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
   typedef Iterator::pointer pointer;
   typedef Iterator::reference reference;
   typedef ptrdiff_t difference_type;


   reverse_iterator();
   //reverse_iterator(Iterator x);



   Iterator base() const; // explicit
   reference operator*() const;
   pointer operator->() const;
   reverse_iterator& operator++();
   reverse_iterator operator++(int);
   reverse_iterator& operator--();
   reverse_iterator operator--(int);
   reverse_iterator operator+ (difference_type n) const;
   reverse_iterator& operator+=(difference_type n);
   reverse_iterator operator- (difference_type n) const;
   reverse_iterator& operator-=(difference_type n);
   reference operator[](difference_type n) const;
};
# 932 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
// for g++ 3.1,3.2
namespace __gnu_cxx
{
  // This iterator adapter is 'normal' in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                    difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparaison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  // _GLIBCPP_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
     const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
} // namespace __gnu_cxx







#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 2
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/iterator" 2
}
# 33 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TRefArray.h" 2


// Prevent -Weffc++ from complaining about the inheritance
// TRefArrayIter from std::iterator.
       
# 38 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TRefArray.h" 3


class TSystem;
class TRefArrayIter;

class TRefArray : public TSeqCollection {

friend class TRefArrayIter;

protected:
   TProcessID *fPID; //Pointer to Process Unique Identifier
   UInt_t *fUIDs; //[fSize] To store uids of referenced objects
   Int_t fLowerBound; //Lower bound of the array
   Int_t fLast; //Last element in array containing an object

   Bool_t BoundsOk(const char *where, Int_t at) const;
   void Init(Int_t s, Int_t lowerBound);
   Bool_t OutOfBoundsError(const char *where, Int_t i) const;
   Int_t GetAbsLast() const;
   TObject *GetFromTable(Int_t idx) const;

public:
   typedef TRefArrayIter Iterator_t;

   TRefArray(TProcessID *pid = 0);
   TRefArray(Int_t s, TProcessID *pid);
   TRefArray(Int_t s, Int_t lowerBound = 0, TProcessID *pid = 0);
   TRefArray(const TRefArray &a);
   TRefArray& operator=(const TRefArray &a);
   virtual ~TRefArray();
   virtual void Clear(Option_t *option="");
   virtual void Compress();
   virtual void Delete(Option_t *option="");
   virtual void Expand(Int_t newSize); // expand or shrink an array
   Int_t GetEntries() const;
   Int_t GetEntriesFast() const {
      return GetAbsLast() + 1; //only OK when no gaps
   }
   Int_t GetLast() const;
   TObject **GetObjectRef(const TObject *obj) const;
   TProcessID *GetPID() const {return fPID;}
   UInt_t GetUID(Int_t at) const;
   Bool_t IsEmpty() const { return GetAbsLast() == -1; }
   TIterator *MakeIterator(Bool_t dir = kIterForward) const;

   void Add(TObject *obj) { AddLast(obj); }
   virtual void AddFirst(TObject *obj);
   virtual void AddLast(TObject *obj);
   virtual void AddAt(TObject *obj, Int_t idx);
   virtual void AddAtAndExpand(TObject *obj, Int_t idx);
   virtual Int_t AddAtFree(TObject *obj);
   virtual void AddAfter(const TObject *after, TObject *obj);
   virtual void AddBefore(const TObject *before, TObject *obj);
   virtual TObject *RemoveAt(Int_t idx);
   virtual TObject *Remove(TObject *obj);

   TObject *At(Int_t idx) const;
   TObject *Before(const TObject *obj) const;
   TObject *After(const TObject *obj) const;
   TObject *First() const;
   TObject *Last() const;
   virtual TObject *operator[](Int_t i) const;
   Int_t LowerBound() const { return fLowerBound; }
   Int_t IndexOf(const TObject *obj) const;
   void SetLast(Int_t last);

   virtual void Sort(Int_t upto = kMaxInt);
   virtual Int_t BinarySearch(TObject *obj, Int_t upto = kMaxInt); // the TRefArray has to be sorted, -1 == not found !!

   private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return TRefArray::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { TRefArray::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TRefArray.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 107; } //An array of references to TObjects
};


// Preventing warnings with -Weffc++ in GCC since it is a false positive for the TRefArrayIter destructor.

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Weffc++"


//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TRefArrayIter                                                        //
//                                                                      //
// Iterator of object array.                                            //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

class TRefArrayIter : public TIterator,
                      public std::iterator<std::bidirectional_iterator_tag, // TODO: ideally it should be a  randomaccess_iterator_tag
                                           TObject*, std::ptrdiff_t,
                                           const TObject**, const TObject*&> {

private:
   const TRefArray *fArray; //array being iterated
   Int_t fCurCursor; //current position in array
   Int_t fCursor; //next position in array
   Bool_t fDirection; //iteration direction

   TRefArrayIter() : fArray(0), fCurCursor(0), fCursor(0), fDirection(kIterForward) { }

public:
   TRefArrayIter(const TRefArray *arr, Bool_t dir = kIterForward);
   TRefArrayIter(const TRefArrayIter &iter);
   ~TRefArrayIter() { }
   TIterator &operator=(const TIterator &rhs);
   TRefArrayIter &operator=(const TRefArrayIter &rhs);

   const TCollection *GetCollection() const { return fArray; }
   TObject *Next();
   void Reset();
   Bool_t operator!=(const TIterator &aIter) const;
   Bool_t operator!=(const TRefArrayIter &aIter) const;
   TObject *operator*() const;

   private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 0; } static void Dictionary(); virtual TClass *IsA() const { return TRefArrayIter::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { TRefArrayIter::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TRefArray.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 152; } //Object array iterator
};


#pragma GCC diagnostic pop



//---- inlines -----------------------------------------------------------------

inline Bool_t TRefArray::BoundsOk(const char *where, Int_t at) const
{
   return (at < fLowerBound || at-fLowerBound >= fSize)
                  ? OutOfBoundsError(where, at)
                  : kTRUE;
}

inline TObject *TRefArray::operator[](Int_t at) const
{
   int j = at-fLowerBound;
   if (j >= 0 && j < fSize) {
      if (!fPID) return 0;
      if (!TProcessID::IsValid(fPID)) return 0;
      TObject *obj = fPID->GetObjectWithID(fUIDs[j]);
      if (obj==0) obj = GetFromTable(j);
      return obj;
   }
   BoundsOk("At", at);
   return 0;
}

inline TObject *TRefArray::At(Int_t at) const
{
   // Return the object at position i. Returns 0 if i is out of bounds.
   int j = at-fLowerBound;
   if (j >= 0 && j < fSize) {
      if (!fPID) return 0;
      if (!TProcessID::IsValid(fPID)) return 0;
      TObject *obj = fPID->GetObjectWithID(fUIDs[j]);
      if (obj==0) obj = GetFromTable(j);
      return obj;
   }
   BoundsOk("At", at);
   return 0;
}
# 23 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsArg.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooPrintable.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooPrintable.h,v 1.12 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/




class TNamed ;

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Riosfwd.h" 1
// @(#)root/base:$Id: Riosfwd.h 20877 2007-11-19 11:17:07Z rdm $
// Author: Fons Rademakers   23/1/02

/*************************************************************************
 * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 23 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooPrintable.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h" 1
/* @(#)root/base:$Id: Rtypes.h 43708 2012-04-12 10:19:00Z axel $ */

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 24 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooPrintable.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TString.h" 1
// @(#)root/base:$Id: TString.h 43133 2012-02-27 09:50:10Z rdm $
// Author: Fons Rademakers   04/08/95

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 25 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooPrintable.h" 2

class RooPrintable {
public:
  inline RooPrintable() { }
  inline virtual ~RooPrintable() { }

  // New-style printing

  // Master print function
  enum ContentsOption { kName=1, kClassName=2, kValue=4, kArgs=8, kExtras=16, kAddress=32, kTitle=64, kCollectionHeader=128} ; // Can be ORed
  enum StyleOption { kInline=1, kSingleLine=2, kStandard=3, kVerbose=4, kTreeStructure=5 } ; // Exclusive
  virtual void printStream(std::ostream& os, Int_t contents, StyleOption style, TString indent="") const ;

  // Virtual hook function for class-specific content implementation
  virtual void printAddress(std::ostream& os) const ;
  virtual void printName(std::ostream& os) const ;
  virtual void printTitle(std::ostream& os) const ;
  virtual void printClassName(std::ostream& os) const ;
  virtual void printValue(std::ostream& os) const ;
  virtual void printArgs(std::ostream& os) const ;
  virtual void printExtras(std::ostream& os) const ;
  virtual void printMultiline(std::ostream& os, Int_t contents, Bool_t verbose=kFALSE, TString indent="") const ;
  virtual void printTree(std::ostream& os, TString indent="") const ;

  static std::ostream& defaultPrintStream(std::ostream *os= 0);
  virtual Int_t defaultPrintContents(Option_t* opt) const ;
  virtual StyleOption defaultPrintStyle(Option_t* opt) const ;

  // Formatting control
  static void nameFieldLength(Int_t newLen) ;

protected:

  static Int_t _nameLength ;

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return RooPrintable::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooPrintable::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooPrintable.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 60; } // Interface for printable objects


};

namespace RooFit {
std::ostream& operator<<(std::ostream& os, const RooPrintable& rp) ;
}
# 24 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsArg.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooRefCountList.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooRefCountList.h,v 1.7 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooLinkedList.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooLinkedList.h,v 1.15 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TNamed.h" 1
// @(#)root/base:$Id: TNamed.h 20877 2007-11-19 11:17:07Z rdm $
// Author: Rene Brun   26/12/94

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooLinkedList.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooLinkedListElem.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooLinkedListElem.h,v 1.11 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h" 1
/* @(#)root/base:$Id: Rtypes.h 43708 2012-04-12 10:19:00Z axel $ */

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooLinkedListElem.h" 2

class TObject ;
class RooLinkedListElem ;
class TBuffer ;

class RooLinkedListElem {
public:
  // Initial element ctor
  RooLinkedListElem() :
    _prev(0), _next(0), _arg(0), _refCount(0), _suc(0) {
  }

  void init(TObject* arg, RooLinkedListElem* after=0, Int_t* suc=0) {
   _arg = arg ;
   _refCount = 1 ;

   if (after) {
     _prev = after ;
     _next = after->_next ;
     after->_next = this ;
     if (_next) {
       _next->_prev = this ;
     }
   }
   _suc = suc ;
   (*_suc)++ ;
 }

 void release() {
   if (_prev) _prev->_next = _next ;
   if (_next) _next->_prev = _prev ;
   _prev = 0 ;
   _next = 0 ;
   (*_suc)-- ;
 }

  RooLinkedListElem(TObject* arg) :
    // Constructor with payload
    _prev(0), _next(0), _arg(arg), _refCount(1), _suc(0) {
  }

  RooLinkedListElem(TObject* arg, RooLinkedListElem* after) :
    // Constructor with payload and next chain element
    _prev(after), _next(after->_next), _arg(arg), _refCount(1), _suc(0) {

    // Insert self in link
    after->_next = this ;
    if (_next) _next->_prev = this ;
  }

  // Destructor
  virtual ~RooLinkedListElem() {
    // Remove self from link
    if (_prev) _prev->_next = _next ;
    if (_next) _next->_prev = _prev ;
  }

  Int_t refCount() const { return _refCount ; }
  Int_t incRefCount() { return ++_refCount ; }
  Int_t decRefCount() { return --_refCount ; }

protected:
  friend class RooHashTable ;
  friend class RooLinkedList ;
  friend class RooLinkedListIter ;
  friend class RooFIter ;
  RooLinkedListElem* _prev ; // Link to previous element in list
  RooLinkedListElem* _next ; // Link to next element in list
  TObject* _arg ; // Link to contents
  Int_t _refCount ; //! Reference count
  Int_t* _suc ; //! Store use count

protected:

  // Forbidden
  RooLinkedListElem(const RooLinkedListElem&) ;

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 0; } static void Dictionary(); virtual TClass *IsA() const { return RooLinkedListElem::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooLinkedListElem::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooLinkedListElem.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 97; } // Element of RooLinkedList container class
} ;
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooLinkedList.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooHashTable.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooHashTable.h,v 1.12 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TObject.h" 1
// @(#)root/base:$Id: TObject.h 38832 2011-04-13 17:54:49Z rdm $
// Author: Rene Brun   26/12/94

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooHashTable.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TString.h" 1
// @(#)root/base:$Id: TString.h 43133 2012-02-27 09:50:10Z rdm $
// Author: Fons Rademakers   04/08/95

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooHashTable.h" 2

class RooAbsArg ;
class RooLinkedList ;
class RooLinkedListElem ;
class RooSetPair ;
class RooArgSet ;

class RooHashTable : public TObject {
public:

  enum HashMethod { Pointer=0, Name=1, Intrinsic=2 } ;

  // Constructor
  RooHashTable(Int_t initSize = 17, HashMethod hashMethod=Name) ;
  RooHashTable(const RooHashTable& other) ;

  // Destructor
  virtual ~RooHashTable() ;

  void add(TObject* arg, TObject* hashArg=0) ;
  Bool_t remove(TObject* arg, TObject* hashArg=0) ;
  TObject* find(const char* name) const ;
  RooAbsArg* findArg(const RooAbsArg* arg) const ;
  TObject* find(const TObject* arg) const ;
  RooLinkedListElem* findLinkTo(const TObject* arg) const ;
  RooSetPair* findSetPair(const RooArgSet* set1, const RooArgSet* set2) const ;
  Bool_t replace(const TObject* oldArg, const TObject* newArg, const TObject* oldHashArg=0) ;
  Int_t size() const { return _size ; }
  Int_t entries() const { return _entries ; }
  Double_t avgCollisions() const ;

protected:
  inline ULong_t hash(const TObject* arg) const {
    // Return hash value calculated by method chosen in constructor
    switch(_hashMethod) {
      case Pointer: return TString::Hash((void*)(&arg),sizeof(void*)) ;
      case Name: return TString::Hash(arg->GetName(),strlen(arg->GetName())) ;
      case Intrinsic: return arg->Hash() ;
    }
    return 0 ;
  }

  HashMethod _hashMethod ; // Hashing method
  Int_t _usedSlots ; // Number of used slots
  Int_t _entries ; // Number of entries stored
  Int_t _size ; // Total number of slots
  RooLinkedList** _arr ; //! Array of linked lists storing elements in each slot

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return RooHashTable::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooHashTable::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooHashTable.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 69; } // Hash table
};
# 22 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooLinkedList.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/list" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_list" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <list.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/list

#pragma ifndef PREC_STL_LIST
#pragma define PREC_STL_LIST
#pragma link off global PREC_STL_LIST;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from ANSI/ISO C++ 1997/Nov draft 
// Got some ideas from Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <iterator.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/iterator

#pragma ifndef PREC_STL_ITERATOR
#pragma define PREC_STL_ITERATOR
#pragma link off global PREC_STL_ITERATOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from STL HP implementation 1994
// Imported from STL SGI implementation 1997 
// Imported from ANSI/ISO C++ draft Nov 1997
// Modified by Masaharu Goto
// May need improvement for the latest standard


////////////////////////////////////////////////////////////////////////
// iterator_tag
////////////////////////////////////////////////////////////////////////
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag {};
struct bidirectional_iterator_tag {};
struct random_access_iterator_tag {};

////////////////////////////////////////////////////////////////////////
// iterator template
////////////////////////////////////////////////////////////////////////
template <class T, class Distance> struct input_iterator {};
struct output_iterator {};
template <class T, class Distance> struct forward_iterator {};
template <class T, class Distance> struct bidirectional_iterator {};
template <class T, class Distance> struct random_access_iterator {};

#pragma link off class output_iterator;







////////////////////////////////////////////////////////////////////////
// iterator_category overloaded function
////////////////////////////////////////////////////////////////////////
template <class T, class Distance>
inline input_iterator_tag
iterator_category(const input_iterator<T, Distance>&) {
    return input_iterator_tag();
}

inline output_iterator_tag iterator_category(const output_iterator&) {
    return output_iterator_tag();
}

#pragma link off function iterator_category(const output_iterator&);


template <class T, class Distance>
inline forward_iterator_tag
iterator_category(const forward_iterator<T, Distance>&) {
    return forward_iterator_tag();
}

template <class T, class Distance>
inline bidirectional_iterator_tag
iterator_category(const bidirectional_iterator<T, Distance>&) {
    return bidirectional_iterator_tag();
}

template <class T, class Distance>
inline random_access_iterator_tag
iterator_category(const random_access_iterator<T, Distance>&) {
    return random_access_iterator_tag();
}

template <class T>
inline random_access_iterator_tag
iterator_category(const T*) {
    return random_access_iterator_tag();
}


// iterator_traits, iterator and reverse_iterator template may not be
// needed for precompiled library interface 

////////////////////////////////////////////////////////////////////////
// iterator_traits
////////////////////////////////////////////////////////////////////////

template <class Iterator>
struct iterator_traits {
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type value_type;
  typedef typename Iterator::difference_type difference_type;
  typedef typename Iterator::pointer pointer;
  typedef typename Iterator::reference reference;
};

// template partial specialization, implement in cint5.15.14 1587
template <class T>
struct iterator_traits<T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
};

// incomplete implementation in cint5.15.14 1587, need some fix
// iterator_traits<const int*> is changed as iterator_traits<const int* const>
// or something, but cint5.15.14 can not handle this well
template <class T>
struct iterator_traits<const T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef const T* pointer;
  typedef const T& reference;
};

////////////////////////////////////////////////////////////////////////
// iterator
////////////////////////////////////////////////////////////////////////
template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator {
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
  typedef Category iterator_category;
};


////////////////////////////////////////////////////////////////////////
// reverse_iterator
////////////////////////////////////////////////////////////////////////






template <class Iterator>
class reverse_iterator
# 166 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
{




 public:
# 181 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
   typedef Iterator::pointer pointer;
   typedef Iterator::reference reference;
   typedef ptrdiff_t difference_type;


   reverse_iterator();
   //reverse_iterator(Iterator x);



   Iterator base() const; // explicit
   reference operator*() const;
   pointer operator->() const;
   reverse_iterator& operator++();
   reverse_iterator operator++(int);
   reverse_iterator& operator--();
   reverse_iterator operator--(int);
   reverse_iterator operator+ (difference_type n) const;
   reverse_iterator& operator+=(difference_type n);
   reverse_iterator operator- (difference_type n) const;
   reverse_iterator& operator-=(difference_type n);
   reference operator[](difference_type n) const;
};
# 932 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
// for g++ 3.1,3.2
namespace __gnu_cxx
{
  // This iterator adapter is 'normal' in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                    difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparaison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  // _GLIBCPP_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
     const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
} // namespace __gnu_cxx







#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 2
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <memory.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/memory

#pragma ifndef PREC_STL_MEMORY
#pragma define PREC_STL_MEMORY
#pragma link off global PREC_STL_MEMORY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////


template <class _Tp>
class allocator {
  //typedef alloc _Alloc;          // The underlying allocator.
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  typedef typename _Tp* pointer;
  typedef const typename _Tp * const_pointer;




  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() ;
  allocator(const allocator&) ;
  //template <class _Tp1> allocator(const allocator<_Tp1>&) ;
  ~allocator() ;

  pointer address(reference __x) const ;
  const_pointer address(const_reference __x) const ;

  // __n is permitted to be 0.  The C++ standard says nothing about what
  // the return value is when __n == 0.
  _Tp* allocate(size_type __n, const void* = 0) ;

  // __p is not permitted to be a null pointer.
  void deallocate(pointer __p, size_type __n);

  size_type max_size() const ;

  void construct(pointer __p, const _Tp& __val) ;
  void destroy(pointer __p) ;
};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;
  typedef void value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };
};
//////////////////////////////////////////////////////////////////////
# 205 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////

/**********************************************************************
* auto_ptr
**********************************************************************/
template <class X> class auto_ptr {
private:
  X* ptr;
  //template<class Y> struct auto_ptr_ref { };
public:
  typedef X element_type;
  explicit auto_ptr(X* p = 0) : ptr(p) {}
  auto_ptr(auto_ptr& a) {ptr=a.ptr;}

  // this implementation may not be correct
  template <class T> auto_ptr(auto_ptr<T>& a) {ptr=a.release();}
# 229 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  auto_ptr& operator=(auto_ptr& a) {
    if (a.ptr != ptr) {
      delete ptr;
      ptr = a.ptr;
    }
    return(*this);
  }

  // this implementation may not be correct
  template <class T> auto_ptr& operator=(auto_ptr<T>& a) {
    if (a.ptr != ptr) {
       delete ptr;
       ptr = a.release();
    }
    return(*this);
  }

  ~auto_ptr() { delete ptr; }

  X& operator*() const { return *ptr; }
  X* operator->() const { return ptr; }
  X* get() const { return ptr; }
  X* release() { X *old = ptr; ptr = 0; return 0; }
# 262 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  // auto_ptr conversions
  //auto_ptr(auto_ptr_ref<X>& x) { }
  //template<class Y> operator auto_ptr_ref<Y>() { return auto_ptr_ref<Y>(); }
  //template<class Y> operator auto_ptr<Y>() { return auto_ptr<T>(); }
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 2
# 28 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list" 2


template<class T,class Allocator=std::allocator<T> >
# 44 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
class list {
 public:
  typedef T value_type;
  typedef Allocator allocator_type;

  typedef void* void_pointer;
  //typedef __list_node<T> list_node;
  //typedef simple_alloc<list_node, Alloc> list_node_allocator;
  //typedef list_node* link_type;
  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
# 68 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
  class iterator
# 84 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
 {
   public:
    iterator() ;
    iterator(const iterator& x) ;

    iterator& operator=(const iterator& x) ;

    T& operator*() const ;

    T* operator->() const ;

    iterator& operator++();
    iterator operator++(int a);
    iterator& operator--();
    iterator operator--(int a);
    bool operator==(const iterator& x) ;

    bool operator!=(const iterator& x) ;





  };







  class reverse_iterator
# 131 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
 {
   public:
    reverse_iterator(const reverse_iterator& x) ;

    reverse_iterator& operator=(const reverse_iterator& x) ;

    T& operator*() const ;

    T* operator->() const ;

    reverse_iterator& operator++();
    reverse_iterator operator++(int a);
    reverse_iterator& operator--();
    reverse_iterator operator--(int a);




  };

  friend bool operator==(const list::reverse_iterator& x
                        ,const list::reverse_iterator& y) const;
  friend bool operator!=(const list::reverse_iterator& x
                        ,const list::reverse_iterator& y) const;

  typedef const iterator const_iterator;
  typedef const reverse_iterator const_reverse_iterator;
# 168 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
  list() ;
  iterator begin() ;
  iterator end() ;
  reverse_iterator rbegin() ;
  reverse_iterator rend() ;






  bool empty() const ;
  size_type size() const ;
  size_type max_size() const ;
  T& front() const ;
  T& back() const ;
  void swap(list& x) ;
  iterator insert(iterator position,const T& x);
  void insert(iterator position,T* first,T* last);
  void insert(iterator position,iterator first,iterator last);
  void insert(iterator position,size_type n,const T& x);
  void push_front(const T& x);
  void push_back(const T& x);
  void resize(size_type n);
  void resize(size_type n, T v);
  void erase(iterator position);
  void erase(iterator first,iterator last);
  void clear() ;
  void pop_front();
  void pop_back();
  list(size_type n,const T& value=T()) ;






  list(const T* first,const T* last) ;

  list(const_iterator first, const_iterator last) ;

  list(const list& x) ;
  ~list() ;
  list& operator=(const list& x) ;
  void splice(iterator position,list& x);
  void splice(iterator position,list& x,iterator i);
  void splice(iterator position,list& x,iterator first,iterator last);
  void remove(const T& value);
  void unique();
  void merge(list& x);
  void reverse();
  void sort();

  friend bool operator==(const list& x, const list& y);
  friend bool operator< (const list& x, const list& y);
  friend bool operator!=(const list& x, const list& y);
  friend bool operator> (const list& x, const list& y);
  friend bool operator>=(const list& x, const list& y);
  friend bool operator<=(const list& x, const list& y);

  // specialized algorithms:





#pragma ifndef G__NOALGORITHM
  // Generic algorithm


  // input iter
  friend list::iterator
    find(list::iterator first,list::iterator last,const T& value);
  // forward iter
  friend list::iterator
    find_end(list::iterator first1,list::iterator last1,
      list::iterator first2,list::iterator last2);
  friend list::iterator
    find_first_of(list::iterator first1,list::iterator last1,
           list::iterator first2,list::iterator last2);
  friend list::iterator
    adjacent_find(list::iterator first,list::iterator last);
  // input iter

  friend list::difference_type
    count(list::iterator first,list::iterator last,const T& value);






  friend bool
    equal(list::iterator first1,list::iterator last1,
          list::iterator first2);
  // forward iter
  friend list::iterator
    search(list::iterator first1,list::iterator last1,
           list::iterator first2,list::iterator last2);
  friend list::iterator
    search_n(list::iterator first,list::iterator last
             ,list::size_type count,const T& value);
  // input and output iter -> forward iter
  friend list::iterator
    copy(list::iterator first,list::iterator last,
         list::iterator result);
  // bidirectional iter
  friend list::iterator
    copy_backward(list::iterator first,list::iterator last,
                  list::iterator result);
  // just value_type
  friend void swap(T& a,T& b);
  // forward iter
  friend list::iterator
    swap_ranges(list::iterator first1,list::iterator last1,
                list::iterator first2);
  friend void iter_swap(list::iterator a,list::iterator b);
  friend void replace(list::iterator first,list::iterator last,
                      const T& old_value,const T& new_value);
  // input, output iter -> forward iter
  friend list::iterator
    replace_copy(list::iterator first,list::iterator last,
                 list::iterator result,
                 const T& old_value,const T& new_value);
  // forward iter
  friend void
    fill(list::iterator first,list::iterator last,const T& value);

  friend void
    fill_n(list::iterator first,list::size_type n,const T& value);

  friend list::iterator
    remove(list::iterator first,list::iterator last,const T& value);
  // input,output iter -> forward iter
  friend list::iterator
    remove_copy(list::iterator first,list::iterator last,
                list::iterator result,const T& value);
  friend list::iterator
    unique(list::iterator first,list::iterator last);
  friend list::iterator
    unique_copy(list::iterator first,list::iterator last,
                list::iterator result);
  friend void reverse(list::iterator first,list::iterator last);
  friend list::iterator
     reverse_copy(list::iterator first,list::iterator last,
                  list::iterator result);
  // forward iter
  friend void rotate(list::iterator first,list::iterator mid,
                     list::iterator last);
  // forward iter
  friend list::iterator
    rotate_copy(list::iterator first,list::iterator mid,
                list::iterator last,list::iterator result);
# 336 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
  // forward iter
  friend list::iterator
    lower_bound(list::iterator first,list::iterator last,const T& value);
  friend list::iterator
    upper_bound(list::iterator first,list::iterator last,const T& value);




  friend bool binary_search(list::iterator first,list::iterator last,
                            const T& value);
  friend list::iterator merge(list::iterator first1,list::iterator last1,
                                list::iterator first2,list::iterator last2,
                                list::iterator result);
  friend void inplace_merge(list::iterator first,list::iterator middle,
                            list::iterator last);
  friend bool includes(list::iterator first1,list::iterator last1,
                       list::iterator first2,list::iterator last2);
  friend list::iterator
    set_union(list::iterator first1,list::iterator last1,
              list::iterator first2,list::iterator last2,
              list::iterator result);
  friend list::iterator
    set_intersection(list::iterator first1,list::iterator last1,
                     list::iterator first2,list::iterator last2,
                     list::iterator result);
  friend list::iterator
    set_difference(list::iterator first1,list::iterator last1,
                   list::iterator first2,list::iterator last2,
                   list::iterator result);
  friend list::iterator
    set_symmetric_difference(list::iterator first1,list::iterator last1,
                             list::iterator first2,list::iterator last2,
                             list::iterator result);







  // min,max, just value_type
  friend const T& min(const T& a,const T& b);
  friend const T& max(const T& a,const T& b);
  // forward iter
  friend list::iterator
    min_element(list::iterator first,list::iterator last);
  friend list::iterator
    max_element(list::iterator first,list::iterator last);
  // input iter
  friend bool
    lexicographical_compare(list::iterator first1,list::iterator last1,
                            list::iterator first2,list::iterator last2);
  // bidirectional iter
  friend bool next_permutation(list::iterator first,list::iterator last);
  friend bool prev_permutation(list::iterator first,list::iterator last);
# 417 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
#pragma endif

  // Generic algorithm
  //friend void reverse(list::iterator first,list::iterator last);
  //friend void reverse(list::reverse_iterator first,list::reverse_itetator last);


  // iterator_category resolution
  //friend bidirectional_iterator_tag iterator_category(list::iterator x);
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_list" 2
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/list" 2
}
# 23 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooLinkedList.h" 2
class RooLinkedListIter ;
class RooFIter ;
class TIterator ;
class RooAbsArg ;

class RooLinkedList : public TObject {
public:
  // Constructor
  RooLinkedList(Int_t htsize=0) ;

  // Copy constructor
  RooLinkedList(const RooLinkedList& other) ;

  virtual TObject* Clone(const char* =0) const {
    return new RooLinkedList(*this) ;
  }

  // Assignment operator
  RooLinkedList& operator=(const RooLinkedList& other) ;

  Int_t getHashTableSize() const {
    // Return size of hash table
    return _htableName ? _htableName->size() : 0 ;
  }

  void setHashTableSize(Int_t size) ;

  // Destructor
  virtual ~RooLinkedList() ;

  Int_t GetSize() const { return _size ; }

  virtual void Add(TObject* arg) { Add(arg,1) ; }
  virtual Bool_t Remove(TObject* arg) ;
  TObject* At(Int_t index) const ;
  Bool_t Replace(const TObject* oldArg, const TObject* newArg) ;
  TIterator* MakeIterator(Bool_t dir=kTRUE) const ;
  RooLinkedListIter iterator(Bool_t dir=kTRUE) const ;
  RooFIter fwdIterator() const ;

  void Clear(Option_t *o=0) ;
  void Delete(Option_t *o=0) ;
  TObject* find(const char* name) const ;
  RooAbsArg* findArg(const RooAbsArg*) const ;
  TObject* FindObject(const char* name) const ;
  TObject* FindObject(const TObject* obj) const ;
  Int_t IndexOf(const char* name) const ;
  Int_t IndexOf(const TObject* arg) const ;
  TObject* First() const {
    return _first?_first->_arg:0 ;
  }

  void Print(const char* opt) const ;
  void Sort(Bool_t ascend=kTRUE) ;

  const char* GetName() const { return _name.Data() ; }
  void SetName(const char* name) { _name = name ; }

protected:

  RooLinkedListElem* createElement(TObject* obj, RooLinkedListElem* elem=0) ;
  void deleteElement(RooLinkedListElem*) ;


  friend class RooLinkedListIter ;
  friend class RooFIter ;

  virtual void Add(TObject* arg, Int_t refCount) ;

  void swapWithNext(RooLinkedListElem* elem) ;

  RooLinkedListElem* findLink(const TObject* arg) const ;

  Int_t _hashThresh ; //  Size threshold for hashing
  Int_t _size ; //  Current size of list
  RooLinkedListElem* _first ; //! Link to first element of list
  RooLinkedListElem* _last ; //! Link to last element of list
  RooHashTable* _htableName ; //! Hash table by name 
  RooHashTable* _htableLink ; //! Hash table by link pointer

  Int_t _curStoreSize ; //!
  Int_t _curStoreUsed ; //!
  std::list<std::pair<Int_t,RooLinkedListElem*> > _storeList ; //!
  RooLinkedListElem* _curStore ; //!

  TString _name ;

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 2; } static void Dictionary(); virtual TClass *IsA() const { return RooLinkedList::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooLinkedList::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooLinkedList.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 110; } // Doubly linked list for storage of RooAbsArg objects
};
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooRefCountList.h" 2

class RooRefCountList : public RooLinkedList {
public:
  RooRefCountList() ;
  virtual ~RooRefCountList() {} ;

  virtual void Add(TObject* arg) { Add(arg,1) ; }
  virtual void Add(TObject* obj, Int_t count) ;
  virtual Bool_t Remove(TObject* obj) ;
  virtual Bool_t RemoveAll(TObject* obj) ;
  Int_t refCount(TObject* obj) ;

protected:
  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return RooRefCountList::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooRefCountList::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooRefCountList.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 33; } // RooLinkedList with reference counting
};
# 25 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsArg.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsCache.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooAbsCache.h 44982 2012-07-10 08:36:13Z moneta $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h" 1
/* @(#)root/base:$Id: Rtypes.h 43708 2012-04-12 10:19:00Z axel $ */

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsCache.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Riosfwd.h" 1
// @(#)root/base:$Id: Riosfwd.h 20877 2007-11-19 11:17:07Z rdm $
// Author: Fons Rademakers   23/1/02

/*************************************************************************
 * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsCache.h" 2

class RooAbsArg ;
class RooAbsCollection ;
class RooArgSet ;
class RooArgList ;
class RooLinkedList ;

class RooAbsCache {

public:

  RooAbsCache(RooAbsArg* owner=0) ;
  RooAbsCache(const RooAbsCache&, RooAbsArg* owner=0 ) ;
  virtual Bool_t redirectServersHook(const RooAbsCollection& /*newServerList*/, Bool_t /*mustReplaceAll*/, Bool_t /*nameChange*/, Bool_t /*isRecursive*/) ;
  virtual void operModeHook() ;
  virtual void optimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList& ) ;
  virtual void findConstantNodes(const RooArgSet&, RooArgSet& , RooLinkedList&) ;
  virtual void printCompactTreeHook(std::ostream&, const char *) ;
  virtual void wireCache() {} ;

  virtual ~RooAbsCache() ;

protected:

  RooAbsArg* _owner ; // Pointer to owning RooAbsArg

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return RooAbsCache::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooAbsCache::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsCache.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 47; } // Base class for cache managers 

} ;
# 26 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsArg.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooLinkedListIter.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooLinkedListIter.h,v 1.11 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h" 1
/* @(#)root/base:$Id: Rtypes.h 43708 2012-04-12 10:19:00Z axel $ */

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooLinkedListIter.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TIterator.h" 1
// @(#)root/cont:$Id: TIterator.h 43515 2012-03-27 21:15:53Z pcanal $
// Author: Fons Rademakers   13/08/95

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooLinkedListIter.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooLinkedList.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooLinkedList.h,v 1.15 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 22 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooLinkedListIter.h" 2







class RooFIter
{
  public:
  inline RooFIter() : _ptr (0) {}
  inline RooFIter(const RooLinkedList* list) : _ptr (list->_first) {}

  inline RooAbsArg *next() {
    // Return next element in collection
    if (!_ptr) return 0 ;
    TObject* arg = _ptr->_arg ;
    _ptr = _ptr->_next;
    return (RooAbsArg*) arg ;
  }

 private:
    const RooLinkedListElem* _ptr ; //! Next link element
};



class RooLinkedListIter : public TIterator {
public:

  RooLinkedListIter() {
    // coverity[UNINIT_CTOR]
  } ;


  RooLinkedListIter(const RooLinkedList* list, Bool_t forward) :
    TIterator(), _forward(forward), _list(list)
  {
    // Constructor from list with direction
    _ptr = _list->_first ;
    _cptr = _ptr;
  }

  RooLinkedListIter(const RooLinkedListIter& other) :
    TIterator(other),
    _forward(other._forward),
    _cptr(other._cptr),
    _ptr(other._ptr),
    _list(other._list)
  {
    // Copy constructor
  }

  virtual ~RooLinkedListIter() { ; }

  TIterator& operator=(const TIterator& other) {

    // Iterator assignment operator

    if (&other==this) return *this ;
    const RooLinkedListIter* iter = dynamic_cast<const RooLinkedListIter*>(&other) ;
    if (iter) {
      _list = iter->_list ;
      _ptr = iter->_ptr ;
      _cptr = iter->_cptr;
      _forward = iter->_forward ;
    }
    return *this ;
  }

  virtual const TCollection *GetCollection() const {
    // Dummy
    return 0 ;
  }

  virtual TObject *Next() {
    // Return next element in collection
    if (!_ptr) return 0 ;
    _cptr = _ptr;
    TObject* arg = _ptr->_arg ;
    _ptr = _forward ? _ptr->_next : _ptr->_prev ;
    return arg ;
  }

  TObject *NextNV() {
    // Return next element in collection
    if (!_ptr) return 0 ;
    _cptr = _ptr;
    TObject* arg = _ptr->_arg ;
    _ptr = _forward ? _ptr->_next : _ptr->_prev ;
    return arg ;
  }


  virtual void Reset() {
    // Return iterator to first element in collection
    _ptr = _forward ? _list->_first : _list->_last ;
    _cptr = _ptr;
  }

  bool operator!=(const TIterator &aIter) const {
    if (0 == &aIter)
       return _cptr;
    if ((aIter.IsA() == RooLinkedListIter::Class())) {
       const RooLinkedListIter &iter(dynamic_cast<const RooLinkedListIter &>(aIter));
       return (_cptr != iter._cptr);
    }
    return false; // for base class we don't implement a comparison
  }

  bool operator!=(const RooLinkedListIter &aIter) const {
    if (0 == (&aIter))
      return _cptr;

    return (_cptr != aIter._cptr);
  }

  virtual TObject *operator*() const {
    // Return element iterator points to
    return (_cptr ? _cptr->_arg : 0);
  }

protected:
  Bool_t _forward ; //  Iterator direction
  const RooLinkedListElem* _cptr ; //! Current link element
  const RooLinkedListElem* _ptr ; //! Next link element
  const RooLinkedList* _list ; //! Collection iterated over

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return RooLinkedListIter::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooLinkedListIter::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooLinkedListIter.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 150; } // Iterator for RooLinkedList container class
} ;
# 27 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsArg.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooNameReg.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooNameReg.h,v 1.3 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TNamed.h" 1
// @(#)root/base:$Id: TNamed.h 20877 2007-11-19 11:17:07Z rdm $
// Author: Rene Brun   26/12/94

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooNameReg.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooHashTable.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooHashTable.h,v 1.12 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooNameReg.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooLinkedList.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooLinkedList.h,v 1.15 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 22 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooNameReg.h" 2

class RooNameReg : public TNamed {
public:

  static RooNameReg& instance() ;
  virtual ~RooNameReg();
  const TNamed* constPtr(const char* stringPtr) ;
  const char* constStr(const TNamed* namePtr) ;
  static const TNamed* ptr(const char* stringPtr) ;
  static const char* str(const TNamed* ptr) ;

  static void cleanup() ;

protected:

  static RooNameReg* _instance ;

  RooNameReg() : TNamed("RooNameReg","RooFit Name Registry"), _htable(31) {}
  RooNameReg(const RooNameReg& other) ;

  RooHashTable _htable ; // Repository of registered names
  RooLinkedList _list ; // 

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return RooNameReg::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooNameReg::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooNameReg.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 45; } // String name registry
};
# 28 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsArg.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/map" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_map" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <pair.dll>
#pragma include_noerr <map.dll>
#pragma include_noerr <map2.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/map

#pragma ifndef PREC_STL_MAP
#pragma define PREC_STL_MAP
#pragma link off global PREC_STL_MAP;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from ANSI/ISO C++ 1997/Nov draft 
// Got some ideas from Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <utility.dll>


#pragma include_noerr <pair.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/utility

#pragma ifndef PREC_STL_UTILITY
#pragma define PREC_STL_UTILITY
#pragma link off global PREC_STL_UTILITY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

template <class T1, class T2>
struct pair {
  T1 first;
  T2 second;
  pair() : first(T1()), second(T2()) {}
  pair(const T1& a, const T2& b) : first(a), second(b) {}
 private:
  pair& operator=(const pair& x){first=x.first;second=x.second;return *this;}
};

#pragma endif
# 17 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 2
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <memory.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/memory

#pragma ifndef PREC_STL_MEMORY
#pragma define PREC_STL_MEMORY
#pragma link off global PREC_STL_MEMORY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////


template <class _Tp>
class allocator {
  //typedef alloc _Alloc;          // The underlying allocator.
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  typedef typename _Tp* pointer;
  typedef const typename _Tp * const_pointer;




  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() ;
  allocator(const allocator&) ;
  //template <class _Tp1> allocator(const allocator<_Tp1>&) ;
  ~allocator() ;

  pointer address(reference __x) const ;
  const_pointer address(const_reference __x) const ;

  // __n is permitted to be 0.  The C++ standard says nothing about what
  // the return value is when __n == 0.
  _Tp* allocate(size_type __n, const void* = 0) ;

  // __p is not permitted to be a null pointer.
  void deallocate(pointer __p, size_type __n);

  size_type max_size() const ;

  void construct(pointer __p, const _Tp& __val) ;
  void destroy(pointer __p) ;
};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;
  typedef void value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };
};
//////////////////////////////////////////////////////////////////////
# 205 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////

/**********************************************************************
* auto_ptr
**********************************************************************/
template <class X> class auto_ptr {
private:
  X* ptr;
  //template<class Y> struct auto_ptr_ref { };
public:
  typedef X element_type;
  explicit auto_ptr(X* p = 0) : ptr(p) {}
  auto_ptr(auto_ptr& a) {ptr=a.ptr;}

  // this implementation may not be correct
  template <class T> auto_ptr(auto_ptr<T>& a) {ptr=a.release();}
# 229 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  auto_ptr& operator=(auto_ptr& a) {
    if (a.ptr != ptr) {
      delete ptr;
      ptr = a.ptr;
    }
    return(*this);
  }

  // this implementation may not be correct
  template <class T> auto_ptr& operator=(auto_ptr<T>& a) {
    if (a.ptr != ptr) {
       delete ptr;
       ptr = a.release();
    }
    return(*this);
  }

  ~auto_ptr() { delete ptr; }

  X& operator*() const { return *ptr; }
  X* operator->() const { return ptr; }
  X* get() const { return ptr; }
  X* release() { X *old = ptr; ptr = 0; return 0; }
# 262 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  // auto_ptr conversions
  //auto_ptr(auto_ptr_ref<X>& x) { }
  //template<class Y> operator auto_ptr_ref<Y>() { return auto_ptr_ref<Y>(); }
  //template<class Y> operator auto_ptr<Y>() { return auto_ptr<T>(); }
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 2
# 28 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <iterator.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/iterator

#pragma ifndef PREC_STL_ITERATOR
#pragma define PREC_STL_ITERATOR
#pragma link off global PREC_STL_ITERATOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from STL HP implementation 1994
// Imported from STL SGI implementation 1997 
// Imported from ANSI/ISO C++ draft Nov 1997
// Modified by Masaharu Goto
// May need improvement for the latest standard


////////////////////////////////////////////////////////////////////////
// iterator_tag
////////////////////////////////////////////////////////////////////////
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag {};
struct bidirectional_iterator_tag {};
struct random_access_iterator_tag {};

////////////////////////////////////////////////////////////////////////
// iterator template
////////////////////////////////////////////////////////////////////////
template <class T, class Distance> struct input_iterator {};
struct output_iterator {};
template <class T, class Distance> struct forward_iterator {};
template <class T, class Distance> struct bidirectional_iterator {};
template <class T, class Distance> struct random_access_iterator {};

#pragma link off class output_iterator;







////////////////////////////////////////////////////////////////////////
// iterator_category overloaded function
////////////////////////////////////////////////////////////////////////
template <class T, class Distance>
inline input_iterator_tag
iterator_category(const input_iterator<T, Distance>&) {
    return input_iterator_tag();
}

inline output_iterator_tag iterator_category(const output_iterator&) {
    return output_iterator_tag();
}

#pragma link off function iterator_category(const output_iterator&);


template <class T, class Distance>
inline forward_iterator_tag
iterator_category(const forward_iterator<T, Distance>&) {
    return forward_iterator_tag();
}

template <class T, class Distance>
inline bidirectional_iterator_tag
iterator_category(const bidirectional_iterator<T, Distance>&) {
    return bidirectional_iterator_tag();
}

template <class T, class Distance>
inline random_access_iterator_tag
iterator_category(const random_access_iterator<T, Distance>&) {
    return random_access_iterator_tag();
}

template <class T>
inline random_access_iterator_tag
iterator_category(const T*) {
    return random_access_iterator_tag();
}


// iterator_traits, iterator and reverse_iterator template may not be
// needed for precompiled library interface 

////////////////////////////////////////////////////////////////////////
// iterator_traits
////////////////////////////////////////////////////////////////////////

template <class Iterator>
struct iterator_traits {
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type value_type;
  typedef typename Iterator::difference_type difference_type;
  typedef typename Iterator::pointer pointer;
  typedef typename Iterator::reference reference;
};

// template partial specialization, implement in cint5.15.14 1587
template <class T>
struct iterator_traits<T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
};

// incomplete implementation in cint5.15.14 1587, need some fix
// iterator_traits<const int*> is changed as iterator_traits<const int* const>
// or something, but cint5.15.14 can not handle this well
template <class T>
struct iterator_traits<const T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef const T* pointer;
  typedef const T& reference;
};

////////////////////////////////////////////////////////////////////////
// iterator
////////////////////////////////////////////////////////////////////////
template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator {
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
  typedef Category iterator_category;
};


////////////////////////////////////////////////////////////////////////
// reverse_iterator
////////////////////////////////////////////////////////////////////////






template <class Iterator>
class reverse_iterator
# 166 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
{




 public:
# 181 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
   typedef Iterator::pointer pointer;
   typedef Iterator::reference reference;
   typedef ptrdiff_t difference_type;


   reverse_iterator();
   //reverse_iterator(Iterator x);



   Iterator base() const; // explicit
   reference operator*() const;
   pointer operator->() const;
   reverse_iterator& operator++();
   reverse_iterator operator++(int);
   reverse_iterator& operator--();
   reverse_iterator operator--(int);
   reverse_iterator operator+ (difference_type n) const;
   reverse_iterator& operator+=(difference_type n);
   reverse_iterator operator- (difference_type n) const;
   reverse_iterator& operator-=(difference_type n);
   reference operator[](difference_type n) const;
};
# 932 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
// for g++ 3.1,3.2
namespace __gnu_cxx
{
  // This iterator adapter is 'normal' in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                    difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparaison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  // _GLIBCPP_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
     const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
} // namespace __gnu_cxx







#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 2
# 29 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_functional" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <functional.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/functional" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/functional

#pragma ifndef PREC_STL_FUNCTIONAL
#pragma define PREC_STL_FUNCTIONAL
#pragma link off global PREC_STL_FUNCTIONAL;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab

// clause _lib.base_, base:
template <class Arg, class Result>
struct unary_function
{
  typedef Arg argument_type;
  typedef Result result_type;
};


template <class Arg1, class Arg2, class Result>
struct binary_function
{
  typedef Arg1 first_argument_type;
  typedef Arg2 second_argument_type;
  typedef Result result_type;
};


// clause _lib.arithmetic.operations_, arithmetic operations:
template <class T> struct plus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct minus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct multiplies : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct divides : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};

template <class T> struct modulus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};

template <class T> struct negate : unary_function<T,T> {
  T operator()(const T& x) const;
};


// clause _lib.comparisons_, comparisons:
template <class T> struct equal_to : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct not_equal_to : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct greater : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct less : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct greater_equal : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct less_equal : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};


// clause _lib.logical.operations_, logical operations:
template <class T> struct logical_and : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct logical_or : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct logical_not : unary_function<T,bool> {
  bool operator()(const T& x) const;
};


// clause _lib.negators_, negators:
template <class Predicate>
class unary_negate
  : public unary_function<Predicate::argument_type, bool>
{
public:
  explicit unary_negate(const Predicate& pred);
  bool operator()(const argument_type& x) const;
};






template <class Predicate>
class binary_negate
  : public binary_function<Predicate::first_argument_type,
                           Predicate::second_argument_type, bool>
{
public:
  explicit binary_negate(const Predicate& pred);
  bool operator()(const first_argument_type& x,
                  const second_argument_type& y) const;
};

// operations omitted (cint can't handle template forward decls...)







// clause _lib.binders_, binders:
template <class Operation>
class binder1st
  : public unary_function<Operation::second_argument_type,
                          Operation::result_type>
{
protected:
  Operation op;
  Operation::first_argument_type value;
public:
  binder1st(const Operation& x, const Operation::first_argument_type& y);
  result_type operator()(const argument_type& x) const;
};


// operations omitted (cint can't handle template forward decls...)





template <class Operation>
class binder2nd
  : public unary_function<Operation::first_argument_type,
                          Operation::result_type>
{
protected:
  Operation op;
  Operation::second_argument_type value;
public:
  binder2nd(const Operation& x, const Operation::second_argument_type& y);
  result_type operator()(const argument_type& x) const;
};


// operations omitted (cint can't handle template forward decls...)






// clause _lib.function.pointer.adaptors_, adaptors:
template <class Arg, class Result>
class pointer_to_unary_function
  : public unary_function<Arg, Result>
{
public:
  explicit pointer_to_unary_function(Result (*f)(Arg));
  Result operator()(Arg x) const;
};

// operations omitted (cint can't handle template forward decls...)





template <class Arg1, class Arg2, class Result>
class pointer_to_binary_function
  : public binary_function<Arg1,Arg2,Result>
{
public:
  explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));
  Result operator()(Arg1 x, Arg2 y) const;
};

// operations omitted (cint can't handle template forward decls...)






// omit these for now.
# 230 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/functional"
#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_functional" 2
# 30 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map" 2

//////////////////////////////////////////////////////////////////////////

template<class Key,class T,class Compare=std::less<Key>
        ,class Allocator=std::allocator<pair<const Key, T> > >
# 63 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map"
class map {
 public:
  typedef Key key_type;
  typedef T mapped_type;



  typedef pair<Key,T> value_type;

  typedef Compare key_compare;
  typedef Allocator allocator_type;

  //typedef Key*                                     pointer;
  //typedef const Key*                               const_pointer;
  //typedef Key&                                     reference;
  //typedef const Key&                               const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
# 90 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map"
  class iterator
# 103 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map"
 {
   public:
    iterator() ;
    iterator(const iterator& x) ;

    iterator& operator=(const iterator& x) ;

    value_type& operator*() ;

    value_type* operator->() ;

    iterator& operator++();
    iterator operator++(int a);
    iterator& operator--();
    iterator operator--(int a);

    bool operator==(const iterator& x) ;
    bool operator!=(const iterator& x) ;




  };
# 134 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map"
  class reverse_iterator
# 147 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map"
 {
   public:
    reverse_iterator(const reverse_iterator& x);

    reverse_iterator& operator=(const reverse_iterator& x) ;

    value_type& operator*() ;

    value_type* operator->() ;

    reverse_iterator& operator++();
    reverse_iterator operator++(int a);
    reverse_iterator& operator--();
    reverse_iterator operator--(int a);
   private:
  };

  friend bool operator==(const map::reverse_iterator& x
                        ,const map::reverse_iterator& y) const;
  friend bool operator!=(const map::reverse_iterator& x
                        ,const map::reverse_iterator& y) const;


  typedef const iterator const_iterator;
  typedef const reverse_iterator const_reverse_iterator;

  // _lib.map.cons_ construct/copy/destroy:
  map();






  map(iterator first, iterator last);
  map(reverse_iterator first, reverse_iterator last);

  map(const map& x);
  ~map();
  map& operator=(const map& x);
  // iterators:
  iterator begin();
  iterator end();
  reverse_iterator rbegin();
  reverse_iterator rend();






  // capacity:
  bool empty() const;
  size_type size() const;
  size_type max_size() const;
  // _lib.map.access_ element access:
  T& operator[](const Key& x);
  // modifiers:
  pair<map::iterator, bool> insert(const value_type& x);
  iterator insert(iterator position, const value_type& x);





  void insert(iterator first, iterator last);
  void insert(reverse_iterator first, reverse_iterator last);

  void erase(iterator position);
  size_type erase(const Key& x);
  void erase(iterator first, iterator last);
  void swap(map&);
  void clear();
  // observers:
  //key_compare   key_comp() const;
  //value_compare value_comp() const;
  // _lib.map.ops_ map operations:
  iterator find(const Key& x);
  //const_iterator find(const Key& x) const;
  size_type count(const Key& x) const;
  iterator lower_bound(const Key& x);
  //const_iterator lower_bound(const Key& x) const;
  iterator upper_bound(const Key& x);
  //const_iterator upper_bound(const Key& x) const;





  friend bool operator==(const map& x, const map& y);
  friend bool operator< (const map& x, const map& y);
  friend bool operator!=(const map& x, const map& y);
  friend bool operator> (const map& x, const map& y);
  friend bool operator>=(const map& x, const map& y);
  friend bool operator<=(const map& x, const map& y);
  // specialized algorithms:





#pragma ifndef G__NOALGORITHM
  // Generic algorithm
  friend map::iterator
    search(map::iterator first1,map::iterator last1,
           map::iterator first2,map::iterator last2);
#pragma endif

  // iterator_category resolution
  //friend bidirectional_iterator_tag iterator_category(map::iterator x);

};

//////////////////////////////////////////////////////////////////////////

#pragma endif
# 16 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_map" 2
# 26 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_map"
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_multimap" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

//#pragma include_noerr <pair.dll> 
#pragma include_noerr <multimap.dll>
#pragma include_noerr <multimap2.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/multimap

#pragma ifndef PREC_STL_MULTIMAP
#pragma define PREC_STL_MULTIMAP
#pragma link off global PREC_STL_MULTIMAP;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from ANSI/ISO C++ 1997/Nov draft 
// Got some ideas from Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <utility.dll>


#pragma include_noerr <pair.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/utility

#pragma ifndef PREC_STL_UTILITY
#pragma define PREC_STL_UTILITY
#pragma link off global PREC_STL_UTILITY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

template <class T1, class T2>
struct pair {
  T1 first;
  T2 second;
  pair() : first(T1()), second(T2()) {}
  pair(const T1& a, const T2& b) : first(a), second(b) {}
 private:
  pair& operator=(const pair& x){first=x.first;second=x.second;return *this;}
};

#pragma endif
# 17 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 2
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <memory.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/memory

#pragma ifndef PREC_STL_MEMORY
#pragma define PREC_STL_MEMORY
#pragma link off global PREC_STL_MEMORY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////


template <class _Tp>
class allocator {
  //typedef alloc _Alloc;          // The underlying allocator.
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  typedef typename _Tp* pointer;
  typedef const typename _Tp * const_pointer;




  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() ;
  allocator(const allocator&) ;
  //template <class _Tp1> allocator(const allocator<_Tp1>&) ;
  ~allocator() ;

  pointer address(reference __x) const ;
  const_pointer address(const_reference __x) const ;

  // __n is permitted to be 0.  The C++ standard says nothing about what
  // the return value is when __n == 0.
  _Tp* allocate(size_type __n, const void* = 0) ;

  // __p is not permitted to be a null pointer.
  void deallocate(pointer __p, size_type __n);

  size_type max_size() const ;

  void construct(pointer __p, const _Tp& __val) ;
  void destroy(pointer __p) ;
};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;
  typedef void value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };
};
//////////////////////////////////////////////////////////////////////
# 205 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////

/**********************************************************************
* auto_ptr
**********************************************************************/
template <class X> class auto_ptr {
private:
  X* ptr;
  //template<class Y> struct auto_ptr_ref { };
public:
  typedef X element_type;
  explicit auto_ptr(X* p = 0) : ptr(p) {}
  auto_ptr(auto_ptr& a) {ptr=a.ptr;}

  // this implementation may not be correct
  template <class T> auto_ptr(auto_ptr<T>& a) {ptr=a.release();}
# 229 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  auto_ptr& operator=(auto_ptr& a) {
    if (a.ptr != ptr) {
      delete ptr;
      ptr = a.ptr;
    }
    return(*this);
  }

  // this implementation may not be correct
  template <class T> auto_ptr& operator=(auto_ptr<T>& a) {
    if (a.ptr != ptr) {
       delete ptr;
       ptr = a.release();
    }
    return(*this);
  }

  ~auto_ptr() { delete ptr; }

  X& operator*() const { return *ptr; }
  X* operator->() const { return ptr; }
  X* get() const { return ptr; }
  X* release() { X *old = ptr; ptr = 0; return 0; }
# 262 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  // auto_ptr conversions
  //auto_ptr(auto_ptr_ref<X>& x) { }
  //template<class Y> operator auto_ptr_ref<Y>() { return auto_ptr_ref<Y>(); }
  //template<class Y> operator auto_ptr<Y>() { return auto_ptr<T>(); }
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 2
# 28 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <iterator.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/iterator

#pragma ifndef PREC_STL_ITERATOR
#pragma define PREC_STL_ITERATOR
#pragma link off global PREC_STL_ITERATOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from STL HP implementation 1994
// Imported from STL SGI implementation 1997 
// Imported from ANSI/ISO C++ draft Nov 1997
// Modified by Masaharu Goto
// May need improvement for the latest standard


////////////////////////////////////////////////////////////////////////
// iterator_tag
////////////////////////////////////////////////////////////////////////
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag {};
struct bidirectional_iterator_tag {};
struct random_access_iterator_tag {};

////////////////////////////////////////////////////////////////////////
// iterator template
////////////////////////////////////////////////////////////////////////
template <class T, class Distance> struct input_iterator {};
struct output_iterator {};
template <class T, class Distance> struct forward_iterator {};
template <class T, class Distance> struct bidirectional_iterator {};
template <class T, class Distance> struct random_access_iterator {};

#pragma link off class output_iterator;







////////////////////////////////////////////////////////////////////////
// iterator_category overloaded function
////////////////////////////////////////////////////////////////////////
template <class T, class Distance>
inline input_iterator_tag
iterator_category(const input_iterator<T, Distance>&) {
    return input_iterator_tag();
}

inline output_iterator_tag iterator_category(const output_iterator&) {
    return output_iterator_tag();
}

#pragma link off function iterator_category(const output_iterator&);


template <class T, class Distance>
inline forward_iterator_tag
iterator_category(const forward_iterator<T, Distance>&) {
    return forward_iterator_tag();
}

template <class T, class Distance>
inline bidirectional_iterator_tag
iterator_category(const bidirectional_iterator<T, Distance>&) {
    return bidirectional_iterator_tag();
}

template <class T, class Distance>
inline random_access_iterator_tag
iterator_category(const random_access_iterator<T, Distance>&) {
    return random_access_iterator_tag();
}

template <class T>
inline random_access_iterator_tag
iterator_category(const T*) {
    return random_access_iterator_tag();
}


// iterator_traits, iterator and reverse_iterator template may not be
// needed for precompiled library interface 

////////////////////////////////////////////////////////////////////////
// iterator_traits
////////////////////////////////////////////////////////////////////////

template <class Iterator>
struct iterator_traits {
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type value_type;
  typedef typename Iterator::difference_type difference_type;
  typedef typename Iterator::pointer pointer;
  typedef typename Iterator::reference reference;
};

// template partial specialization, implement in cint5.15.14 1587
template <class T>
struct iterator_traits<T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
};

// incomplete implementation in cint5.15.14 1587, need some fix
// iterator_traits<const int*> is changed as iterator_traits<const int* const>
// or something, but cint5.15.14 can not handle this well
template <class T>
struct iterator_traits<const T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef const T* pointer;
  typedef const T& reference;
};

////////////////////////////////////////////////////////////////////////
// iterator
////////////////////////////////////////////////////////////////////////
template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator {
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
  typedef Category iterator_category;
};


////////////////////////////////////////////////////////////////////////
// reverse_iterator
////////////////////////////////////////////////////////////////////////






template <class Iterator>
class reverse_iterator
# 166 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
{




 public:
# 181 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
   typedef Iterator::pointer pointer;
   typedef Iterator::reference reference;
   typedef ptrdiff_t difference_type;


   reverse_iterator();
   //reverse_iterator(Iterator x);



   Iterator base() const; // explicit
   reference operator*() const;
   pointer operator->() const;
   reverse_iterator& operator++();
   reverse_iterator operator++(int);
   reverse_iterator& operator--();
   reverse_iterator operator--(int);
   reverse_iterator operator+ (difference_type n) const;
   reverse_iterator& operator+=(difference_type n);
   reverse_iterator operator- (difference_type n) const;
   reverse_iterator& operator-=(difference_type n);
   reference operator[](difference_type n) const;
};
# 932 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
// for g++ 3.1,3.2
namespace __gnu_cxx
{
  // This iterator adapter is 'normal' in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                    difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparaison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  // _GLIBCPP_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
     const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
} // namespace __gnu_cxx







#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 2
# 29 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_functional" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <functional.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/functional" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/functional

#pragma ifndef PREC_STL_FUNCTIONAL
#pragma define PREC_STL_FUNCTIONAL
#pragma link off global PREC_STL_FUNCTIONAL;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab

// clause _lib.base_, base:
template <class Arg, class Result>
struct unary_function
{
  typedef Arg argument_type;
  typedef Result result_type;
};


template <class Arg1, class Arg2, class Result>
struct binary_function
{
  typedef Arg1 first_argument_type;
  typedef Arg2 second_argument_type;
  typedef Result result_type;
};


// clause _lib.arithmetic.operations_, arithmetic operations:
template <class T> struct plus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct minus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct multiplies : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct divides : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};

template <class T> struct modulus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};

template <class T> struct negate : unary_function<T,T> {
  T operator()(const T& x) const;
};


// clause _lib.comparisons_, comparisons:
template <class T> struct equal_to : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct not_equal_to : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct greater : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct less : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct greater_equal : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct less_equal : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};


// clause _lib.logical.operations_, logical operations:
template <class T> struct logical_and : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct logical_or : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct logical_not : unary_function<T,bool> {
  bool operator()(const T& x) const;
};


// clause _lib.negators_, negators:
template <class Predicate>
class unary_negate
  : public unary_function<Predicate::argument_type, bool>
{
public:
  explicit unary_negate(const Predicate& pred);
  bool operator()(const argument_type& x) const;
};






template <class Predicate>
class binary_negate
  : public binary_function<Predicate::first_argument_type,
                           Predicate::second_argument_type, bool>
{
public:
  explicit binary_negate(const Predicate& pred);
  bool operator()(const first_argument_type& x,
                  const second_argument_type& y) const;
};

// operations omitted (cint can't handle template forward decls...)







// clause _lib.binders_, binders:
template <class Operation>
class binder1st
  : public unary_function<Operation::second_argument_type,
                          Operation::result_type>
{
protected:
  Operation op;
  Operation::first_argument_type value;
public:
  binder1st(const Operation& x, const Operation::first_argument_type& y);
  result_type operator()(const argument_type& x) const;
};


// operations omitted (cint can't handle template forward decls...)





template <class Operation>
class binder2nd
  : public unary_function<Operation::first_argument_type,
                          Operation::result_type>
{
protected:
  Operation op;
  Operation::second_argument_type value;
public:
  binder2nd(const Operation& x, const Operation::second_argument_type& y);
  result_type operator()(const argument_type& x) const;
};


// operations omitted (cint can't handle template forward decls...)






// clause _lib.function.pointer.adaptors_, adaptors:
template <class Arg, class Result>
class pointer_to_unary_function
  : public unary_function<Arg, Result>
{
public:
  explicit pointer_to_unary_function(Result (*f)(Arg));
  Result operator()(Arg x) const;
};

// operations omitted (cint can't handle template forward decls...)





template <class Arg1, class Arg2, class Result>
class pointer_to_binary_function
  : public binary_function<Arg1,Arg2,Result>
{
public:
  explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));
  Result operator()(Arg1 x, Arg2 y) const;
};

// operations omitted (cint can't handle template forward decls...)






// omit these for now.
# 230 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/functional"
#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_functional" 2
# 30 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap" 2

//////////////////////////////////////////////////////////////////////////

// This does not work yet. Don't know why.
template<class Key,class T,class Compare=std::less<Key>
        ,class Allocator=std::allocator<pair<const Key,T> > >
# 63 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap"
class multimap {
 public:
  typedef Key key_type;
  typedef T mapped_type;
  typedef pair<Key,T> value_type;
  //typedef pair<const Key,T>                         value_type;
  typedef Compare key_compare;
  typedef Allocator allocator_type;

  //typedef Key*                                     pointer;
  //typedef const Key*                               const_pointer;
  //typedef Key&                                     reference;
  //typedef const Key&                               const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
# 87 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap"
  class iterator
# 100 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap"
 {
   public:
    iterator() ;
    iterator(const iterator& x) ;

    iterator& operator=(const iterator& x) ;

    value_type& operator*() ;

    value_type* operator->() ;

    iterator& operator++();
    iterator operator++(int a);
    iterator& operator--();
    iterator operator--(int a);

    bool operator==(const iterator& x) ;
    bool operator!=(const iterator& x) ;




  };
# 131 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap"
  class reverse_iterator
# 144 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap"
 {
   public:
    reverse_iterator(const reverse_iterator& x);

    reverse_iterator& operator=(const reverse_iterator& x) ;

    value_type& operator*() ;

    value_type* operator->() ;

    reverse_iterator& operator++();
    reverse_iterator operator++(int a);
    reverse_iterator& operator--();
    reverse_iterator operator--(int a);
   private:
  };

  friend bool operator==(const multimap::reverse_iterator& x
                        ,const multimap::reverse_iterator& y) const;
  friend bool operator!=(const multimap::reverse_iterator& x
                        ,const multimap::reverse_iterator& y) const;


  typedef const iterator const_iterator;
  typedef const reverse_iterator const_reverse_iterator;

  // _lib.multimap.cons_ construct/copy/destroy:
  multimap();






  multimap(iterator first, iterator last);
  multimap(reverse_iterator first, reverse_iterator last);

  multimap(const multimap& x);
  ~multimap();
  multimap& operator=(const multimap& x);
  // iterators:
  iterator begin();
  iterator end();
  reverse_iterator rbegin();
  reverse_iterator rend();






  // capacity:
  bool empty() const;
  size_type size() const;
  size_type max_size() const;
  // _lib.multimap.access_ element access:
  //T& operator[](const Key& x);
  // modifiers:
  iterator insert(const value_type& x);
  iterator insert(iterator position, const value_type& x);





  void insert(iterator first, iterator last);
  void insert(reverse_iterator first, reverse_iterator last);

  void erase(iterator position);
  size_type erase(const Key& x);
  void erase(iterator first, iterator last);
  void swap(multimap&);
  void clear();
  // observers:
  //key_compare   key_comp() const;
  //value_compare value_comp() const;
  // _lib.multimap.ops_ multimap operations:
  iterator find(const Key& x);
  //const_iterator find(const Key& x) const;
  size_type count(const Key& x) const;
  iterator lower_bound(const Key& x);
  //const_iterator lower_bound(const Key& x) const;
  iterator upper_bound(const Key& x);
  //const_iterator upper_bound(const Key& x) const;





  friend bool operator==(const multimap& x, const multimap& y);
  friend bool operator< (const multimap& x, const multimap& y);
  friend bool operator!=(const multimap& x, const multimap& y);
  friend bool operator> (const multimap& x, const multimap& y);
  friend bool operator>=(const multimap& x, const multimap& y);
  friend bool operator<=(const multimap& x, const multimap& y);
  // specialized algorithms:





#pragma ifndef G__NOALGORITHM
  // Generic algorithm
  friend multimap::iterator
    search(multimap::iterator first1,multimap::iterator last1,
           multimap::iterator first2,multimap::iterator last2);
#pragma endif


  // Generic algorithm
  //friend void reverse(multimap::iterator first,multimap::iterator last);
  //friend void reverse(multimap::reverse_iterator first,multimap::reverse_itetator last);

  // iterator_category resolution
  //friend bidirectional_iterator_tag iterator_category(multimap::iterator x);

};

//////////////////////////////////////////////////////////////////////////

#pragma endif
# 16 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_multimap" 2
# 26 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_map" 2
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/map" 2
}
# 29 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsArg.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/set" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_set" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <set.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/set" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/set

#pragma ifndef PREC_STL_SET
#pragma define PREC_STL_SET
#pragma link off global PREC_STL_SET;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from ANSI/ISO C++ 1997/Nov draft
// Got some ideas from Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <utility.dll>


#pragma include_noerr <pair.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/utility

#pragma ifndef PREC_STL_UTILITY
#pragma define PREC_STL_UTILITY
#pragma link off global PREC_STL_UTILITY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

template <class T1, class T2>
struct pair {
  T1 first;
  T2 second;
  pair() : first(T1()), second(T2()) {}
  pair(const T1& a, const T2& b) : first(a), second(b) {}
 private:
  pair& operator=(const pair& x){first=x.first;second=x.second;return *this;}
};

#pragma endif
# 17 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 2
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/set" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <memory.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/memory

#pragma ifndef PREC_STL_MEMORY
#pragma define PREC_STL_MEMORY
#pragma link off global PREC_STL_MEMORY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////


template <class _Tp>
class allocator {
  //typedef alloc _Alloc;          // The underlying allocator.
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  typedef typename _Tp* pointer;
  typedef const typename _Tp * const_pointer;




  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() ;
  allocator(const allocator&) ;
  //template <class _Tp1> allocator(const allocator<_Tp1>&) ;
  ~allocator() ;

  pointer address(reference __x) const ;
  const_pointer address(const_reference __x) const ;

  // __n is permitted to be 0.  The C++ standard says nothing about what
  // the return value is when __n == 0.
  _Tp* allocate(size_type __n, const void* = 0) ;

  // __p is not permitted to be a null pointer.
  void deallocate(pointer __p, size_type __n);

  size_type max_size() const ;

  void construct(pointer __p, const _Tp& __val) ;
  void destroy(pointer __p) ;
};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;
  typedef void value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };
};
//////////////////////////////////////////////////////////////////////
# 205 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////

/**********************************************************************
* auto_ptr
**********************************************************************/
template <class X> class auto_ptr {
private:
  X* ptr;
  //template<class Y> struct auto_ptr_ref { };
public:
  typedef X element_type;
  explicit auto_ptr(X* p = 0) : ptr(p) {}
  auto_ptr(auto_ptr& a) {ptr=a.ptr;}

  // this implementation may not be correct
  template <class T> auto_ptr(auto_ptr<T>& a) {ptr=a.release();}
# 229 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  auto_ptr& operator=(auto_ptr& a) {
    if (a.ptr != ptr) {
      delete ptr;
      ptr = a.ptr;
    }
    return(*this);
  }

  // this implementation may not be correct
  template <class T> auto_ptr& operator=(auto_ptr<T>& a) {
    if (a.ptr != ptr) {
       delete ptr;
       ptr = a.release();
    }
    return(*this);
  }

  ~auto_ptr() { delete ptr; }

  X& operator*() const { return *ptr; }
  X* operator->() const { return ptr; }
  X* get() const { return ptr; }
  X* release() { X *old = ptr; ptr = 0; return 0; }
# 262 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  // auto_ptr conversions
  //auto_ptr(auto_ptr_ref<X>& x) { }
  //template<class Y> operator auto_ptr_ref<Y>() { return auto_ptr_ref<Y>(); }
  //template<class Y> operator auto_ptr<Y>() { return auto_ptr<T>(); }
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 2
# 28 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/set" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <iterator.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/iterator

#pragma ifndef PREC_STL_ITERATOR
#pragma define PREC_STL_ITERATOR
#pragma link off global PREC_STL_ITERATOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from STL HP implementation 1994
// Imported from STL SGI implementation 1997 
// Imported from ANSI/ISO C++ draft Nov 1997
// Modified by Masaharu Goto
// May need improvement for the latest standard


////////////////////////////////////////////////////////////////////////
// iterator_tag
////////////////////////////////////////////////////////////////////////
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag {};
struct bidirectional_iterator_tag {};
struct random_access_iterator_tag {};

////////////////////////////////////////////////////////////////////////
// iterator template
////////////////////////////////////////////////////////////////////////
template <class T, class Distance> struct input_iterator {};
struct output_iterator {};
template <class T, class Distance> struct forward_iterator {};
template <class T, class Distance> struct bidirectional_iterator {};
template <class T, class Distance> struct random_access_iterator {};

#pragma link off class output_iterator;







////////////////////////////////////////////////////////////////////////
// iterator_category overloaded function
////////////////////////////////////////////////////////////////////////
template <class T, class Distance>
inline input_iterator_tag
iterator_category(const input_iterator<T, Distance>&) {
    return input_iterator_tag();
}

inline output_iterator_tag iterator_category(const output_iterator&) {
    return output_iterator_tag();
}

#pragma link off function iterator_category(const output_iterator&);


template <class T, class Distance>
inline forward_iterator_tag
iterator_category(const forward_iterator<T, Distance>&) {
    return forward_iterator_tag();
}

template <class T, class Distance>
inline bidirectional_iterator_tag
iterator_category(const bidirectional_iterator<T, Distance>&) {
    return bidirectional_iterator_tag();
}

template <class T, class Distance>
inline random_access_iterator_tag
iterator_category(const random_access_iterator<T, Distance>&) {
    return random_access_iterator_tag();
}

template <class T>
inline random_access_iterator_tag
iterator_category(const T*) {
    return random_access_iterator_tag();
}


// iterator_traits, iterator and reverse_iterator template may not be
// needed for precompiled library interface 

////////////////////////////////////////////////////////////////////////
// iterator_traits
////////////////////////////////////////////////////////////////////////

template <class Iterator>
struct iterator_traits {
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type value_type;
  typedef typename Iterator::difference_type difference_type;
  typedef typename Iterator::pointer pointer;
  typedef typename Iterator::reference reference;
};

// template partial specialization, implement in cint5.15.14 1587
template <class T>
struct iterator_traits<T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
};

// incomplete implementation in cint5.15.14 1587, need some fix
// iterator_traits<const int*> is changed as iterator_traits<const int* const>
// or something, but cint5.15.14 can not handle this well
template <class T>
struct iterator_traits<const T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef const T* pointer;
  typedef const T& reference;
};

////////////////////////////////////////////////////////////////////////
// iterator
////////////////////////////////////////////////////////////////////////
template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator {
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
  typedef Category iterator_category;
};


////////////////////////////////////////////////////////////////////////
// reverse_iterator
////////////////////////////////////////////////////////////////////////






template <class Iterator>
class reverse_iterator
# 166 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
{




 public:
# 181 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
   typedef Iterator::pointer pointer;
   typedef Iterator::reference reference;
   typedef ptrdiff_t difference_type;


   reverse_iterator();
   //reverse_iterator(Iterator x);



   Iterator base() const; // explicit
   reference operator*() const;
   pointer operator->() const;
   reverse_iterator& operator++();
   reverse_iterator operator++(int);
   reverse_iterator& operator--();
   reverse_iterator operator--(int);
   reverse_iterator operator+ (difference_type n) const;
   reverse_iterator& operator+=(difference_type n);
   reverse_iterator operator- (difference_type n) const;
   reverse_iterator& operator-=(difference_type n);
   reference operator[](difference_type n) const;
};
# 932 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
// for g++ 3.1,3.2
namespace __gnu_cxx
{
  // This iterator adapter is 'normal' in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                    difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparaison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  // _GLIBCPP_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
     const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
} // namespace __gnu_cxx







#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 2
# 29 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/set" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_functional" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <functional.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/functional" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/functional

#pragma ifndef PREC_STL_FUNCTIONAL
#pragma define PREC_STL_FUNCTIONAL
#pragma link off global PREC_STL_FUNCTIONAL;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab

// clause _lib.base_, base:
template <class Arg, class Result>
struct unary_function
{
  typedef Arg argument_type;
  typedef Result result_type;
};


template <class Arg1, class Arg2, class Result>
struct binary_function
{
  typedef Arg1 first_argument_type;
  typedef Arg2 second_argument_type;
  typedef Result result_type;
};


// clause _lib.arithmetic.operations_, arithmetic operations:
template <class T> struct plus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct minus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct multiplies : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct divides : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};

template <class T> struct modulus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};

template <class T> struct negate : unary_function<T,T> {
  T operator()(const T& x) const;
};


// clause _lib.comparisons_, comparisons:
template <class T> struct equal_to : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct not_equal_to : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct greater : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct less : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct greater_equal : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct less_equal : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};


// clause _lib.logical.operations_, logical operations:
template <class T> struct logical_and : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct logical_or : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct logical_not : unary_function<T,bool> {
  bool operator()(const T& x) const;
};


// clause _lib.negators_, negators:
template <class Predicate>
class unary_negate
  : public unary_function<Predicate::argument_type, bool>
{
public:
  explicit unary_negate(const Predicate& pred);
  bool operator()(const argument_type& x) const;
};






template <class Predicate>
class binary_negate
  : public binary_function<Predicate::first_argument_type,
                           Predicate::second_argument_type, bool>
{
public:
  explicit binary_negate(const Predicate& pred);
  bool operator()(const first_argument_type& x,
                  const second_argument_type& y) const;
};

// operations omitted (cint can't handle template forward decls...)







// clause _lib.binders_, binders:
template <class Operation>
class binder1st
  : public unary_function<Operation::second_argument_type,
                          Operation::result_type>
{
protected:
  Operation op;
  Operation::first_argument_type value;
public:
  binder1st(const Operation& x, const Operation::first_argument_type& y);
  result_type operator()(const argument_type& x) const;
};


// operations omitted (cint can't handle template forward decls...)





template <class Operation>
class binder2nd
  : public unary_function<Operation::first_argument_type,
                          Operation::result_type>
{
protected:
  Operation op;
  Operation::second_argument_type value;
public:
  binder2nd(const Operation& x, const Operation::second_argument_type& y);
  result_type operator()(const argument_type& x) const;
};


// operations omitted (cint can't handle template forward decls...)






// clause _lib.function.pointer.adaptors_, adaptors:
template <class Arg, class Result>
class pointer_to_unary_function
  : public unary_function<Arg, Result>
{
public:
  explicit pointer_to_unary_function(Result (*f)(Arg));
  Result operator()(Arg x) const;
};

// operations omitted (cint can't handle template forward decls...)





template <class Arg1, class Arg2, class Result>
class pointer_to_binary_function
  : public binary_function<Arg1,Arg2,Result>
{
public:
  explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));
  Result operator()(Arg1 x, Arg2 y) const;
};

// operations omitted (cint can't handle template forward decls...)






// omit these for now.
# 230 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/functional"
#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_functional" 2
# 30 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/set" 2


template<class Key,class Compare=std::less<Key>
        ,class Allocator=std::allocator<Key> >
# 49 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/set"
class set {
 public:
  // types:
  typedef Key key_type;
  typedef Key value_type;
  typedef Compare key_compare;
  typedef Compare value_compare;
  typedef Allocator allocator_type;

  typedef Key* pointer;
  typedef const Key* const_pointer;
  typedef Key& reference;
  typedef const Key& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
# 73 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/set"
  class iterator
# 89 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/set"
 {
   public:
    iterator() ;
    iterator(const iterator& x) ;

    iterator& operator=(const iterator& x) ;


    value_type operator*() const;




    value_type* operator->() const;

    iterator& operator++();
    iterator operator++(int a);
    iterator& operator--();
    iterator operator--(int a);

    bool operator==(const iterator& x) ;
    bool operator!=(const iterator& x) ;




  };
# 124 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/set"
  class reverse_iterator
# 140 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/set"
 {
   public:
    reverse_iterator(const reverse_iterator& x);

    reverse_iterator& operator=(const reverse_iterator& x) ;


    value_type operator*() const;




    value_type* operator->() const;

    reverse_iterator& operator++();
    reverse_iterator operator++(int a);
    reverse_iterator& operator--();
    reverse_iterator operator--(int a);
   private:
  };
  friend bool operator==(const set::reverse_iterator& x
                        ,const set::reverse_iterator& y) const;
  friend bool operator!=(const set::reverse_iterator& x
                        ,const set::reverse_iterator& y) const;

  typedef const iterator const_iterator;
  typedef const reverse_iterator const_reverse_iterator;

  // _lib.set.cons_ construct/copy/destroy:
  //set(const Compare& comp=Compare(), const Allocator&=Allocator());
  set();





  set(const set& x);
  ~set();
  set& operator= (const set& x);
  //allocator_type get_allocator() const;
  // iterators:
  iterator begin();
  iterator end();
  reverse_iterator rbegin();
  reverse_iterator rend();







  // capacity:
  bool empty() const;
  size_type size() const;
  size_type max_size() const;
  // modifiers:
  pair<set::iterator,bool> insert(const Key& x);
  iterator insert(iterator position, const Key& x);




  void erase(iterator position);



  void erase(iterator first, iterator last);
  void swap(set<Key,Compare,Allocator>&);
  void clear();
  // observers:
  //key_compare   key_comp() const;
  //value_compare value_comp() const;
  // set operations:






  iterator find(const Key& x) const;

  size_type count(const Key& x) const;
# 232 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/set"
  iterator lower_bound(const Key& x) const;
  iterator upper_bound(const Key& x) const;

  //pair<iterator,iterator> equal_range(const Key& x) const;

  friend bool operator==(const set& x, const set& y);
  friend bool operator< (const set& x, const set& y);
  friend bool operator!=(const set& x, const set& y);
  friend bool operator> (const set& x, const set& y);
  friend bool operator>=(const set& x, const set& y);
  friend bool operator<=(const set& x, const set& y);
  // specialized algorithms:
  //friend void swap(set& x, set& y);


#pragma ifndef G__NOALGORITHM
  // Generic algorithm


  friend set::iterator
    find(set::iterator first,set::iterator last,const Key& value);
  friend set::iterator
    search(set::iterator first1,set::iterator last1,
           set::iterator first2,set::iterator last2);
# 276 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/set"
#pragma endif

};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_set" 2




# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_multiset" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <multiset.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multiset" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/multiset

#pragma ifndef PREC_STL_MULTISET
#pragma define PREC_STL_MULTISET
#pragma link off global PREC_STL_MULTISET;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from ANSI/ISO C++ 1997/Nov draft
// Got some ideas from Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <utility.dll>


#pragma include_noerr <pair.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/utility

#pragma ifndef PREC_STL_UTILITY
#pragma define PREC_STL_UTILITY
#pragma link off global PREC_STL_UTILITY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

template <class T1, class T2>
struct pair {
  T1 first;
  T2 second;
  pair() : first(T1()), second(T2()) {}
  pair(const T1& a, const T2& b) : first(a), second(b) {}
 private:
  pair& operator=(const pair& x){first=x.first;second=x.second;return *this;}
};

#pragma endif
# 17 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 2
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multiset" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <memory.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/memory

#pragma ifndef PREC_STL_MEMORY
#pragma define PREC_STL_MEMORY
#pragma link off global PREC_STL_MEMORY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////


template <class _Tp>
class allocator {
  //typedef alloc _Alloc;          // The underlying allocator.
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  typedef typename _Tp* pointer;
  typedef const typename _Tp * const_pointer;




  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() ;
  allocator(const allocator&) ;
  //template <class _Tp1> allocator(const allocator<_Tp1>&) ;
  ~allocator() ;

  pointer address(reference __x) const ;
  const_pointer address(const_reference __x) const ;

  // __n is permitted to be 0.  The C++ standard says nothing about what
  // the return value is when __n == 0.
  _Tp* allocate(size_type __n, const void* = 0) ;

  // __p is not permitted to be a null pointer.
  void deallocate(pointer __p, size_type __n);

  size_type max_size() const ;

  void construct(pointer __p, const _Tp& __val) ;
  void destroy(pointer __p) ;
};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;
  typedef void value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };
};
//////////////////////////////////////////////////////////////////////
# 205 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////

/**********************************************************************
* auto_ptr
**********************************************************************/
template <class X> class auto_ptr {
private:
  X* ptr;
  //template<class Y> struct auto_ptr_ref { };
public:
  typedef X element_type;
  explicit auto_ptr(X* p = 0) : ptr(p) {}
  auto_ptr(auto_ptr& a) {ptr=a.ptr;}

  // this implementation may not be correct
  template <class T> auto_ptr(auto_ptr<T>& a) {ptr=a.release();}
# 229 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  auto_ptr& operator=(auto_ptr& a) {
    if (a.ptr != ptr) {
      delete ptr;
      ptr = a.ptr;
    }
    return(*this);
  }

  // this implementation may not be correct
  template <class T> auto_ptr& operator=(auto_ptr<T>& a) {
    if (a.ptr != ptr) {
       delete ptr;
       ptr = a.release();
    }
    return(*this);
  }

  ~auto_ptr() { delete ptr; }

  X& operator*() const { return *ptr; }
  X* operator->() const { return ptr; }
  X* get() const { return ptr; }
  X* release() { X *old = ptr; ptr = 0; return 0; }
# 262 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  // auto_ptr conversions
  //auto_ptr(auto_ptr_ref<X>& x) { }
  //template<class Y> operator auto_ptr_ref<Y>() { return auto_ptr_ref<Y>(); }
  //template<class Y> operator auto_ptr<Y>() { return auto_ptr<T>(); }
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 2
# 28 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multiset" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <iterator.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/iterator

#pragma ifndef PREC_STL_ITERATOR
#pragma define PREC_STL_ITERATOR
#pragma link off global PREC_STL_ITERATOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from STL HP implementation 1994
// Imported from STL SGI implementation 1997 
// Imported from ANSI/ISO C++ draft Nov 1997
// Modified by Masaharu Goto
// May need improvement for the latest standard


////////////////////////////////////////////////////////////////////////
// iterator_tag
////////////////////////////////////////////////////////////////////////
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag {};
struct bidirectional_iterator_tag {};
struct random_access_iterator_tag {};

////////////////////////////////////////////////////////////////////////
// iterator template
////////////////////////////////////////////////////////////////////////
template <class T, class Distance> struct input_iterator {};
struct output_iterator {};
template <class T, class Distance> struct forward_iterator {};
template <class T, class Distance> struct bidirectional_iterator {};
template <class T, class Distance> struct random_access_iterator {};

#pragma link off class output_iterator;







////////////////////////////////////////////////////////////////////////
// iterator_category overloaded function
////////////////////////////////////////////////////////////////////////
template <class T, class Distance>
inline input_iterator_tag
iterator_category(const input_iterator<T, Distance>&) {
    return input_iterator_tag();
}

inline output_iterator_tag iterator_category(const output_iterator&) {
    return output_iterator_tag();
}

#pragma link off function iterator_category(const output_iterator&);


template <class T, class Distance>
inline forward_iterator_tag
iterator_category(const forward_iterator<T, Distance>&) {
    return forward_iterator_tag();
}

template <class T, class Distance>
inline bidirectional_iterator_tag
iterator_category(const bidirectional_iterator<T, Distance>&) {
    return bidirectional_iterator_tag();
}

template <class T, class Distance>
inline random_access_iterator_tag
iterator_category(const random_access_iterator<T, Distance>&) {
    return random_access_iterator_tag();
}

template <class T>
inline random_access_iterator_tag
iterator_category(const T*) {
    return random_access_iterator_tag();
}


// iterator_traits, iterator and reverse_iterator template may not be
// needed for precompiled library interface 

////////////////////////////////////////////////////////////////////////
// iterator_traits
////////////////////////////////////////////////////////////////////////

template <class Iterator>
struct iterator_traits {
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type value_type;
  typedef typename Iterator::difference_type difference_type;
  typedef typename Iterator::pointer pointer;
  typedef typename Iterator::reference reference;
};

// template partial specialization, implement in cint5.15.14 1587
template <class T>
struct iterator_traits<T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
};

// incomplete implementation in cint5.15.14 1587, need some fix
// iterator_traits<const int*> is changed as iterator_traits<const int* const>
// or something, but cint5.15.14 can not handle this well
template <class T>
struct iterator_traits<const T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef const T* pointer;
  typedef const T& reference;
};

////////////////////////////////////////////////////////////////////////
// iterator
////////////////////////////////////////////////////////////////////////
template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator {
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
  typedef Category iterator_category;
};


////////////////////////////////////////////////////////////////////////
// reverse_iterator
////////////////////////////////////////////////////////////////////////






template <class Iterator>
class reverse_iterator
# 166 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
{




 public:
# 181 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
   typedef Iterator::pointer pointer;
   typedef Iterator::reference reference;
   typedef ptrdiff_t difference_type;


   reverse_iterator();
   //reverse_iterator(Iterator x);



   Iterator base() const; // explicit
   reference operator*() const;
   pointer operator->() const;
   reverse_iterator& operator++();
   reverse_iterator operator++(int);
   reverse_iterator& operator--();
   reverse_iterator operator--(int);
   reverse_iterator operator+ (difference_type n) const;
   reverse_iterator& operator+=(difference_type n);
   reverse_iterator operator- (difference_type n) const;
   reverse_iterator& operator-=(difference_type n);
   reference operator[](difference_type n) const;
};
# 932 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
// for g++ 3.1,3.2
namespace __gnu_cxx
{
  // This iterator adapter is 'normal' in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                    difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparaison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  // _GLIBCPP_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
     const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
} // namespace __gnu_cxx







#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 2
# 29 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multiset" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_functional" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <functional.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/functional" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/functional

#pragma ifndef PREC_STL_FUNCTIONAL
#pragma define PREC_STL_FUNCTIONAL
#pragma link off global PREC_STL_FUNCTIONAL;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab

// clause _lib.base_, base:
template <class Arg, class Result>
struct unary_function
{
  typedef Arg argument_type;
  typedef Result result_type;
};


template <class Arg1, class Arg2, class Result>
struct binary_function
{
  typedef Arg1 first_argument_type;
  typedef Arg2 second_argument_type;
  typedef Result result_type;
};


// clause _lib.arithmetic.operations_, arithmetic operations:
template <class T> struct plus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct minus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct multiplies : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct divides : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};

template <class T> struct modulus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};

template <class T> struct negate : unary_function<T,T> {
  T operator()(const T& x) const;
};


// clause _lib.comparisons_, comparisons:
template <class T> struct equal_to : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct not_equal_to : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct greater : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct less : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct greater_equal : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct less_equal : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};


// clause _lib.logical.operations_, logical operations:
template <class T> struct logical_and : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct logical_or : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct logical_not : unary_function<T,bool> {
  bool operator()(const T& x) const;
};


// clause _lib.negators_, negators:
template <class Predicate>
class unary_negate
  : public unary_function<Predicate::argument_type, bool>
{
public:
  explicit unary_negate(const Predicate& pred);
  bool operator()(const argument_type& x) const;
};






template <class Predicate>
class binary_negate
  : public binary_function<Predicate::first_argument_type,
                           Predicate::second_argument_type, bool>
{
public:
  explicit binary_negate(const Predicate& pred);
  bool operator()(const first_argument_type& x,
                  const second_argument_type& y) const;
};

// operations omitted (cint can't handle template forward decls...)







// clause _lib.binders_, binders:
template <class Operation>
class binder1st
  : public unary_function<Operation::second_argument_type,
                          Operation::result_type>
{
protected:
  Operation op;
  Operation::first_argument_type value;
public:
  binder1st(const Operation& x, const Operation::first_argument_type& y);
  result_type operator()(const argument_type& x) const;
};


// operations omitted (cint can't handle template forward decls...)





template <class Operation>
class binder2nd
  : public unary_function<Operation::first_argument_type,
                          Operation::result_type>
{
protected:
  Operation op;
  Operation::second_argument_type value;
public:
  binder2nd(const Operation& x, const Operation::second_argument_type& y);
  result_type operator()(const argument_type& x) const;
};


// operations omitted (cint can't handle template forward decls...)






// clause _lib.function.pointer.adaptors_, adaptors:
template <class Arg, class Result>
class pointer_to_unary_function
  : public unary_function<Arg, Result>
{
public:
  explicit pointer_to_unary_function(Result (*f)(Arg));
  Result operator()(Arg x) const;
};

// operations omitted (cint can't handle template forward decls...)





template <class Arg1, class Arg2, class Result>
class pointer_to_binary_function
  : public binary_function<Arg1,Arg2,Result>
{
public:
  explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));
  Result operator()(Arg1 x, Arg2 y) const;
};

// operations omitted (cint can't handle template forward decls...)






// omit these for now.
# 230 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/functional"
#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_functional" 2
# 30 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multiset" 2


template<class Key,class Compare=std::less<Key>
        ,class Allocator=std::allocator<Key> >
# 49 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multiset"
class multiset {
 public:
  // types:
  typedef Key key_type;
  typedef Key value_type;
  typedef Compare key_compare;
  typedef Compare value_compare;
  typedef Allocator allocator_type;

  typedef Key* pointer;
  typedef const Key* const_pointer;
  typedef Key& reference;
  typedef const Key& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
# 73 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multiset"
  class iterator
# 89 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multiset"
 {
   public:
    iterator() ;
    iterator(const iterator& x) ;

    iterator& operator=(const iterator& x) ;


    value_type operator*() const;




    value_type* operator->() const;

    iterator& operator++();
    iterator operator++(int a);
    iterator& operator--();
    iterator operator--(int a);

    bool operator==(const iterator& x) ;
    bool operator!=(const iterator& x) ;




  };
# 124 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multiset"
  class reverse_iterator
# 140 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multiset"
 {
   public:
    reverse_iterator(const reverse_iterator& x);

    reverse_iterator& operator=(const reverse_iterator& x) ;


    value_type operator*() const;




    value_type* operator->() const;

    reverse_iterator& operator++();
    reverse_iterator operator++(int a);
    reverse_iterator& operator--();
    reverse_iterator operator--(int a);
   private:
  };
  friend bool operator==(const multiset::reverse_iterator& x
                        ,const multiset::reverse_iterator& y) const;
  friend bool operator!=(const multiset::reverse_iterator& x
                        ,const multiset::reverse_iterator& y) const;

  typedef const iterator const_iterator;
  typedef const reverse_iterator const_reverse_iterator;

  // _lib.multiset.cons_ construct/copy/destroy:
  //multiset(const Compare& comp=Compare(), const Allocator&=Allocator());
  multiset();





  multiset(const multiset& x);
  ~multiset();
  multiset& operator= (const multiset& x);
  //allocator_type get_allocator() const;
  // iterators:
  iterator begin();
  iterator end();
  reverse_iterator rbegin();
  reverse_iterator rend();







  // capacity:
  bool empty() const;
  size_type size() const;
  size_type max_size() const;
  // modifiers:
  iterator insert(const Key& x);
  iterator insert(iterator position, const Key& x);




  void erase(iterator position);



  void erase(iterator first, iterator last);
  void swap(multiset<Key,Compare,Allocator>&);
  void clear();
  // observers:
  //key_compare   key_comp() const;
  //value_compare value_comp() const;
  // multiset operations:






  iterator find(const Key& x) const;

  size_type count(const Key& x) const;
# 232 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multiset"
  iterator lower_bound(const Key& x) const;
  iterator upper_bound(const Key& x) const;

  //pair<iterator,iterator> equal_range(const Key& x) const;

  friend bool operator==(const multiset& x, const multiset& y);
  friend bool operator< (const multiset& x, const multiset& y);
  friend bool operator!=(const multiset& x, const multiset& y);
  friend bool operator> (const multiset& x, const multiset& y);
  friend bool operator>=(const multiset& x, const multiset& y);
  friend bool operator<=(const multiset& x, const multiset& y);
  // specialized algorithms:
  //friend void swap(multiset& x, multiset& y);

#pragma ifndef G__NOALGORITHM
  // Generic algorithm


  friend multiset::iterator
    find(multiset::iterator first,multiset::iterator last,const Key& value);
  friend multiset::iterator
    search(multiset::iterator first1,multiset::iterator last1,
           multiset::iterator first2,multiset::iterator last2);
# 285 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multiset"
#pragma endif

};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_multiset" 2
# 19 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_set" 2
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/set" 2
}
# 30 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsArg.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/deque" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_deque" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <deque.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/deque" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/deque

#pragma ifndef PREC_STL_DEQUE
#pragma define PREC_STL_DEQUE
#pragma link off global PREC_STL_DEQUE;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from ANSI/ISO C++ 1997/Nov draft 
// Got some ideas from Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <iterator.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/iterator

#pragma ifndef PREC_STL_ITERATOR
#pragma define PREC_STL_ITERATOR
#pragma link off global PREC_STL_ITERATOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from STL HP implementation 1994
// Imported from STL SGI implementation 1997 
// Imported from ANSI/ISO C++ draft Nov 1997
// Modified by Masaharu Goto
// May need improvement for the latest standard


////////////////////////////////////////////////////////////////////////
// iterator_tag
////////////////////////////////////////////////////////////////////////
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag {};
struct bidirectional_iterator_tag {};
struct random_access_iterator_tag {};

////////////////////////////////////////////////////////////////////////
// iterator template
////////////////////////////////////////////////////////////////////////
template <class T, class Distance> struct input_iterator {};
struct output_iterator {};
template <class T, class Distance> struct forward_iterator {};
template <class T, class Distance> struct bidirectional_iterator {};
template <class T, class Distance> struct random_access_iterator {};

#pragma link off class output_iterator;







////////////////////////////////////////////////////////////////////////
// iterator_category overloaded function
////////////////////////////////////////////////////////////////////////
template <class T, class Distance>
inline input_iterator_tag
iterator_category(const input_iterator<T, Distance>&) {
    return input_iterator_tag();
}

inline output_iterator_tag iterator_category(const output_iterator&) {
    return output_iterator_tag();
}

#pragma link off function iterator_category(const output_iterator&);


template <class T, class Distance>
inline forward_iterator_tag
iterator_category(const forward_iterator<T, Distance>&) {
    return forward_iterator_tag();
}

template <class T, class Distance>
inline bidirectional_iterator_tag
iterator_category(const bidirectional_iterator<T, Distance>&) {
    return bidirectional_iterator_tag();
}

template <class T, class Distance>
inline random_access_iterator_tag
iterator_category(const random_access_iterator<T, Distance>&) {
    return random_access_iterator_tag();
}

template <class T>
inline random_access_iterator_tag
iterator_category(const T*) {
    return random_access_iterator_tag();
}


// iterator_traits, iterator and reverse_iterator template may not be
// needed for precompiled library interface 

////////////////////////////////////////////////////////////////////////
// iterator_traits
////////////////////////////////////////////////////////////////////////

template <class Iterator>
struct iterator_traits {
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type value_type;
  typedef typename Iterator::difference_type difference_type;
  typedef typename Iterator::pointer pointer;
  typedef typename Iterator::reference reference;
};

// template partial specialization, implement in cint5.15.14 1587
template <class T>
struct iterator_traits<T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
};

// incomplete implementation in cint5.15.14 1587, need some fix
// iterator_traits<const int*> is changed as iterator_traits<const int* const>
// or something, but cint5.15.14 can not handle this well
template <class T>
struct iterator_traits<const T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef const T* pointer;
  typedef const T& reference;
};

////////////////////////////////////////////////////////////////////////
// iterator
////////////////////////////////////////////////////////////////////////
template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator {
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
  typedef Category iterator_category;
};


////////////////////////////////////////////////////////////////////////
// reverse_iterator
////////////////////////////////////////////////////////////////////////






template <class Iterator>
class reverse_iterator
# 166 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
{




 public:
# 181 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
   typedef Iterator::pointer pointer;
   typedef Iterator::reference reference;
   typedef ptrdiff_t difference_type;


   reverse_iterator();
   //reverse_iterator(Iterator x);



   Iterator base() const; // explicit
   reference operator*() const;
   pointer operator->() const;
   reverse_iterator& operator++();
   reverse_iterator operator++(int);
   reverse_iterator& operator--();
   reverse_iterator operator--(int);
   reverse_iterator operator+ (difference_type n) const;
   reverse_iterator& operator+=(difference_type n);
   reverse_iterator operator- (difference_type n) const;
   reverse_iterator& operator-=(difference_type n);
   reference operator[](difference_type n) const;
};
# 932 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
// for g++ 3.1,3.2
namespace __gnu_cxx
{
  // This iterator adapter is 'normal' in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                    difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparaison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  // _GLIBCPP_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
     const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
} // namespace __gnu_cxx







#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 2
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/deque" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <memory.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/memory

#pragma ifndef PREC_STL_MEMORY
#pragma define PREC_STL_MEMORY
#pragma link off global PREC_STL_MEMORY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////


template <class _Tp>
class allocator {
  //typedef alloc _Alloc;          // The underlying allocator.
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  typedef typename _Tp* pointer;
  typedef const typename _Tp * const_pointer;




  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() ;
  allocator(const allocator&) ;
  //template <class _Tp1> allocator(const allocator<_Tp1>&) ;
  ~allocator() ;

  pointer address(reference __x) const ;
  const_pointer address(const_reference __x) const ;

  // __n is permitted to be 0.  The C++ standard says nothing about what
  // the return value is when __n == 0.
  _Tp* allocate(size_type __n, const void* = 0) ;

  // __p is not permitted to be a null pointer.
  void deallocate(pointer __p, size_type __n);

  size_type max_size() const ;

  void construct(pointer __p, const _Tp& __val) ;
  void destroy(pointer __p) ;
};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;
  typedef void value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };
};
//////////////////////////////////////////////////////////////////////
# 205 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////

/**********************************************************************
* auto_ptr
**********************************************************************/
template <class X> class auto_ptr {
private:
  X* ptr;
  //template<class Y> struct auto_ptr_ref { };
public:
  typedef X element_type;
  explicit auto_ptr(X* p = 0) : ptr(p) {}
  auto_ptr(auto_ptr& a) {ptr=a.ptr;}

  // this implementation may not be correct
  template <class T> auto_ptr(auto_ptr<T>& a) {ptr=a.release();}
# 229 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  auto_ptr& operator=(auto_ptr& a) {
    if (a.ptr != ptr) {
      delete ptr;
      ptr = a.ptr;
    }
    return(*this);
  }

  // this implementation may not be correct
  template <class T> auto_ptr& operator=(auto_ptr<T>& a) {
    if (a.ptr != ptr) {
       delete ptr;
       ptr = a.release();
    }
    return(*this);
  }

  ~auto_ptr() { delete ptr; }

  X& operator*() const { return *ptr; }
  X* operator->() const { return ptr; }
  X* get() const { return ptr; }
  X* release() { X *old = ptr; ptr = 0; return 0; }
# 262 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  // auto_ptr conversions
  //auto_ptr(auto_ptr_ref<X>& x) { }
  //template<class Y> operator auto_ptr_ref<Y>() { return auto_ptr_ref<Y>(); }
  //template<class Y> operator auto_ptr<Y>() { return auto_ptr<T>(); }
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 2
# 28 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/deque" 2


template<class T,class Allocator=std::allocator<T> >
# 42 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/deque"
class deque {
 public:
  typedef T value_type;
  typedef Allocator allocator_type;

  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
# 62 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/deque"
  class iterator
# 77 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/deque"
 {
   public:
    iterator() ;
    iterator(const iterator& x) ;


    iterator& operator=(const iterator& x) ;

    T& operator*() const ;

    T* operator->() const;

    iterator& operator++();
    iterator operator++(int a);
    iterator& operator--();
    iterator operator--(int a);
# 102 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/deque"
    iterator operator+(long n);
    iterator operator-(long n);
    iterator& operator+=(long n);
    iterator& operator-=(long n);
    T& operator[](long n) ;
  };




  friend bool operator==(const deque::iterator& x
                        ,const deque::iterator& y) const;
  friend bool operator!=(const deque::iterator& x
                        ,const deque::iterator& y) const;


  class reverse_iterator
# 133 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/deque"
 {
   public:
    reverse_iterator(const reverse_iterator& x);

    reverse_iterator& operator=(const reverse_iterator& x) ;




    T& operator*() const ;


    T* operator->() const;

    reverse_iterator& operator++();
    reverse_iterator operator++(int a);
    reverse_iterator& operator--();
    reverse_iterator operator--(int a);
    reverse_iterator operator+(long n);
    reverse_iterator operator-(long n);
    reverse_iterator& operator+=(long n);
    reverse_iterator& operator-=(long n);
    T& operator[](long n) ;
   private:
  };
  friend bool operator==(const deque::reverse_iterator& x
                        ,const deque::reverse_iterator& y) const;
  friend bool operator!=(const deque::reverse_iterator& x
                        ,const deque::reverse_iterator& y) const;

  typedef const iterator const_iterator;
  typedef const reverse_iterator const_reverse_iterator;

  deque();
  deque(size_type n, const T& value = T());






  deque(const T* first,const T* last) ;

  deque(const_iterator first, const_iterator last);

  deque(const deque& x);
  ~deque();
  deque& operator=(const deque& x);







  //allocator_type get_allocator() const;
  // iterators:
  iterator begin();
  iterator end();
  reverse_iterator rbegin();
  reverse_iterator rend();






  // _lib.deque.capacity_ capacity:
  size_type size() const;
  size_type max_size() const;
  void resize(size_type sz, T c = T());
  bool empty() const;

  // element access:
  T& operator[](size_type n);
  //const_reference operator[](size_type n) const;



  //const_reference at(size_type n) const;
  T& front();
  //const_reference front() const;
  T& back();
  //const_reference back() const;
  // _lib.deque.modifiers_ modifiers:
  void push_front(const T& x);
  void push_back(const T& x);
  iterator insert(iterator position, const T& x);
  void insert(iterator position, size_type n, const T& x);





  void pop_front();
  void pop_back();
  iterator erase(iterator position);
  iterator erase(iterator first, iterator last);
  void swap(deque<T,Allocator>&);
  void clear();

  friend bool operator==(const deque& x, const deque& y);
  friend bool operator< (const deque& x, const deque& y);
  friend bool operator!=(const deque& x, const deque& y);
  friend bool operator> (const deque& x, const deque& y);
  friend bool operator>=(const deque& x, const deque& y);
  friend bool operator<=(const deque& x, const deque& y);
  // specialized algorithms:





#pragma ifndef G__NOALGORITHM
  // Generic algorithm


  // input iter
  friend deque::iterator
    find(deque::iterator first,deque::iterator last,const T& value);
  // forward iter
  friend deque::iterator
    find_end(deque::iterator first1,deque::iterator last1,
      deque::iterator first2,deque::iterator last2);
  friend deque::iterator
    find_first_of(deque::iterator first1,deque::iterator last1,
           deque::iterator first2,deque::iterator last2);
  friend deque::iterator
    adjacent_find(deque::iterator first,deque::iterator last);
  // input iter

  friend deque::difference_type
    count(deque::iterator first,deque::iterator last,const T& value);






  friend bool
    equal(deque::iterator first1,deque::iterator last1,
          deque::iterator first2);
  // forward iter
  friend deque::iterator
    search(deque::iterator first1,deque::iterator last1,
           deque::iterator first2,deque::iterator last2);
  friend deque::iterator
    search_n(deque::iterator first,deque::iterator last
             ,deque::size_type count,const T& value);
  // input and output iter -> forward iter
  friend deque::iterator
    copy(deque::iterator first,deque::iterator last,
         deque::iterator result);
  // bidirectional iter
  friend deque::iterator
    copy_backward(deque::iterator first,deque::iterator last,
                  deque::iterator result);
  // just value_type
  friend void swap(T& a,T& b);
  // forward iter
  friend deque::iterator
    swap_ranges(deque::iterator first1,deque::iterator last1,
                deque::iterator first2);
  friend void iter_swap(deque::iterator a,deque::iterator b);
  friend void replace(deque::iterator first,deque::iterator last,
                      const T& old_value,const T& new_value);
  // input, output iter -> forward iter
  friend deque::iterator
    replace_copy(deque::iterator first,deque::iterator last,
                 deque::iterator result,
                 const T& old_value,const T& new_value);
  // forward iter
  friend void
    fill(deque::iterator first,deque::iterator last,const T& value);

  friend void
    fill_n(deque::iterator first,deque::size_type n,const T& value);

  friend deque::iterator
    remove(deque::iterator first,deque::iterator last,const T& value);
  // input,output iter -> forward iter
  friend deque::iterator
    remove_copy(deque::iterator first,deque::iterator last,
                deque::iterator result,const T& value);
  friend deque::iterator
    unique(deque::iterator first,deque::iterator last);
  friend deque::iterator
    unique_copy(deque::iterator first,deque::iterator last,
                deque::iterator result);
  friend void reverse(deque::iterator first,deque::iterator last);
  friend deque::iterator
     reverse_copy(deque::iterator first,deque::iterator last,
                  deque::iterator result);
  // forward iter
  friend void rotate(deque::iterator first,deque::iterator mid,
                     deque::iterator last);
  // forward iter
  friend deque::iterator
    rotate_copy(deque::iterator first,deque::iterator mid,
                deque::iterator last,deque::iterator result);
  // randomaccess iter
  friend void random_shuffle(deque::iterator first,deque::iterator last);
  // randomaccess iter
  friend void sort(deque::iterator first,deque::iterator last);
  friend void stable_sort(deque::iterator first,deque::iterator last);
  friend void partial_sort(deque::iterator first,deque::iterator mid,
                           deque::iterator last);
  friend deque::iterator
    partial_sort_copy(deque::iterator first,deque::iterator last,
                      deque::iterator result_first,
                      deque::iterator result_last);
  friend void nth_element(deque::iterator first,deque::iterator nth,
                          deque::iterator last);
  // forward iter
  friend deque::iterator
    lower_bound(deque::iterator first,deque::iterator last,const T& value);
  friend deque::iterator
    upper_bound(deque::iterator first,deque::iterator last,const T& value);




  friend bool binary_search(deque::iterator first,deque::iterator last,
                            const T& value);
  friend deque::iterator merge(deque::iterator first1,deque::iterator last1,
                                deque::iterator first2,deque::iterator last2,
                                deque::iterator result);
  friend void inplace_merge(deque::iterator first,deque::iterator middle,
                            deque::iterator last);
  friend bool includes(deque::iterator first1,deque::iterator last1,
                       deque::iterator first2,deque::iterator last2);
  friend deque::iterator
    set_union(deque::iterator first1,deque::iterator last1,
              deque::iterator first2,deque::iterator last2,
              deque::iterator result);
  friend deque::iterator
    set_intersection(deque::iterator first1,deque::iterator last1,
                     deque::iterator first2,deque::iterator last2,
                     deque::iterator result);
  friend deque::iterator
    set_difference(deque::iterator first1,deque::iterator last1,
                   deque::iterator first2,deque::iterator last2,
                   deque::iterator result);
  friend deque::iterator
    set_symmetric_difference(deque::iterator first1,deque::iterator last1,
                             deque::iterator first2,deque::iterator last2,
                             deque::iterator result);
  // random access
  friend void push_heap(deque::iterator first,deque::iterator last);
  friend void pop_heap(deque::iterator first,deque::iterator last);
  friend void make_heap(deque::iterator first,deque::iterator last);
  friend void sort_heap(deque::iterator first,deque::iterator last);
  // min,max, just value_type
  friend const T& min(const T& a,const T& b);
  friend const T& max(const T& a,const T& b);
  // forward iter
  friend deque::iterator
    min_element(deque::iterator first,deque::iterator last);
  friend deque::iterator
    max_element(deque::iterator first,deque::iterator last);
  // input iter
  friend bool
    lexicographical_compare(deque::iterator first1,deque::iterator last1,
                            deque::iterator first2,deque::iterator last2);
  // bidirectional iter
  friend bool next_permutation(deque::iterator first,deque::iterator last);
  friend bool prev_permutation(deque::iterator first,deque::iterator last);
# 425 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/deque"
#pragma endif

  // Generic algorithm
  //friend void reverse(deque::iterator first,deque::iterator last);
  //friend void reverse(deque::reverse_iterator first,deque::reverse_itetator last);

  // iterator_category resolution
  //friend random_access_iterator_tag iterator_category(deque::iterator x);
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_deque" 2
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/deque" 2
}
# 31 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsArg.h" 2

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iostream" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iostream.h" 1
/* /% C++ %/ */
/***********************************************************************
 * cint (C/C++ interpreter)
 ************************************************************************
 * I/O stream header file iostream.h
 ************************************************************************
 * Description:
 *  CINT iostream header file
 ************************************************************************
 * Copyright(c) 1995~1999  Masaharu Goto 
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
# 11 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iostream" 2
}
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/_iostream" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// include/_iostream

std::ostream& operator<<(std::ostream& ostr,std::G__CINT_ENDL& i)
 {return(std::endl(ostr));}
std::ostream& operator<<(std::ostream& ostr,std::G__CINT_ENDS& i)
 {return(std::ends(ostr));}
std::ostream& operator<<(std::ostream& ostr,std::G__CINT_FLUSH& i)
 {return(std::flush(ostr));}

std::istream& operator>>(std::istream& istr,std::G__CINT_ws& i)
 {return(std::ws(istr));}
std::istream& operator>>(std::istream& istr,std::G__CINT_WS& i)
 {return(std::WS(istr));}


std::ostream& operator<<(std::ostream& ostr,std::G__CINT_IOFLAGS& f) {
   ostr.setf(f.flag, f.mask);
  return ostr;
}
std::istream& operator>>(std::istream& istr,std::G__CINT_IOFLAGS& f) {
  istr.setf(f.flag, f.mask);
  return istr;
}

std::ostream& operator<<(std::ostream& ostr,std::G__CINT_NOSUPPORT& i) {
  fprintf(stderr,"Limitation: dec,hex,oct manipurator not supported\n");
  return(ostr);
}
std::istream& operator<<(std::istream& istr,std::G__CINT_NOSUPPORT& i) {
  fprintf(stderr,"Limitation: dec,hex,oct manipurator not supported\n");
  return(istr);
}


std::ostream& operator<<(std::ostream& ostr,long long i) {
  char buf[200];
#pragma ifndef G__TMPLTIOS
  if (ostr.flags() & ios::hex)
#pragma else
  if (ostr.flags() & ios_base::hex)
#pragma endif
     sprintf(buf,"%llx",i);
  else
     sprintf(buf,"%lld",i);
  ostr << buf ;
  return(ostr);
}
std::ostream& operator<<(std::ostream& ostr,unsigned long long i) {
  char buf[200];
#pragma ifndef G__TMPLTIOS
  if (ostr.flags() & ios::hex)
#pragma else
  if (ostr.flags() & ios_base::hex)
#pragma endif
     sprintf(buf,"%llx",i);
  else
     sprintf(buf,"%llu",i);
  ostr << buf ;
  return(ostr);
}
std::ostream& operator<<(std::ostream& ostr,long double i) {
  char buf[200];
  sprintf(buf,"%Lg",i);
  ostr << buf ;
  return(ostr);
}
std::istream& operator>>(std::istream& istr,long long &i) {
  char buf[200];
  istr >> buf ;
  sscanf(buf,"%lld",&i);
  return(istr);
}
std::istream& operator>>(std::istream& istr,unsigned long long &i) {
  char buf[200];
  istr >> buf ;
#pragma ifndef G__TMPLTIOS
  if (ostr.flags() & ios::hex)
#pragma else
  if (ostr.flags() & ios_base::hex)
#pragma endif
     sscanf(buf,"%llx",&i);
  else
     sscanf(buf,"%llu",&i);
  return(istr);
}
std::istream& operator>>(std::istream& istr,long double &i) {
  char buf[200];
  istr >> buf ;
  sscanf(buf,"%Lg",&i);
  return(istr);
}


// Value evaluation
//template<class T> int G__ateval(const T* x) {return(0);}
//template<class T> int G__ateval(const T& x) {return(0);}
int G__ateval(const char* const &x) {return(0);}
//int G__ateval(const void* const &x) {return(0);}
int G__ateval(double x) {return(0);}
int G__ateval(float x) {return(0);}
int G__ateval(bool x) {return(0);}
int G__ateval(char x) {return(0);}
int G__ateval(short x) {return(0);}
int G__ateval(int x) {return(0);}
int G__ateval(long x) {return(0);}
int G__ateval(unsigned char x) {return(0);}
int G__ateval(unsigned short x) {return(0);}
int G__ateval(unsigned int x) {return(0);}
int G__ateval(unsigned long x) {return(0);}
# 127 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/_iostream"
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iomanip.h" 1
/* /% C++ %/ */
/***********************************************************************
 * cint (C/C++ interpreter)
 ************************************************************************
 * I/O manipulator header for iomanip.h
 ************************************************************************
 * Description:
 *  CINT IOMANIP header file
 ************************************************************************
 * Author                  Masaharu Goto 
 * Copyright(c) 1995~1999  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
# 127 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/_iostream" 2
# 12 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iostream" 2
# 33 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsArg.h" 2

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TClass.h" 1
// @(#)root/meta:$Id: TClass.h 43993 2012-04-27 16:23:16Z pcanal $
// Author: Rene Brun   07/01/95

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/





//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TClass                                                               //
//                                                                      //
// Dictionary of a class.                                               //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TDictionary.h" 1
// @(#)root/meta:$Id: TDictionary.h 41070 2011-09-30 12:15:22Z axel $
// Author: Fons Rademakers   20/06/96

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/





//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TDictionary                                                          //
//                                                                      //
// This class defines an abstract interface that must be implemented    //
// by all classes that contain dictionary information.                  //
//                                                                      //
// The dictionary is defined by the followling classes:                 //
// TDataType                              (typedef definitions)         //
// TGlobal                                (global variables)            //
// TFunction                              (global functions)            //
// TClass                                 (classes)                     //
//    TBaseClass                          (base classes)                //
//    TDataMember                         (class datamembers)           //
//    TMethod                             (class methods)               //
//       TMethodArg                       (method arguments)            //
//                                                                      //
// All the above classes implement the TDictionary abstract interface   //
// (note: the indentation shows aggregation not inheritance).           //
// The ROOT dictionary system provides a very extensive RTTI            //
// environment that facilitates a.o. object inspectors, object I/O,     //
// ROOT Trees, etc. Most of the type information is provided by the     //
// CINT C++ interpreter.                                                //
//                                                                      //
// TMethodCall                            (method call environment)     //
//                                                                      //
//////////////////////////////////////////////////////////////////////////





# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Property.h" 1
/* /% C++ %/ */
/***********************************************************************
 * cint (C/C++ interpreter)
 ************************************************************************
 * Header file Property.h
 ************************************************************************
 * Description:
 *  Extended Run Time Type Identification API
 ************************************************************************
 * Copyright(c) 1995~1999  Masaharu Goto 
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/




/* Normal Property() */
# 59 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Property.h"
/* ECF enhancement  ClassProperty() */
# 49 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TDictionary.h" 2

typedef void CallFunc_t;
typedef void ClassInfo_t;
typedef void BaseClassInfo_t;
typedef void DataMemberInfo_t;
typedef void MethodInfo_t;
typedef void MethodArgInfo_t;
typedef void MethodArgInfo_t;
typedef void TypeInfo_t;
typedef void TypedefInfo_t;

enum EProperty {
   kIsClass = 0x00000001,
   kIsStruct = 0x00000002,
   kIsUnion = 0x00000004,
   kIsEnum = 0x00000008,
   kIsNamespace = 0x08000000,
   kIsTypedef = 0x00000010,
   kIsFundamental = 0x00000020,
   kIsAbstract = 0x00000040,
   kIsVirtual = 0x00000080,
   kIsPureVirtual = 0x00000100,
   kIsPublic = 0x00000200,
   kIsProtected = 0x00000400,
   kIsPrivate = 0x00000800,
   kIsPointer = 0x00001000,
   kIsArray = 0x00002000,
   kIsStatic = 0x00004000,
   kIsUsingVariable= 0x20000000,
   kIsDefault = 0x00008000,
   kIsReference = 0x00010000,
   kIsConstant = 0x00100000,
   kIsConstPointer = 0x00400000,
   kIsMethConst = 0x10000000
};


class TDictionary : public TNamed {

public:
   TDictionary() { }
   TDictionary(const char* name): TNamed(name, "") { }
   virtual ~TDictionary() { }

   virtual Long_t Property() const = 0;
   static TDictionary* GetDictionary(const char* name);
   static TDictionary* GetDictionary(const type_info &typeinfo);

   // Type of STL container (returned by IsSTLContainer).
   enum ESTLType {kNone=0, kVector=1, kList, kDeque, kMap, kMultimap, kSet, kMultiset};

   private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 0; } static void Dictionary(); virtual TClass *IsA() const { return TDictionary::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { TDictionary::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TDictionary.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 100; } //ABC defining interface to dictionary
};
# 26 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TClass.h" 2
# 34 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TClass.h"
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TObjString.h" 1
// @(#)root/base:$Id: TObjString.h 20877 2007-11-19 11:17:07Z rdm $
// Author: Fons Rademakers   12/11/95

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/





//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TObjString                                                           //
//                                                                      //
// Collectable string class. This is a TObject containing a TString.    //
//                                                                      //
//////////////////////////////////////////////////////////////////////////
# 32 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TObjString.h"
class TObjString : public TObject {

private:
   TString fString; // wrapped TString

public:
   TObjString(const char *s = "") : fString(s) { }
   TObjString(const TObjString &s) : TObject(), fString(s.fString) { }
   ~TObjString() { }
   Int_t Compare(const TObject *obj) const;
   const char *GetName() const { return fString; }
   ULong_t Hash() const { return fString.Hash(); }
   void FillBuffer(char *&buffer) { fString.FillBuffer(buffer); }
   void Print(Option_t *) const { Printf("TObjString = %s", (const char*)fString); }
   Bool_t IsSortable() const { return kTRUE; }
   Bool_t IsEqual(const TObject *obj) const;
   void ReadBuffer(char *&buffer) { fString.ReadBuffer(buffer); }
   void SetString(const char *s) { fString = s; }
   TString GetString() const { return fString; }
   Int_t Sizeof() const { return fString.Sizeof(); }
   TString &String() { return fString; }

   private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return TObjString::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { TObjString::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TObjString.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 54; } //Collectable string class
};
# 35 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TClass.h" 2

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/map" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_map" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <pair.dll>
#pragma include_noerr <map.dll>
#pragma include_noerr <map2.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/map

#pragma ifndef PREC_STL_MAP
#pragma define PREC_STL_MAP
#pragma link off global PREC_STL_MAP;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from ANSI/ISO C++ 1997/Nov draft 
// Got some ideas from Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <utility.dll>


#pragma include_noerr <pair.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/utility

#pragma ifndef PREC_STL_UTILITY
#pragma define PREC_STL_UTILITY
#pragma link off global PREC_STL_UTILITY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

template <class T1, class T2>
struct pair {
  T1 first;
  T2 second;
  pair() : first(T1()), second(T2()) {}
  pair(const T1& a, const T2& b) : first(a), second(b) {}
 private:
  pair& operator=(const pair& x){first=x.first;second=x.second;return *this;}
};

#pragma endif
# 17 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 2
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <memory.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/memory

#pragma ifndef PREC_STL_MEMORY
#pragma define PREC_STL_MEMORY
#pragma link off global PREC_STL_MEMORY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////


template <class _Tp>
class allocator {
  //typedef alloc _Alloc;          // The underlying allocator.
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  typedef typename _Tp* pointer;
  typedef const typename _Tp * const_pointer;




  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() ;
  allocator(const allocator&) ;
  //template <class _Tp1> allocator(const allocator<_Tp1>&) ;
  ~allocator() ;

  pointer address(reference __x) const ;
  const_pointer address(const_reference __x) const ;

  // __n is permitted to be 0.  The C++ standard says nothing about what
  // the return value is when __n == 0.
  _Tp* allocate(size_type __n, const void* = 0) ;

  // __p is not permitted to be a null pointer.
  void deallocate(pointer __p, size_type __n);

  size_type max_size() const ;

  void construct(pointer __p, const _Tp& __val) ;
  void destroy(pointer __p) ;
};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;
  typedef void value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };
};
//////////////////////////////////////////////////////////////////////
# 205 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////

/**********************************************************************
* auto_ptr
**********************************************************************/
template <class X> class auto_ptr {
private:
  X* ptr;
  //template<class Y> struct auto_ptr_ref { };
public:
  typedef X element_type;
  explicit auto_ptr(X* p = 0) : ptr(p) {}
  auto_ptr(auto_ptr& a) {ptr=a.ptr;}

  // this implementation may not be correct
  template <class T> auto_ptr(auto_ptr<T>& a) {ptr=a.release();}
# 229 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  auto_ptr& operator=(auto_ptr& a) {
    if (a.ptr != ptr) {
      delete ptr;
      ptr = a.ptr;
    }
    return(*this);
  }

  // this implementation may not be correct
  template <class T> auto_ptr& operator=(auto_ptr<T>& a) {
    if (a.ptr != ptr) {
       delete ptr;
       ptr = a.release();
    }
    return(*this);
  }

  ~auto_ptr() { delete ptr; }

  X& operator*() const { return *ptr; }
  X* operator->() const { return ptr; }
  X* get() const { return ptr; }
  X* release() { X *old = ptr; ptr = 0; return 0; }
# 262 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  // auto_ptr conversions
  //auto_ptr(auto_ptr_ref<X>& x) { }
  //template<class Y> operator auto_ptr_ref<Y>() { return auto_ptr_ref<Y>(); }
  //template<class Y> operator auto_ptr<Y>() { return auto_ptr<T>(); }
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 2
# 28 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <iterator.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/iterator

#pragma ifndef PREC_STL_ITERATOR
#pragma define PREC_STL_ITERATOR
#pragma link off global PREC_STL_ITERATOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from STL HP implementation 1994
// Imported from STL SGI implementation 1997 
// Imported from ANSI/ISO C++ draft Nov 1997
// Modified by Masaharu Goto
// May need improvement for the latest standard


////////////////////////////////////////////////////////////////////////
// iterator_tag
////////////////////////////////////////////////////////////////////////
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag {};
struct bidirectional_iterator_tag {};
struct random_access_iterator_tag {};

////////////////////////////////////////////////////////////////////////
// iterator template
////////////////////////////////////////////////////////////////////////
template <class T, class Distance> struct input_iterator {};
struct output_iterator {};
template <class T, class Distance> struct forward_iterator {};
template <class T, class Distance> struct bidirectional_iterator {};
template <class T, class Distance> struct random_access_iterator {};

#pragma link off class output_iterator;







////////////////////////////////////////////////////////////////////////
// iterator_category overloaded function
////////////////////////////////////////////////////////////////////////
template <class T, class Distance>
inline input_iterator_tag
iterator_category(const input_iterator<T, Distance>&) {
    return input_iterator_tag();
}

inline output_iterator_tag iterator_category(const output_iterator&) {
    return output_iterator_tag();
}

#pragma link off function iterator_category(const output_iterator&);


template <class T, class Distance>
inline forward_iterator_tag
iterator_category(const forward_iterator<T, Distance>&) {
    return forward_iterator_tag();
}

template <class T, class Distance>
inline bidirectional_iterator_tag
iterator_category(const bidirectional_iterator<T, Distance>&) {
    return bidirectional_iterator_tag();
}

template <class T, class Distance>
inline random_access_iterator_tag
iterator_category(const random_access_iterator<T, Distance>&) {
    return random_access_iterator_tag();
}

template <class T>
inline random_access_iterator_tag
iterator_category(const T*) {
    return random_access_iterator_tag();
}


// iterator_traits, iterator and reverse_iterator template may not be
// needed for precompiled library interface 

////////////////////////////////////////////////////////////////////////
// iterator_traits
////////////////////////////////////////////////////////////////////////

template <class Iterator>
struct iterator_traits {
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type value_type;
  typedef typename Iterator::difference_type difference_type;
  typedef typename Iterator::pointer pointer;
  typedef typename Iterator::reference reference;
};

// template partial specialization, implement in cint5.15.14 1587
template <class T>
struct iterator_traits<T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
};

// incomplete implementation in cint5.15.14 1587, need some fix
// iterator_traits<const int*> is changed as iterator_traits<const int* const>
// or something, but cint5.15.14 can not handle this well
template <class T>
struct iterator_traits<const T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef const T* pointer;
  typedef const T& reference;
};

////////////////////////////////////////////////////////////////////////
// iterator
////////////////////////////////////////////////////////////////////////
template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator {
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
  typedef Category iterator_category;
};


////////////////////////////////////////////////////////////////////////
// reverse_iterator
////////////////////////////////////////////////////////////////////////






template <class Iterator>
class reverse_iterator
# 166 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
{




 public:
# 181 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
   typedef Iterator::pointer pointer;
   typedef Iterator::reference reference;
   typedef ptrdiff_t difference_type;


   reverse_iterator();
   //reverse_iterator(Iterator x);



   Iterator base() const; // explicit
   reference operator*() const;
   pointer operator->() const;
   reverse_iterator& operator++();
   reverse_iterator operator++(int);
   reverse_iterator& operator--();
   reverse_iterator operator--(int);
   reverse_iterator operator+ (difference_type n) const;
   reverse_iterator& operator+=(difference_type n);
   reverse_iterator operator- (difference_type n) const;
   reverse_iterator& operator-=(difference_type n);
   reference operator[](difference_type n) const;
};
# 932 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
// for g++ 3.1,3.2
namespace __gnu_cxx
{
  // This iterator adapter is 'normal' in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                    difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparaison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  // _GLIBCPP_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
     const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
} // namespace __gnu_cxx







#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 2
# 29 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_functional" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <functional.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/functional" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/functional

#pragma ifndef PREC_STL_FUNCTIONAL
#pragma define PREC_STL_FUNCTIONAL
#pragma link off global PREC_STL_FUNCTIONAL;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab

// clause _lib.base_, base:
template <class Arg, class Result>
struct unary_function
{
  typedef Arg argument_type;
  typedef Result result_type;
};


template <class Arg1, class Arg2, class Result>
struct binary_function
{
  typedef Arg1 first_argument_type;
  typedef Arg2 second_argument_type;
  typedef Result result_type;
};


// clause _lib.arithmetic.operations_, arithmetic operations:
template <class T> struct plus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct minus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct multiplies : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct divides : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};

template <class T> struct modulus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};

template <class T> struct negate : unary_function<T,T> {
  T operator()(const T& x) const;
};


// clause _lib.comparisons_, comparisons:
template <class T> struct equal_to : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct not_equal_to : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct greater : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct less : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct greater_equal : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct less_equal : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};


// clause _lib.logical.operations_, logical operations:
template <class T> struct logical_and : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct logical_or : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct logical_not : unary_function<T,bool> {
  bool operator()(const T& x) const;
};


// clause _lib.negators_, negators:
template <class Predicate>
class unary_negate
  : public unary_function<Predicate::argument_type, bool>
{
public:
  explicit unary_negate(const Predicate& pred);
  bool operator()(const argument_type& x) const;
};






template <class Predicate>
class binary_negate
  : public binary_function<Predicate::first_argument_type,
                           Predicate::second_argument_type, bool>
{
public:
  explicit binary_negate(const Predicate& pred);
  bool operator()(const first_argument_type& x,
                  const second_argument_type& y) const;
};

// operations omitted (cint can't handle template forward decls...)







// clause _lib.binders_, binders:
template <class Operation>
class binder1st
  : public unary_function<Operation::second_argument_type,
                          Operation::result_type>
{
protected:
  Operation op;
  Operation::first_argument_type value;
public:
  binder1st(const Operation& x, const Operation::first_argument_type& y);
  result_type operator()(const argument_type& x) const;
};


// operations omitted (cint can't handle template forward decls...)





template <class Operation>
class binder2nd
  : public unary_function<Operation::first_argument_type,
                          Operation::result_type>
{
protected:
  Operation op;
  Operation::second_argument_type value;
public:
  binder2nd(const Operation& x, const Operation::second_argument_type& y);
  result_type operator()(const argument_type& x) const;
};


// operations omitted (cint can't handle template forward decls...)






// clause _lib.function.pointer.adaptors_, adaptors:
template <class Arg, class Result>
class pointer_to_unary_function
  : public unary_function<Arg, Result>
{
public:
  explicit pointer_to_unary_function(Result (*f)(Arg));
  Result operator()(Arg x) const;
};

// operations omitted (cint can't handle template forward decls...)





template <class Arg1, class Arg2, class Result>
class pointer_to_binary_function
  : public binary_function<Arg1,Arg2,Result>
{
public:
  explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));
  Result operator()(Arg1 x, Arg2 y) const;
};

// operations omitted (cint can't handle template forward decls...)






// omit these for now.
# 230 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/functional"
#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_functional" 2
# 30 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map" 2

//////////////////////////////////////////////////////////////////////////

template<class Key,class T,class Compare=std::less<Key>
        ,class Allocator=std::allocator<pair<const Key, T> > >
# 63 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map"
class map {
 public:
  typedef Key key_type;
  typedef T mapped_type;



  typedef pair<Key,T> value_type;

  typedef Compare key_compare;
  typedef Allocator allocator_type;

  //typedef Key*                                     pointer;
  //typedef const Key*                               const_pointer;
  //typedef Key&                                     reference;
  //typedef const Key&                               const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
# 90 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map"
  class iterator
# 103 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map"
 {
   public:
    iterator() ;
    iterator(const iterator& x) ;

    iterator& operator=(const iterator& x) ;

    value_type& operator*() ;

    value_type* operator->() ;

    iterator& operator++();
    iterator operator++(int a);
    iterator& operator--();
    iterator operator--(int a);

    bool operator==(const iterator& x) ;
    bool operator!=(const iterator& x) ;




  };
# 134 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map"
  class reverse_iterator
# 147 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map"
 {
   public:
    reverse_iterator(const reverse_iterator& x);

    reverse_iterator& operator=(const reverse_iterator& x) ;

    value_type& operator*() ;

    value_type* operator->() ;

    reverse_iterator& operator++();
    reverse_iterator operator++(int a);
    reverse_iterator& operator--();
    reverse_iterator operator--(int a);
   private:
  };

  friend bool operator==(const map::reverse_iterator& x
                        ,const map::reverse_iterator& y) const;
  friend bool operator!=(const map::reverse_iterator& x
                        ,const map::reverse_iterator& y) const;


  typedef const iterator const_iterator;
  typedef const reverse_iterator const_reverse_iterator;

  // _lib.map.cons_ construct/copy/destroy:
  map();






  map(iterator first, iterator last);
  map(reverse_iterator first, reverse_iterator last);

  map(const map& x);
  ~map();
  map& operator=(const map& x);
  // iterators:
  iterator begin();
  iterator end();
  reverse_iterator rbegin();
  reverse_iterator rend();






  // capacity:
  bool empty() const;
  size_type size() const;
  size_type max_size() const;
  // _lib.map.access_ element access:
  T& operator[](const Key& x);
  // modifiers:
  pair<map::iterator, bool> insert(const value_type& x);
  iterator insert(iterator position, const value_type& x);





  void insert(iterator first, iterator last);
  void insert(reverse_iterator first, reverse_iterator last);

  void erase(iterator position);
  size_type erase(const Key& x);
  void erase(iterator first, iterator last);
  void swap(map&);
  void clear();
  // observers:
  //key_compare   key_comp() const;
  //value_compare value_comp() const;
  // _lib.map.ops_ map operations:
  iterator find(const Key& x);
  //const_iterator find(const Key& x) const;
  size_type count(const Key& x) const;
  iterator lower_bound(const Key& x);
  //const_iterator lower_bound(const Key& x) const;
  iterator upper_bound(const Key& x);
  //const_iterator upper_bound(const Key& x) const;





  friend bool operator==(const map& x, const map& y);
  friend bool operator< (const map& x, const map& y);
  friend bool operator!=(const map& x, const map& y);
  friend bool operator> (const map& x, const map& y);
  friend bool operator>=(const map& x, const map& y);
  friend bool operator<=(const map& x, const map& y);
  // specialized algorithms:





#pragma ifndef G__NOALGORITHM
  // Generic algorithm
  friend map::iterator
    search(map::iterator first1,map::iterator last1,
           map::iterator first2,map::iterator last2);
#pragma endif

  // iterator_category resolution
  //friend bidirectional_iterator_tag iterator_category(map::iterator x);

};

//////////////////////////////////////////////////////////////////////////

#pragma endif
# 16 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_map" 2
# 26 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_map"
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_multimap" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

//#pragma include_noerr <pair.dll> 
#pragma include_noerr <multimap.dll>
#pragma include_noerr <multimap2.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/multimap

#pragma ifndef PREC_STL_MULTIMAP
#pragma define PREC_STL_MULTIMAP
#pragma link off global PREC_STL_MULTIMAP;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from ANSI/ISO C++ 1997/Nov draft 
// Got some ideas from Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <utility.dll>


#pragma include_noerr <pair.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/utility

#pragma ifndef PREC_STL_UTILITY
#pragma define PREC_STL_UTILITY
#pragma link off global PREC_STL_UTILITY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

template <class T1, class T2>
struct pair {
  T1 first;
  T2 second;
  pair() : first(T1()), second(T2()) {}
  pair(const T1& a, const T2& b) : first(a), second(b) {}
 private:
  pair& operator=(const pair& x){first=x.first;second=x.second;return *this;}
};

#pragma endif
# 17 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 2
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <memory.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/memory

#pragma ifndef PREC_STL_MEMORY
#pragma define PREC_STL_MEMORY
#pragma link off global PREC_STL_MEMORY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////


template <class _Tp>
class allocator {
  //typedef alloc _Alloc;          // The underlying allocator.
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  typedef typename _Tp* pointer;
  typedef const typename _Tp * const_pointer;




  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() ;
  allocator(const allocator&) ;
  //template <class _Tp1> allocator(const allocator<_Tp1>&) ;
  ~allocator() ;

  pointer address(reference __x) const ;
  const_pointer address(const_reference __x) const ;

  // __n is permitted to be 0.  The C++ standard says nothing about what
  // the return value is when __n == 0.
  _Tp* allocate(size_type __n, const void* = 0) ;

  // __p is not permitted to be a null pointer.
  void deallocate(pointer __p, size_type __n);

  size_type max_size() const ;

  void construct(pointer __p, const _Tp& __val) ;
  void destroy(pointer __p) ;
};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;
  typedef void value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };
};
//////////////////////////////////////////////////////////////////////
# 205 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////

/**********************************************************************
* auto_ptr
**********************************************************************/
template <class X> class auto_ptr {
private:
  X* ptr;
  //template<class Y> struct auto_ptr_ref { };
public:
  typedef X element_type;
  explicit auto_ptr(X* p = 0) : ptr(p) {}
  auto_ptr(auto_ptr& a) {ptr=a.ptr;}

  // this implementation may not be correct
  template <class T> auto_ptr(auto_ptr<T>& a) {ptr=a.release();}
# 229 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  auto_ptr& operator=(auto_ptr& a) {
    if (a.ptr != ptr) {
      delete ptr;
      ptr = a.ptr;
    }
    return(*this);
  }

  // this implementation may not be correct
  template <class T> auto_ptr& operator=(auto_ptr<T>& a) {
    if (a.ptr != ptr) {
       delete ptr;
       ptr = a.release();
    }
    return(*this);
  }

  ~auto_ptr() { delete ptr; }

  X& operator*() const { return *ptr; }
  X* operator->() const { return ptr; }
  X* get() const { return ptr; }
  X* release() { X *old = ptr; ptr = 0; return 0; }
# 262 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  // auto_ptr conversions
  //auto_ptr(auto_ptr_ref<X>& x) { }
  //template<class Y> operator auto_ptr_ref<Y>() { return auto_ptr_ref<Y>(); }
  //template<class Y> operator auto_ptr<Y>() { return auto_ptr<T>(); }
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 2
# 28 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <iterator.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/iterator

#pragma ifndef PREC_STL_ITERATOR
#pragma define PREC_STL_ITERATOR
#pragma link off global PREC_STL_ITERATOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from STL HP implementation 1994
// Imported from STL SGI implementation 1997 
// Imported from ANSI/ISO C++ draft Nov 1997
// Modified by Masaharu Goto
// May need improvement for the latest standard


////////////////////////////////////////////////////////////////////////
// iterator_tag
////////////////////////////////////////////////////////////////////////
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag {};
struct bidirectional_iterator_tag {};
struct random_access_iterator_tag {};

////////////////////////////////////////////////////////////////////////
// iterator template
////////////////////////////////////////////////////////////////////////
template <class T, class Distance> struct input_iterator {};
struct output_iterator {};
template <class T, class Distance> struct forward_iterator {};
template <class T, class Distance> struct bidirectional_iterator {};
template <class T, class Distance> struct random_access_iterator {};

#pragma link off class output_iterator;







////////////////////////////////////////////////////////////////////////
// iterator_category overloaded function
////////////////////////////////////////////////////////////////////////
template <class T, class Distance>
inline input_iterator_tag
iterator_category(const input_iterator<T, Distance>&) {
    return input_iterator_tag();
}

inline output_iterator_tag iterator_category(const output_iterator&) {
    return output_iterator_tag();
}

#pragma link off function iterator_category(const output_iterator&);


template <class T, class Distance>
inline forward_iterator_tag
iterator_category(const forward_iterator<T, Distance>&) {
    return forward_iterator_tag();
}

template <class T, class Distance>
inline bidirectional_iterator_tag
iterator_category(const bidirectional_iterator<T, Distance>&) {
    return bidirectional_iterator_tag();
}

template <class T, class Distance>
inline random_access_iterator_tag
iterator_category(const random_access_iterator<T, Distance>&) {
    return random_access_iterator_tag();
}

template <class T>
inline random_access_iterator_tag
iterator_category(const T*) {
    return random_access_iterator_tag();
}


// iterator_traits, iterator and reverse_iterator template may not be
// needed for precompiled library interface 

////////////////////////////////////////////////////////////////////////
// iterator_traits
////////////////////////////////////////////////////////////////////////

template <class Iterator>
struct iterator_traits {
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type value_type;
  typedef typename Iterator::difference_type difference_type;
  typedef typename Iterator::pointer pointer;
  typedef typename Iterator::reference reference;
};

// template partial specialization, implement in cint5.15.14 1587
template <class T>
struct iterator_traits<T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
};

// incomplete implementation in cint5.15.14 1587, need some fix
// iterator_traits<const int*> is changed as iterator_traits<const int* const>
// or something, but cint5.15.14 can not handle this well
template <class T>
struct iterator_traits<const T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef const T* pointer;
  typedef const T& reference;
};

////////////////////////////////////////////////////////////////////////
// iterator
////////////////////////////////////////////////////////////////////////
template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator {
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
  typedef Category iterator_category;
};


////////////////////////////////////////////////////////////////////////
// reverse_iterator
////////////////////////////////////////////////////////////////////////






template <class Iterator>
class reverse_iterator
# 166 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
{




 public:
# 181 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
   typedef Iterator::pointer pointer;
   typedef Iterator::reference reference;
   typedef ptrdiff_t difference_type;


   reverse_iterator();
   //reverse_iterator(Iterator x);



   Iterator base() const; // explicit
   reference operator*() const;
   pointer operator->() const;
   reverse_iterator& operator++();
   reverse_iterator operator++(int);
   reverse_iterator& operator--();
   reverse_iterator operator--(int);
   reverse_iterator operator+ (difference_type n) const;
   reverse_iterator& operator+=(difference_type n);
   reverse_iterator operator- (difference_type n) const;
   reverse_iterator& operator-=(difference_type n);
   reference operator[](difference_type n) const;
};
# 932 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
// for g++ 3.1,3.2
namespace __gnu_cxx
{
  // This iterator adapter is 'normal' in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                    difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparaison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  // _GLIBCPP_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
     const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
} // namespace __gnu_cxx







#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 2
# 29 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_functional" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <functional.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/functional" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/functional

#pragma ifndef PREC_STL_FUNCTIONAL
#pragma define PREC_STL_FUNCTIONAL
#pragma link off global PREC_STL_FUNCTIONAL;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab

// clause _lib.base_, base:
template <class Arg, class Result>
struct unary_function
{
  typedef Arg argument_type;
  typedef Result result_type;
};


template <class Arg1, class Arg2, class Result>
struct binary_function
{
  typedef Arg1 first_argument_type;
  typedef Arg2 second_argument_type;
  typedef Result result_type;
};


// clause _lib.arithmetic.operations_, arithmetic operations:
template <class T> struct plus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct minus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct multiplies : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct divides : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};

template <class T> struct modulus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};

template <class T> struct negate : unary_function<T,T> {
  T operator()(const T& x) const;
};


// clause _lib.comparisons_, comparisons:
template <class T> struct equal_to : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct not_equal_to : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct greater : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct less : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct greater_equal : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct less_equal : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};


// clause _lib.logical.operations_, logical operations:
template <class T> struct logical_and : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct logical_or : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct logical_not : unary_function<T,bool> {
  bool operator()(const T& x) const;
};


// clause _lib.negators_, negators:
template <class Predicate>
class unary_negate
  : public unary_function<Predicate::argument_type, bool>
{
public:
  explicit unary_negate(const Predicate& pred);
  bool operator()(const argument_type& x) const;
};






template <class Predicate>
class binary_negate
  : public binary_function<Predicate::first_argument_type,
                           Predicate::second_argument_type, bool>
{
public:
  explicit binary_negate(const Predicate& pred);
  bool operator()(const first_argument_type& x,
                  const second_argument_type& y) const;
};

// operations omitted (cint can't handle template forward decls...)







// clause _lib.binders_, binders:
template <class Operation>
class binder1st
  : public unary_function<Operation::second_argument_type,
                          Operation::result_type>
{
protected:
  Operation op;
  Operation::first_argument_type value;
public:
  binder1st(const Operation& x, const Operation::first_argument_type& y);
  result_type operator()(const argument_type& x) const;
};


// operations omitted (cint can't handle template forward decls...)





template <class Operation>
class binder2nd
  : public unary_function<Operation::first_argument_type,
                          Operation::result_type>
{
protected:
  Operation op;
  Operation::second_argument_type value;
public:
  binder2nd(const Operation& x, const Operation::second_argument_type& y);
  result_type operator()(const argument_type& x) const;
};


// operations omitted (cint can't handle template forward decls...)






// clause _lib.function.pointer.adaptors_, adaptors:
template <class Arg, class Result>
class pointer_to_unary_function
  : public unary_function<Arg, Result>
{
public:
  explicit pointer_to_unary_function(Result (*f)(Arg));
  Result operator()(Arg x) const;
};

// operations omitted (cint can't handle template forward decls...)





template <class Arg1, class Arg2, class Result>
class pointer_to_binary_function
  : public binary_function<Arg1,Arg2,Result>
{
public:
  explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));
  Result operator()(Arg1 x, Arg2 y) const;
};

// operations omitted (cint can't handle template forward decls...)






// omit these for now.
# 230 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/functional"
#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_functional" 2
# 30 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap" 2

//////////////////////////////////////////////////////////////////////////

// This does not work yet. Don't know why.
template<class Key,class T,class Compare=std::less<Key>
        ,class Allocator=std::allocator<pair<const Key,T> > >
# 63 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap"
class multimap {
 public:
  typedef Key key_type;
  typedef T mapped_type;
  typedef pair<Key,T> value_type;
  //typedef pair<const Key,T>                         value_type;
  typedef Compare key_compare;
  typedef Allocator allocator_type;

  //typedef Key*                                     pointer;
  //typedef const Key*                               const_pointer;
  //typedef Key&                                     reference;
  //typedef const Key&                               const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
# 87 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap"
  class iterator
# 100 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap"
 {
   public:
    iterator() ;
    iterator(const iterator& x) ;

    iterator& operator=(const iterator& x) ;

    value_type& operator*() ;

    value_type* operator->() ;

    iterator& operator++();
    iterator operator++(int a);
    iterator& operator--();
    iterator operator--(int a);

    bool operator==(const iterator& x) ;
    bool operator!=(const iterator& x) ;




  };
# 131 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap"
  class reverse_iterator
# 144 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap"
 {
   public:
    reverse_iterator(const reverse_iterator& x);

    reverse_iterator& operator=(const reverse_iterator& x) ;

    value_type& operator*() ;

    value_type* operator->() ;

    reverse_iterator& operator++();
    reverse_iterator operator++(int a);
    reverse_iterator& operator--();
    reverse_iterator operator--(int a);
   private:
  };

  friend bool operator==(const multimap::reverse_iterator& x
                        ,const multimap::reverse_iterator& y) const;
  friend bool operator!=(const multimap::reverse_iterator& x
                        ,const multimap::reverse_iterator& y) const;


  typedef const iterator const_iterator;
  typedef const reverse_iterator const_reverse_iterator;

  // _lib.multimap.cons_ construct/copy/destroy:
  multimap();






  multimap(iterator first, iterator last);
  multimap(reverse_iterator first, reverse_iterator last);

  multimap(const multimap& x);
  ~multimap();
  multimap& operator=(const multimap& x);
  // iterators:
  iterator begin();
  iterator end();
  reverse_iterator rbegin();
  reverse_iterator rend();






  // capacity:
  bool empty() const;
  size_type size() const;
  size_type max_size() const;
  // _lib.multimap.access_ element access:
  //T& operator[](const Key& x);
  // modifiers:
  iterator insert(const value_type& x);
  iterator insert(iterator position, const value_type& x);





  void insert(iterator first, iterator last);
  void insert(reverse_iterator first, reverse_iterator last);

  void erase(iterator position);
  size_type erase(const Key& x);
  void erase(iterator first, iterator last);
  void swap(multimap&);
  void clear();
  // observers:
  //key_compare   key_comp() const;
  //value_compare value_comp() const;
  // _lib.multimap.ops_ multimap operations:
  iterator find(const Key& x);
  //const_iterator find(const Key& x) const;
  size_type count(const Key& x) const;
  iterator lower_bound(const Key& x);
  //const_iterator lower_bound(const Key& x) const;
  iterator upper_bound(const Key& x);
  //const_iterator upper_bound(const Key& x) const;





  friend bool operator==(const multimap& x, const multimap& y);
  friend bool operator< (const multimap& x, const multimap& y);
  friend bool operator!=(const multimap& x, const multimap& y);
  friend bool operator> (const multimap& x, const multimap& y);
  friend bool operator>=(const multimap& x, const multimap& y);
  friend bool operator<=(const multimap& x, const multimap& y);
  // specialized algorithms:





#pragma ifndef G__NOALGORITHM
  // Generic algorithm
  friend multimap::iterator
    search(multimap::iterator first1,multimap::iterator last1,
           multimap::iterator first2,multimap::iterator last2);
#pragma endif


  // Generic algorithm
  //friend void reverse(multimap::iterator first,multimap::iterator last);
  //friend void reverse(multimap::reverse_iterator first,multimap::reverse_itetator last);

  // iterator_category resolution
  //friend bidirectional_iterator_tag iterator_category(multimap::iterator x);

};

//////////////////////////////////////////////////////////////////////////

#pragma endif
# 16 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_multimap" 2
# 26 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_map" 2
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/map" 2
}
# 37 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TClass.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/string" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_string" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// string
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/string" 2
}
# 38 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TClass.h" 2

class TBaseClass;
class TBrowser;
class TDataMember;
class TClassRef;
class TMethod;
class TRealData;
class TCint;
class TBuffer;
class TVirtualStreamerInfo;
class TVirtualCollectionProxy;
class TMethodCall;
class TVirtualIsAProxy;
class TVirtualRefProxy;
class THashTable;

namespace clang {
   class Decl;
}

namespace ROOT {
   class TGenericClassInfo;
   class TCollectionProxyInfo;
   class TSchemaRuleSet;
}

namespace ROOT {
   class TMapTypeToTClass;
}
typedef ROOT::TMapTypeToTClass IdMap_t;

class TClass : public TDictionary {

friend class TCint;
friend class TCintWithCling;
friend void ROOT::ResetClassVersion(TClass*, const char*, Short_t);
friend class ROOT::TGenericClassInfo;

public:
   // TClass status bits
   enum { kClassSaved = (1ULL << (12)), kIgnoreTObjectStreamer = (1ULL << (15)),
          kUnloaded = (1ULL << (16)), kIsTObject = (1ULL << (17)),
          kIsForeign = (1ULL << (18)), kIsEmulation = (1ULL << (19)),
          kStartWithTObject = (1ULL << (20)), // see comments for IsStartingWithTObject()
          kWarned = (1ULL << (21)),
          kHasNameMapNode = (1ULL << (22))
   };
   enum ENewType { kRealNew = 0, kClassNew, kDummyNew };

private:

   mutable TObjArray *fStreamerInfo; //Array of TVirtualStreamerInfo
   mutable std::map<std::string, TObjArray*> *fConversionStreamerInfo; //Array of the streamer infos derived from another class.
   TList *fRealData; //linked list for persistent members including base classes
   TList *fBase; //linked list for base classes
   TList *fData; //linked list for data members
   TList *fMethod; //linked list for methods
   TList *fAllPubData; //all public data members (including from base classes)
   TList *fAllPubMethod; //all public methods (including from base classes)
   mutable TList *fClassMenuList; //list of class menu items

   const char *fDeclFileName; //name of class declaration file
   const char *fImplFileName; //name of class implementation file
   Short_t fDeclFileLine; //line of class declaration
   Short_t fImplFileLine; //line of class implementation
   UInt_t fInstanceCount; //number of instances of this class
   UInt_t fOnHeap; //number of instances on heap
   mutable UInt_t fCheckSum; //checksum of data members and base classes
   TVirtualCollectionProxy *fCollectionProxy; //Collection interface
   Version_t fClassVersion; //Class version Identifier
   ClassInfo_t *fClassInfo; //pointer to CINT class info class
   TString fContextMenuTitle;//context menu title
   const type_info *fTypeInfo; //pointer to the C++ type information.
   ShowMembersFunc_t fShowMembers; //pointer to the class's ShowMembers function
   mutable void *fInterShowMembers;//Interpreter call setup for ShowMembers
   TClassStreamer *fStreamer; //pointer to streamer function
   TString fSharedLibs; //shared libraries containing class code

   TVirtualIsAProxy *fIsA; //!pointer to the class's IsA proxy.
   IsAGlobalFunc_t fGlobalIsA; //pointer to a global IsA function.
   mutable TMethodCall *fIsAMethod; //!saved info to call a IsA member function

   ROOT::MergeFunc_t fMerge; //pointer to a function implementing Merging objects of this class.
   ROOT::ResetAfterMergeFunc_t fResetAfterMerge; //pointer to a function implementing Merging objects of this class.
   ROOT::NewFunc_t fNew; //pointer to a function newing one object.
   ROOT::NewArrFunc_t fNewArray; //pointer to a function newing an array of objects.
   ROOT::DelFunc_t fDelete; //pointer to a function deleting one object.
   ROOT::DelArrFunc_t fDeleteArray; //pointer to a function deleting an array of objects.
   ROOT::DesFunc_t fDestructor; //pointer to a function call an object's destructor.
   ROOT::DirAutoAdd_t fDirAutoAdd; //pointer which implements the Directory Auto Add feature for this class.']'
   ClassStreamerFunc_t fStreamerFunc; //Wrapper around this class custom Streamer member function.
   Int_t fSizeof; //Sizeof the class.

   mutable Int_t fCanSplit; //!Indicates whether this class can be split or not.
   mutable Long_t fProperty; //!Property
   mutable Bool_t fVersionUsed; //!Indicates whether GetClassVersion has been called

   mutable Bool_t fIsOffsetStreamerSet; //!saved remember if fOffsetStreamer has been set.
   mutable Long_t fOffsetStreamer; //!saved info to call Streamer
   Int_t fStreamerType; //!cached of the streaming method to use
   mutable TVirtualStreamerInfo *fCurrentInfo; //!cached current streamer info.
   TClassRef *fRefStart; //!List of references to this object
   TVirtualRefProxy *fRefProxy; //!Pointer to reference proxy if this class represents a reference
   ROOT::TSchemaRuleSet *fSchemaRules; //! Schema evolution rules

   typedef void (TClass::*StreamerImpl_t)(void *obj, TBuffer &b, const TClass *onfile_class) const;
   mutable StreamerImpl_t fStreamerImpl;//! Pointer to the function implementing the right streaming behavior for the class represented by this object.

   TMethod *GetClassMethod(Long_t faddr);
   TMethod *GetClassMethod(const char *name, const char *signature);
   Int_t GetBaseClassOffsetRecurse(const TClass *base);
   void Init(const char *name, Version_t cversion, const type_info *info,
             TVirtualIsAProxy *isa, ShowMembersFunc_t showmember,
             const char *dfil, const char *ifil,
             Int_t dl, Int_t il,
             Bool_t silent);
   void ForceReload (TClass* oldcl);

   void SetClassVersion(Version_t version);
   void SetClassSize(Int_t sizof) { fSizeof = sizof; }

   // Various implementation for TClass::Stramer
   void StreamerExternal(void *object, TBuffer &b, const TClass *onfile_class) const;
   void StreamerTObject(void *object, TBuffer &b, const TClass *onfile_class) const;
   void StreamerTObjectInitialized(void *object, TBuffer &b, const TClass *onfile_class) const;
   void StreamerTObjectEmulated(void *object, TBuffer &b, const TClass *onfile_class) const;
   void StreamerInstrumented(void *object, TBuffer &b, const TClass *onfile_class) const;
   void StreamerStreamerInfo(void *object, TBuffer &b, const TClass *onfile_class) const;
   void StreamerDefault(void *object, TBuffer &b, const TClass *onfile_class) const;

   static IdMap_t *GetIdMap(); //Map from typeid to TClass pointer
   static ENewType fgCallingNew; //Intent of why/how TClass::New() is called
   static Int_t fgClassCount; //provides unique id for a each class
                                        //stored in TObject::fUniqueID
   // Internal status bits
   enum { kLoading = (1ULL << (14)) };
   // Internal streamer type.
   enum EStreamerType {kDefault=0, kEmulated=1, kTObject=2, kInstrumented=4, kForeign=8, kExternal=16};

   // When a new class is created, we need to be able to find
   // if there are any existing classes that have the same name
   // after any typedefs are expanded.  (This only really affects
   // template arguments.)  To avoid having to search through all classes
   // in that case, we keep a hash table mapping from the fully
   // typedef-expanded names to the original class names.
   // An entry is made in the table only if they are actually different.
   //
   // In these objects, the TObjString base holds the typedef-expanded
   // name (the hash key), and fOrigName holds the original class name
   // (the value to which the key maps).
   //
   class TNameMapNode
     : public TObjString
   {
   public:
     TNameMapNode (const char* typedf, const char* orig);
     TString fOrigName;
   };

   // These are the above-referenced hash tables.  (The pointers are null
   // if no entries have been made.)  There are actually two variants.
   // In the first, the typedef names are resolved with
   // TClassEdit::ResolveTypedef; in the second, the class names
   // are first massaged with TClassEdit::ShortType with kDropStlDefault.
   // (??? Are the two distinct tables really needed?)
   static THashTable* fgClassTypedefHash;
   static THashTable* fgClassShortTypedefHash;

private:
   TClass(const TClass& tc);
   TClass& operator=(const TClass&);

protected:
   TVirtualStreamerInfo *FindStreamerInfo(TObjArray* arr, UInt_t checksum) const;
   static THashTable *GetClassShortTypedefHash();

public:
   TClass();
   TClass(const char *name, Bool_t silent = kFALSE);
   TClass(const char *name, Version_t cversion,
          const char *dfil = 0, const char *ifil = 0,
          Int_t dl = 0, Int_t il = 0, Bool_t silent = kFALSE);
   TClass(const char *name, Version_t cversion,
          const type_info &info, TVirtualIsAProxy *isa,
          ShowMembersFunc_t showmember,
          const char *dfil, const char *ifil,
          Int_t dl, Int_t il, Bool_t silent = kFALSE);
   virtual ~TClass();

   void AddInstance(Bool_t heap = kFALSE) { fInstanceCount++; if (heap) fOnHeap++; }
   void AddImplFile(const char *filename, int line);
   void AddRef(TClassRef *ref);
   static Bool_t AddRule(const char *rule);
   static Int_t ReadRules(const char *filename);
   static Int_t ReadRules();
   void AdoptSchemaRules( ROOT::TSchemaRuleSet *rules );
   virtual void Browse(TBrowser *b);
   void BuildRealData(void *pointer=0, Bool_t isTransient = kFALSE);
   void BuildEmulatedRealData(const char *name, Long_t offset, TClass *cl);
   void CalculateStreamerOffset() const;
   Bool_t CallShowMembers(void* obj, TMemberInspector &insp,
                                      Int_t isATObject = -1) const;
   Bool_t CanSplit() const;
   Bool_t CanIgnoreTObjectStreamer() { return TestBit(kIgnoreTObjectStreamer);}
   TObject *Clone(const char *newname="") const;
   void CopyCollectionProxy(const TVirtualCollectionProxy&);
   void Draw(Option_t *option="");
   void Dump() const { TDictionary::Dump(); }
   void Dump(void *obj) const;
   char *EscapeChars(const char *text) const;
   TVirtualStreamerInfo *FindStreamerInfo(UInt_t checksum) const;
   TVirtualStreamerInfo *GetConversionStreamerInfo( const char* onfile_classname, Int_t version ) const;
   TVirtualStreamerInfo *FindConversionStreamerInfo( const char* onfile_classname, UInt_t checksum ) const;
   TVirtualStreamerInfo *GetConversionStreamerInfo( const TClass* onfile_cl, Int_t version ) const;
   TVirtualStreamerInfo *FindConversionStreamerInfo( const TClass* onfile_cl, UInt_t checksum ) const;
   Bool_t HasDefaultConstructor() const;
   UInt_t GetCheckSum(UInt_t code=0) const;
   TVirtualCollectionProxy *GetCollectionProxy() const;
   TVirtualIsAProxy *GetIsAProxy() const;
   Version_t GetClassVersion() const { fVersionUsed = kTRUE; return fClassVersion; }
   TDataMember *GetDataMember(const char *datamember) const;
   Long_t GetDataMemberOffset(const char *membername) const;
   const char *GetDeclFileName() const { return fDeclFileName; }
   Short_t GetDeclFileLine() const { return fDeclFileLine; }
   ROOT::DelFunc_t GetDelete() const;
   ROOT::DesFunc_t GetDestructor() const;
   ROOT::DelArrFunc_t GetDeleteArray() const;
   ClassInfo_t *GetClassInfo() const { return fClassInfo; }
   const char *GetContextMenuTitle() const { return fContextMenuTitle; }
   TVirtualStreamerInfo *GetCurrentStreamerInfo() {
      if (fCurrentInfo) return fCurrentInfo;
      else return (fCurrentInfo=(TVirtualStreamerInfo*)(fStreamerInfo->At(fClassVersion)));
   }
   TList *GetListOfDataMembers();
   TList *GetListOfBases();
   TList *GetListOfMethods();
   TList *GetListOfRealData() const { return fRealData; }
   TList *GetListOfAllPublicMethods();
   TList *GetListOfAllPublicDataMembers();
   const char *GetImplFileName() const { return fImplFileName; }
   Short_t GetImplFileLine() const { return fImplFileLine; }
   TClass *GetActualClass(const void *object) const;
   TClass *GetBaseClass(const char *classname);
   TClass *GetBaseClass(const TClass *base);
   Int_t GetBaseClassOffset(const TClass *base);
   TClass *GetBaseDataMember(const char *datamember);
   ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const;
   UInt_t GetInstanceCount() const { return fInstanceCount; }
   UInt_t GetHeapInstanceCount() const { return fOnHeap; }
   void GetMenuItems(TList *listitems);
   TList *GetMenuList() const;
   TMethod *GetMethod(const char *method, const char *params);
   TMethod *GetMethodWithPrototype(const char *method, const char *proto);
   TMethod *GetMethodAny(const char *method);
   TMethod *GetMethodAllAny(const char *method);
   Int_t GetNdata();
   ROOT::MergeFunc_t GetMerge() const;
   ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const;
   ROOT::NewFunc_t GetNew() const;
   ROOT::NewArrFunc_t GetNewArray() const;
   Int_t GetNmethods();
   TRealData *GetRealData(const char *name) const;
   TVirtualRefProxy *GetReferenceProxy() const { return fRefProxy; }
   const ROOT::TSchemaRuleSet *GetSchemaRules() const;
   ROOT::TSchemaRuleSet *GetSchemaRules(Bool_t create = kFALSE);
   const char *GetSharedLibs();
   ShowMembersFunc_t GetShowMembersWrapper() const { return fShowMembers; }
   TClassStreamer *GetStreamer() const;
   ClassStreamerFunc_t GetStreamerFunc() const;
   TObjArray *GetStreamerInfos() const { return fStreamerInfo; }
   TVirtualStreamerInfo *GetStreamerInfo(Int_t version=0) const;
   TVirtualStreamerInfo *GetStreamerInfoAbstractEmulated(Int_t version=0) const;
   const type_info *GetTypeInfo() const { return fTypeInfo; };
   void IgnoreTObjectStreamer(Bool_t ignore=kTRUE);
   Bool_t InheritsFrom(const char *cl) const;
   Bool_t InheritsFrom(const TClass *cl) const;
   void InterpretedShowMembers(void* obj, TMemberInspector &insp);
   Bool_t IsFolder() const { return kTRUE; }
   Bool_t IsLoaded() const;
   Bool_t IsForeign() const;
   Bool_t IsStartingWithTObject() const;
   Bool_t IsTObject() const;
   void ls(Option_t *opt="") const;
   void MakeCustomMenuList();
   void Move(void *arenaFrom, void *arenaTo) const;
   void *New(ENewType defConstructor = kClassNew) const;
   void *New(void *arena, ENewType defConstructor = kClassNew) const;
   void *NewArray(Long_t nElements, ENewType defConstructor = kClassNew) const;
   void *NewArray(Long_t nElements, void *arena, ENewType defConstructor = kClassNew) const;
   virtual void PostLoadCheck();
   Long_t Property() const;
   Int_t ReadBuffer(TBuffer &b, void *pointer, Int_t version, UInt_t start, UInt_t count);
   Int_t ReadBuffer(TBuffer &b, void *pointer);
   void RemoveRef(TClassRef *ref);
   void ReplaceWith(TClass *newcl, Bool_t recurse = kTRUE) const;
   void ResetClassInfo(Long_t tagnum);
   void ResetInstanceCount() { fInstanceCount = fOnHeap = 0; }
   void ResetMenuList();
   Int_t Size() const;
   void SetCanSplit(Int_t splitmode);
   void SetCollectionProxy(const ROOT::TCollectionProxyInfo&);
   void SetContextMenuTitle(const char *title);
   void SetCurrentStreamerInfo(TVirtualStreamerInfo *info);
   void SetGlobalIsA(IsAGlobalFunc_t);
   void SetDeclFile(const char *name, int line) { fDeclFileName = name; fDeclFileLine = line; }
   void SetDelete(ROOT::DelFunc_t deleteFunc);
   void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc);
   void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc);
   void SetDestructor(ROOT::DesFunc_t destructorFunc);
   void SetImplFileName(const char *implFileName) { fImplFileName = implFileName; }
   void SetMerge(ROOT::MergeFunc_t mergeFunc);
   void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc);
   void SetNew(ROOT::NewFunc_t newFunc);
   void SetNewArray(ROOT::NewArrFunc_t newArrayFunc);
   TVirtualStreamerInfo *SetStreamerInfo(Int_t version, const char *info="");
   void SetUnloaded();
   Int_t WriteBuffer(TBuffer &b, void *pointer, const char *info="");

   void AdoptReferenceProxy(TVirtualRefProxy* proxy);
   void AdoptStreamer(TClassStreamer *strm);
   void AdoptMemberStreamer(const char *name, TMemberStreamer *strm);
   void SetMemberStreamer(const char *name, MemberStreamerFunc_t strm);
   void SetStreamerFunc(ClassStreamerFunc_t strm);

   // Function to retrieve the TClass object and dictionary function
   static void AddClass(TClass *cl);
   static void RemoveClass(TClass *cl);
   static TClass *GetClass(const char *name, Bool_t load = kTRUE, Bool_t silent = kFALSE);
   static TClass *GetClass(const type_info &typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE);
   static VoidFuncPtr_t GetDict (const char *cname);
   static VoidFuncPtr_t GetDict (const type_info &info);

   static Int_t AutoBrowse(TObject *obj, TBrowser *browser);
   static ENewType IsCallingNew();
   static TClass *Load(TBuffer &b);
   void Store(TBuffer &b) const;

   // Pseudo-method apply to the 'obj'. In particular those are used to
   // implement TObject like methods for non-TObject classes

   Int_t Browse(void *obj, TBrowser *b) const;
   void DeleteArray(void *ary, Bool_t dtorOnly = kFALSE);
   void Destructor(void *obj, Bool_t dtorOnly = kFALSE);
   void *DynamicCast(const TClass *base, void *obj, Bool_t up = kTRUE);
   Bool_t IsFolder(void *obj) const;
   inline void Streamer(void *obj, TBuffer &b, const TClass *onfile_class = 0) const
   {
      // Inline for performance, skipping one function call.
       (this->*fStreamerImpl)(obj,b,onfile_class);
   }

   private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 0; } static void Dictionary(); virtual TClass *IsA() const { return TClass::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { TClass::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TClass.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 389; } //Dictionary containing class information
};

namespace ROOT {


      template <typename T> struct IsPointer { enum { kVal = 0 }; };
      template <typename T> struct IsPointer<T*> { enum { kVal = 1 }; };





   template <typename T> TClass* GetClass( T* /* dummy */) { return TClass::GetClass(typeid(T)); }
   template <typename T> TClass* GetClass(const T* /* dummy */) { return TClass::GetClass(typeid(T)); }


      // This can only be used when the template overload resolution can distringuish between
      // T* and T**
      template <typename T> TClass* GetClass( T** /* dummy */) { return GetClass((T*)0); }
      template <typename T> TClass* GetClass(const T** /* dummy */) { return GetClass((T*)0); }
      template <typename T> TClass* GetClass( T* const* /* dummy */) { return GetClass((T*)0); }
      template <typename T> TClass* GetClass(const T* const* /* dummy */) { return GetClass((T*)0); }


   extern TClass *CreateClass(const char *cname, Version_t id,
                              const char *dfil, const char *ifil,
                              Int_t dl, Int_t il);
}
# 35 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsArg.h" 2

class TTree ;
class RooArgSet ;
class RooAbsCollection ;
class RooTreeData ;
class RooTreeDataStore ;
class RooVectorDataStore ;
class RooAbsData ;
class RooAbsDataStore ;
class RooAbsProxy ;
class RooArgProxy ;
class RooSetProxy ;
class RooListProxy ;
class RooExpensiveObjectCache ;
class RooWorkspace ;
class RooRealProxy ;
/* class TGraphStruct ; */

class RooAbsArg : public TNamed, public RooPrintable {
public:

  // Constructors, cloning and assignment
  RooAbsArg() ;
  virtual ~RooAbsArg();
  RooAbsArg(const char *name, const char *title);
  RooAbsArg(const RooAbsArg& other, const char* name=0) ;
  virtual TObject* clone(const char* newname) const = 0 ;
  virtual TObject* Clone(const char* newname=0) const {
    return clone(newname?newname:GetName()) ;
  }
  virtual RooAbsArg* cloneTree(const char* newname=0) const ;

  // Accessors to client-server relation information 
  virtual Bool_t isDerived() const {
    // Does value or shape of this arg depend on any other arg?
    return kTRUE ;
    //std::cout << IsA()->GetName() << "::isDerived(" << GetName() << ") = " << (_serverList.GetSize()>0 || _proxyList.GetSize()>0) << std::endl ;
    //return (_serverList.GetSize()>0 || _proxyList.GetSize()>0)?kTRUE:kFALSE; 
  }
  Bool_t isCloneOf(const RooAbsArg& other) const ;
  Bool_t dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg=0) const {
    // Does this arg depend on the value of any of of the values in serverList?
    return dependsOn(serverList,ignoreArg,kTRUE) ;
  }
  Bool_t dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg=0) const {
    // Does this arg depend on the value of server?
    return dependsOn(server,ignoreArg,kTRUE) ;
  }
  Bool_t dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg=0, Bool_t valueOnly=kFALSE) const ;
  Bool_t dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg=0, Bool_t valueOnly=kFALSE) const ;
  Bool_t overlaps(const RooAbsArg& testArg, Bool_t valueOnly=kFALSE) const ;
  Bool_t hasClients() const { return _clientList.GetSize()>0 ? kTRUE : kFALSE ; }
  inline TIterator* clientIterator() const {
    // Return iterator over all client RooAbsArgs
    return _clientList.MakeIterator() ;
  }
  inline TIterator* valueClientIterator() const {
    // Return iterator over all value client RooAbsArgs
    return _clientListValue.MakeIterator() ;
  }
  inline TIterator* shapeClientIterator() const {
    // Return iterator over all shape client RooAbsArgs
    return _clientListShape.MakeIterator() ;
  }
  inline TIterator* serverIterator() const {
    // Return iterator over all server RooAbsArgs
    return _serverList.MakeIterator() ;
  }

  inline RooFIter valueClientMIterator() const { return _clientListValue.fwdIterator() ; }
  inline RooFIter shapeClientMIterator() const { return _clientListShape.fwdIterator() ; }
  inline RooFIter serverMIterator() const { return _serverList.fwdIterator() ; }


  inline RooAbsArg* findServer(const char *name) const {
    // Return server of this arg with given name. Returns null if not found
    return (RooAbsArg*)_serverList.FindObject(name);
  }
  inline RooAbsArg* findServer(const RooAbsArg& arg) const {
    // Return server of this arg with name of given input arg. Returns null if not found
    return (RooAbsArg*)_serverList.findArg(&arg);
  }
  inline RooAbsArg* findServer(Int_t index) const {
    // Return i-th server from server list
    return (RooAbsArg*)_serverList.At(index);
  }
  inline Bool_t isValueServer(const RooAbsArg& arg) const {
    // If true, arg is a value server of self
    return _clientListValue.findArg(&arg)?kTRUE:kFALSE ;
  }
  inline Bool_t isValueServer(const char* name) const {
    // If true, we have a server with given name
    return _clientListValue.FindObject(name)?kTRUE:kFALSE ;
  }
  inline Bool_t isShapeServer(const RooAbsArg& arg) const {
    // If true arg is a shape server of self
    return _clientListShape.findArg(&arg)?kTRUE:kFALSE ;
  }
  inline Bool_t isShapeServer(const char* name) const {
    // If true, we have a shape server with given name
    return _clientListShape.FindObject(name)?kTRUE:kFALSE ;
  }
  void leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg=0, Bool_t recurseNonDerived=kFALSE) const ;
  void branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg=0, Bool_t recurseNonDerived=kFALSE) const ;
  void treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg=0,
     Bool_t doBranch=kTRUE, Bool_t doLeaf=kTRUE,
     Bool_t valueOnly=kFALSE, Bool_t recurseNonDerived=kFALSE) const ;


  inline virtual Bool_t isFundamental() const {
    // Is this object a fundamental type that can be added to a dataset?
    // Fundamental-type subclasses override this method to return kTRUE.
    // Note that this test is subtlely different from the dynamic isDerived()
    // test, e.g. a constant is not derived but is also not fundamental.
    return kFALSE;
  }

  // Create a fundamental-type object that stores our type of value. The
  // created object will have a valid value, but not necessarily the same
  // as our value. The caller is responsible for deleting the returned object.
  virtual RooAbsArg *createFundamental(const char* newname=0) const = 0;

  inline virtual Bool_t isLValue() const {
    // Is this argument an l-value, ie, can it appear on the left-hand side
    // of an assignment expression? LValues are also special since they can
    // potentially be analytically integrated and generated.
    return kFALSE;
  }

  void addParameters(RooArgSet& params, const RooArgSet* nset=0, Bool_t stripDisconnected=kTRUE) const ;

  // Parameter & observable interpretation of servers
  friend class RooProdPdf ;
  friend class RooAddPdf ;
  friend class RooAddPdfOrig ;
  RooArgSet* getVariables(Bool_t stripDisconnected=kTRUE) const ;
  RooArgSet* getParameters(const RooAbsData* data, Bool_t stripDisconnected=kTRUE) const ;
  RooArgSet* getParameters(const RooAbsData& data, Bool_t stripDisconnected=kTRUE) const {
    // Return the parameters of this p.d.f when used in conjuction with dataset 'data'
    return getParameters(&data,stripDisconnected) ;
  }
  RooArgSet* getParameters(const RooArgSet& set, Bool_t stripDisconnected=kTRUE) const {
    // Return the parameters of the p.d.f given the provided set of observables
    return getParameters(&set,stripDisconnected) ;
  }
  virtual RooArgSet* getParameters(const RooArgSet* depList, Bool_t stripDisconnected=kTRUE) const ;
  RooArgSet* getObservables(const RooArgSet& set, Bool_t valueOnly=kTRUE) const {
    // Return the observables of _this_ pdf given a set of observables
    return getObservables(&set,valueOnly) ;
  }
  RooArgSet* getObservables(const RooAbsData* data) const ;
  RooArgSet* getObservables(const RooAbsData& data) const {
    // Return the observables of _this_ pdf given the observables defined by 'data'
    return getObservables(&data) ;
  }
  RooArgSet* getObservables(const RooArgSet* depList, Bool_t valueOnly=kTRUE) const ;
  Bool_t observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const ;
  Bool_t observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const ;
  virtual Bool_t checkObservables(const RooArgSet* nset) const ;
  Bool_t recursiveCheckObservables(const RooArgSet* nset) const ;
  RooArgSet* getComponents() const ;

  // --- Obsolete functions for backward compatibility
  inline RooArgSet* getDependents(const RooArgSet& set) const { return getObservables(set) ; }
  inline RooArgSet* getDependents(const RooAbsData* set) const { return getObservables(set) ; }
  inline RooArgSet* getDependents(const RooArgSet* depList) const { return getObservables(depList) ; }
  inline Bool_t dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const { return observableOverlaps(dset,testArg) ; }
  inline Bool_t dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const { return observableOverlaps(depList, testArg) ; }
  inline Bool_t checkDependents(const RooArgSet* nset) const { return checkObservables(nset) ; }
  inline Bool_t recursiveCheckDependents(const RooArgSet* nset) const { return recursiveCheckObservables(nset) ; }
  // --- End obsolete functions for backward compatibility

  void attachDataSet(const RooAbsData &set);
  void attachDataStore(const RooAbsDataStore &set);

  // I/O streaming interface (machine readable)
  virtual Bool_t readFromStream(std::istream& is, Bool_t compact, Bool_t verbose=kFALSE) = 0 ;
  virtual void writeToStream(std::ostream& os, Bool_t compact) const = 0 ;

  inline virtual void Print(Option_t *options= 0) const {
    // Printing interface (human readable)
    printStream(defaultPrintStream(),defaultPrintContents(options),defaultPrintStyle(options));
  }

  virtual void printName(std::ostream& os) const ;
  virtual void printTitle(std::ostream& os) const ;
  virtual void printClassName(std::ostream& os) const ;
  virtual void printAddress(std::ostream& os) const ;
  virtual void printArgs(std::ostream& os) const ;
  virtual void printMetaArgs(std::ostream& /*os*/) const {} ;
  virtual void printMultiline(std::ostream& os, Int_t contents, Bool_t verbose=kFALSE, TString indent="") const;
  virtual void printTree(std::ostream& os, TString indent="") const ;

  virtual Int_t defaultPrintContents(Option_t* opt) const ;

  // Accessors to attributes
  void setAttribute(const Text_t* name, Bool_t value=kTRUE) ;
  Bool_t getAttribute(const Text_t* name) const ;
  inline const std::set<std::string>& attributes() const {
    // Returns set of names of boolean attributes defined
    return _boolAttrib ;
  }

  void setStringAttribute(const Text_t* key, const Text_t* value) ;
  const Text_t* getStringAttribute(const Text_t* key) const ;
  inline const std::map<std::string,std::string>& stringAttributes() const {
    // Returns std::map<string,string> with all string attributes defined
    return _stringAttrib ;
  }

  // Accessors to transient attributes
  void setTransientAttribute(const Text_t* name, Bool_t value=kTRUE) ;
  Bool_t getTransientAttribute(const Text_t* name) const ;
  inline const std::set<std::string>& transientAttributes() const {
    // Return set of transient boolean attributes 
    return _boolAttribTransient ;
  }

  inline Bool_t isConstant() const {
    // Returns true if 'Constant' attribute is set
    return getAttribute("Constant") ;
  }
  RooLinkedList getCloningAncestors() const ;

  // Sorting
  Int_t Compare(const TObject* other) const ;
  virtual Bool_t IsSortable() const {
    // Object is sortable in ROOT container class
    return kTRUE ;
  }

  //Debug hooks
  static void verboseDirty(Bool_t flag) ;
  void printDirty(Bool_t depth=kTRUE) const ;

  static void setDirtyInhibit(Bool_t flag) ;

  virtual Bool_t operator==(const RooAbsArg& other) = 0 ;

  // Range management
  virtual Bool_t inRange(const char*) const {
    // Is value in range (dummy interface always returns true)
    return kTRUE ;
  }
  virtual Bool_t hasRange(const char*) const {
    // Has this argument a defined range (dummy interface always returns flase)
    return kFALSE ;
  }


  enum ConstOpCode { Activate=0, DeActivate=1, ConfigChange=2, ValueChange=3 } ;


  friend class RooMinuit ;

  // Cache mode optimization (tracks changes & do lazy evaluation vs evaluate always)
  virtual void optimizeCacheMode(const RooArgSet& observables) ;
  virtual void optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes) ;


  // Find constant terms in expression 
  Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList) ;
  Bool_t findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes) ;


  // constant term optimization
  virtual void constOptimizeTestStatistic(ConstOpCode opcode, Bool_t doAlsoTrackingOpt=kTRUE) ;

  void graphVizTree(const char* fileName, const char* delimiter="\n", bool useTitle=false, bool useLatex=false) ;
  void graphVizTree(std::ostream& os, const char* delimiter="\n", bool useTitle=false, bool useLatex=false) ;

/*   TGraphStruct* graph(Bool_t useFactoryTag=kFALSE, Double_t textSize=0.03) ; */

  void printComponentTree(const char* indent="",const char* namePat=0, Int_t nLevel=999) ;
  void printCompactTree(const char* indent="",const char* fileName=0, const char* namePat=0, RooAbsArg* client=0) ;
  void printCompactTree(std::ostream& os, const char* indent="", const char* namePat=0, RooAbsArg* client=0) ;
  virtual void printCompactTreeHook(std::ostream& os, const char *ind="") ;

  // Dirty state accessor
  inline Bool_t isShapeDirty() const {
    // Return true is shape has been invalidated by server value change
    return isDerived()?_shapeDirty:kFALSE ;
  }

  inline Bool_t isValueDirty() const {
    // Returns true of value has been invalidated by server value change
    if (inhibitDirty()) return kTRUE ;
    switch(_operMode) {
    case AClean:
      return kFALSE ;
    case ADirty:
      return kTRUE ;
    case Auto:
      if (_valueDirty) return isDerived() ;
      return kFALSE ;
    }
    return kTRUE ; // we should never get here
  }

  inline Bool_t isValueDirtyAndClear() const {
    // Returns true of value has been invalidated by server value change
    if (inhibitDirty()) return kTRUE ;
    switch(_operMode) {
    case AClean:
      return kFALSE ;
    case ADirty:
      return kTRUE ;
    case Auto:
      if (_valueDirty) {
 _valueDirty = kFALSE ;
 return isDerived();
      }
      return kFALSE ;
    }
    return kTRUE ; // But we should never get here
  }


  inline Bool_t isValueOrShapeDirtyAndClear() const {
    // Returns true of value has been invalidated by server value change

    if (inhibitDirty()) return kTRUE ;
    switch(_operMode) {
    case AClean:
      return kFALSE ;
    case ADirty:
      return kTRUE ;
    case Auto:
      if (_valueDirty || _shapeDirty) {
 _shapeDirty = kFALSE ;
 _valueDirty = kFALSE ;
 return isDerived();
      }
      _shapeDirty = kFALSE ;
      _valueDirty = kFALSE ;
      return kFALSE ;
    }
    return kTRUE ; // But we should never get here
  }

  // Cache management
  void registerCache(RooAbsCache& cache) ;
  void unRegisterCache(RooAbsCache& cache) ;
  Int_t numCaches() const ;
  RooAbsCache* getCache(Int_t index) const ;

  enum OperMode { Auto=0, AClean=1, ADirty=2 } ;
  inline OperMode operMode() const { return _operMode ; }
  void setOperMode(OperMode mode, Bool_t recurseADirty=kTRUE) ;

  static UInt_t crc32(const char* data) ;

  Bool_t addOwnedComponents(const RooArgSet& comps) ;
  const RooArgSet* ownedComponents() const { return _ownedComponents ; }

  void setProhibitServerRedirect(Bool_t flag) { _prohibitServerRedirect = flag ; }

  protected:

  void graphVizAddConnections(std::set<std::pair<RooAbsArg*,RooAbsArg*> >&) ;

  friend class RooExtendPdf ;
  friend class RooRealIntegral ;
  friend class RooAbsReal ;
  friend class RooProjectedPdf ;
  //friend class RooSimCloneTool ;

  virtual void operModeHook() {} ;

  virtual void optimizeDirtyHook(const RooArgSet* /*obs*/) {} ;

  virtual Bool_t isValid() const ;

  virtual void getParametersHook(const RooArgSet* /*nset*/, RooArgSet* /*list*/, Bool_t /*stripDisconnected*/) const {} ;
  virtual void getObservablesHook(const RooArgSet* /*nset*/, RooArgSet* /*list*/) const {} ;

  // Dirty state modifiers
 public:
  inline void setValueDirty() const { if (_operMode==Auto && !inhibitDirty()) setValueDirty(0) ; }
  inline void setShapeDirty() const { setShapeDirty(0) ; }

  inline void clearValueAndShapeDirty() const {
    _valueDirty=kFALSE ;
    _shapeDirty=kFALSE ;
  }

  inline void clearValueDirty() const {
    _valueDirty=kFALSE ;
  }
  inline void clearShapeDirty() const {
    _shapeDirty=kFALSE ;
  }

  const char* aggregateCacheUniqueSuffix() const ;
  virtual const char* cacheUniqueSuffix() const { return 0 ; }

  void wireAllCaches() ;

  inline const TNamed* namePtr() const {
    return _namePtr ;
  }

  void SetName(const char* name) ;
  void SetNameTitle(const char *name, const char *title) ;

 protected:

  // Client-Server relatation and Proxy management 
  friend class RooArgSet ;
  friend class RooAbsCollection ;
  friend class RooCustomizer ;
  friend class RooWorkspace ;
  RooRefCountList _serverList ; // list of server objects
  RooRefCountList _clientList ; // list of client objects
  RooRefCountList _clientListShape ; // subset of clients that requested shape dirty flag propagation
  RooRefCountList _clientListValue ; // subset of clients that requested value dirty flag propagation
  TRefArray _proxyList ; // list of proxies
  std::deque<RooAbsCache*> _cacheList ; // list of caches
  TIterator* _clientShapeIter ; //! Iterator over _clientListShape 
  TIterator* _clientValueIter ; //! Iterator over _clientListValue 

  // Server redirection interface
 public:
  Bool_t redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll=kFALSE, Bool_t nameChange=kFALSE, Bool_t isRecursionStep=kFALSE) ;
  Bool_t recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll=kFALSE, Bool_t nameChange=kFALSE, Bool_t recurseInNewSet=kTRUE) ;
  virtual Bool_t redirectServersHook(const RooAbsCollection& /*newServerList*/, Bool_t /*mustReplaceAll*/, Bool_t /*nameChange*/, Bool_t /*isRecursive*/) { return kFALSE ; } ;
  virtual void serverNameChangeHook(const RooAbsArg* /*oldServer*/, const RooAbsArg* /*newServer*/) { } ;

  void addServer(RooAbsArg& server, Bool_t valueProp=kTRUE, Bool_t shapeProp=kFALSE) ;
  void addServerList(RooAbsCollection& serverList, Bool_t valueProp=kTRUE, Bool_t shapeProp=kFALSE) ;
  void replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp) ;
  void changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp) ;
  void removeServer(RooAbsArg& server, Bool_t force=kFALSE) ;
  RooAbsArg *findNewServer(const RooAbsCollection &newSet, Bool_t nameChange) const;

  RooExpensiveObjectCache& expensiveObjectCache() const ;
  void setExpensiveObjectCache(RooExpensiveObjectCache& cache) { _eocache = &cache ; }

  virtual Bool_t importWorkspaceHook(RooWorkspace&) { return kFALSE ; } ;

 protected:

  // Proxy management
  friend class RooAddModel ;
  friend class RooArgProxy ;
  friend class RooSetProxy ;
  friend class RooListProxy ;
  friend class RooObjectFactory ;
  friend class RooHistPdf ;
  friend class RooHistFunc ;
  void registerProxy(RooArgProxy& proxy) ;
  void registerProxy(RooSetProxy& proxy) ;
  void registerProxy(RooListProxy& proxy) ;
  void unRegisterProxy(RooArgProxy& proxy) ;
  void unRegisterProxy(RooSetProxy& proxy) ;
  void unRegisterProxy(RooListProxy& proxy) ;
  RooAbsProxy* getProxy(Int_t index) const ;
  void setProxyNormSet(const RooArgSet* nset) ;
  Int_t numProxies() const ;

  // Attribute list
  std::set<std::string> _boolAttrib ; // Boolean attributes
  std::map<std::string,std::string> _stringAttrib ; // String attributes
  std::set<std::string> _boolAttribTransient ; //! Transient boolean attributes (not copied in ctor)

  void printAttribList(std::ostream& os) const;

  // Hooks for RooTreeData interface
  friend class RooCompositeDataStore ;
  friend class RooTreeDataStore ;
  friend class RooVectorDataStore ;
  friend class RooTreeData ;
  friend class RooDataSet ;
  friend class RooRealMPFE ;
  virtual void syncCache(const RooArgSet* nset=0) = 0 ;
  virtual void copyCache(const RooAbsArg* source, Bool_t valueOnly=kFALSE, Bool_t setValDirty=kTRUE) = 0 ;

  virtual void attachToTree(TTree& t, Int_t bufSize=32000) = 0 ;
  virtual void attachToVStore(RooVectorDataStore& vstore) = 0 ;
  void attachToStore(RooAbsDataStore& store) ;

  virtual void setTreeBranchStatus(TTree& t, Bool_t active) = 0 ;
  virtual void fillTreeBranch(TTree& t) = 0 ;
  TString cleanBranchName() const ;

  // Global   
  friend std::ostream& operator<<(std::ostream& os, const RooAbsArg &arg);
  friend std::istream& operator>>(std::istream& is, RooAbsArg &arg) ;

  // Debug stuff
  static Bool_t _verboseDirty ; // Static flag controlling verbose messaging for dirty state changes
  static Bool_t _inhibitDirty ; // Static flag controlling global inhibit of dirty state propagation
  Bool_t _deleteWatch ; //! Delete watch flag 

  static Bool_t inhibitDirty() ;

  // Value and Shape dirty state bits
  void setValueDirty(const RooAbsArg* source) const ;
  void setShapeDirty(const RooAbsArg* source) const ;
  mutable Bool_t _valueDirty ; // Flag set if value needs recalculating because input values modified
  mutable Bool_t _shapeDirty ; // Flag set if value needs recalculating because input shapes modified

  friend class RooRealProxy ;
  mutable OperMode _operMode ; // Dirty state propagation mode
  mutable Bool_t _fast ; // Allow fast access mode in getVal() and proxies

  // Owned components
  RooArgSet* _ownedComponents ; //! Set of owned component

  mutable Bool_t _prohibitServerRedirect ; //! Prohibit server redirects -- Debugging tool

  mutable RooExpensiveObjectCache* _eocache ; // Pointer to global cache manager for any expensive components created by this object

  mutable TNamed* _namePtr ; //! Do not persist. Pointer to global instance of string that matches object named

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 5; } static void Dictionary(); virtual TClass *IsA() const { return RooAbsArg::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooAbsArg::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsArg.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 550; } // Abstract variable
};

std::ostream& operator<<(std::ostream& os, const RooAbsArg &arg);
std::istream& operator>>(std::istream& is, RooAbsArg &arg) ;
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsReal.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCmdArg.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooCmdArg.h,v 1.10 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/




# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/string" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_string" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// string
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/string" 2
}
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCmdArg.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TNamed.h" 1
// @(#)root/base:$Id: TNamed.h 20877 2007-11-19 11:17:07Z rdm $
// Author: Rene Brun   26/12/94

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 22 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCmdArg.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TString.h" 1
// @(#)root/base:$Id: TString.h 43133 2012-02-27 09:50:10Z rdm $
// Author: Fons Rademakers   04/08/95

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 23 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCmdArg.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooLinkedList.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooLinkedList.h,v 1.15 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 24 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCmdArg.h" 2
class RooAbsData ;
class RooArgSet ;

class RooCmdArg : public TNamed {
public:

  RooCmdArg();
  RooCmdArg(const char* name,
     Int_t i1=0, Int_t i2=0,
     Double_t d1=0, Double_t d2=0,
     const char* s1=0, const char* s2=0,
     const TObject* o1=0, const TObject* o2=0, const RooCmdArg* ca=0, const char* s3=0,
     const RooArgSet* c1=0, const RooArgSet* c2=0) ;
  RooCmdArg(const RooCmdArg& other) ;
  RooCmdArg& operator=(const RooCmdArg& other) ;
  void addArg(const RooCmdArg& arg) ;
  void setProcessRecArgs(Bool_t flag, Bool_t prefix=kTRUE) {
    // If true flag this object as containing recursive arguments
    _procSubArgs = flag ;
    _prefixSubArgs = prefix ;
  }

  RooLinkedList& subArgs() {
    // Return list of sub-arguments in this RooCmdArg
    return _argList ;
  }

  virtual TObject* Clone(const char* newName=0) const {
    RooCmdArg* newarg = new RooCmdArg(*this) ;
    if (newName) { newarg->SetName(newName) ; }
    return newarg ;
  }

  virtual ~RooCmdArg();

  static const RooCmdArg& none() ;

  const char* opcode() const {
    // Return operator code
    return strlen(GetName()) ? GetName() : 0 ;
  }

  void setInt(Int_t idx,Int_t value) {
    _i[idx] = value ;
  }
  void setDouble(Int_t idx,Double_t value) {
    _d[idx] = value ;
  }
  void setString(Int_t idx,const char* value) {
    _s[idx] = value ;
  }
  void setObject(Int_t idx,TObject* value) {
    _o[idx] = value ;
  }
  void setSet(Int_t idx,const RooArgSet& set) ;

  Int_t getInt(Int_t idx) const {
    // Return integer stored in slot idx
    return _i[idx] ;
  }
  Double_t getDouble(Int_t idx) const {
    // Return double stored in slot idx
    return _d[idx] ;
  }
  const char* getString(Int_t idx) const {
    // Return string stored in slot idx
      return (_s[idx].size()>0) ? _s[idx].c_str() : 0 ;
  }
  const TObject* getObject(Int_t idx) const {
  // Return TObject stored in slot idx
    return _o[idx] ;
  }

  const RooArgSet* getSet(Int_t idx) const ;

protected:

  static const RooCmdArg _none ; // Static instance of null object
  friend class RooCmdConfig ;

private:

  friend class RooAbsCollection ;

  // Payload
  Double_t _d[2] ; // Payload doubles
  Int_t _i[2] ; // Payload integers
  std::string _s[3] ; // Payload strings
  TObject* _o[2] ; // Payload objects
  Bool_t _procSubArgs ; // If true argument requires recursive processing
  RooArgSet* _c ; // Payload RooArgSets 
  RooLinkedList _argList ; // Payload sub-arguments
  Bool_t _prefixSubArgs ; // Prefix subarguments with container name?

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 2; } static void Dictionary(); virtual TClass *IsA() const { return RooCmdArg::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooCmdArg::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCmdArg.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 118; } // Generic named argument container
};
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsReal.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCurve.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooCurve.h,v 1.24 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TGraph.h" 1
// @(#)root/hist:$Id: TGraph.h 38549 2011-03-21 19:26:04Z pcanal $
// Author: Rene Brun, Olivier Couet   12/12/94

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/





//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TGraph                                                               //
//                                                                      //
// Graph graphics class.                                                //
//                                                                      //
//////////////////////////////////////////////////////////////////////////





# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TAttLine.h" 1
// @(#)root/base:$Id: TAttLine.h 27860 2009-03-18 08:36:17Z brun $
// Author: Rene Brun   28/11/94

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/





//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TAttLine                                                             //
//                                                                      //
// Line attributes.                                                     //
//                                                                      //
//////////////////////////////////////////////////////////////////////////
# 32 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TAttLine.h"
class TAttLine {

protected:
   Color_t fLineColor; //line color
   Style_t fLineStyle; //line style
   Width_t fLineWidth; //line width

public:

   TAttLine();
   TAttLine(Color_t lcolor,Style_t lstyle, Width_t lwidth);
   virtual ~TAttLine();

   void Copy(TAttLine &attline) const;
   Int_t DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2 );
   virtual Color_t GetLineColor() const {return fLineColor;}
   virtual Style_t GetLineStyle() const {return fLineStyle;}
   virtual Width_t GetLineWidth() const {return fLineWidth;}
   virtual void Modify();
   virtual void ResetAttLine(Option_t *option="");
   virtual void SaveLineAttributes(ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1, Int_t widdef=1);
   virtual void SetLineAttributes(); // *MENU*
   virtual void SetLineColor(Color_t lcolor) { fLineColor = lcolor;}
   virtual void SetLineStyle(Style_t lstyle) { fLineStyle = lstyle;}
   virtual void SetLineWidth(Width_t lwidth) { fLineWidth = lwidth;}

   private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return TAttLine::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { TAttLine::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TAttLine.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 58; }; //Line attributes
};

   enum ELineStyle { kSolid = 1, kDashed, kDotted, kDashDotted };
# 29 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TGraph.h" 2


# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TAttFill.h" 1
// @(#)root/base:$Id: TAttFill.h 27860 2009-03-18 08:36:17Z brun $
// Author: Rene Brun   12/12/94

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/





//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TAttFill                                                             //
//                                                                      //
// Fill area attributes.                                                //
//                                                                      //
//////////////////////////////////////////////////////////////////////////
# 32 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TAttFill.h"
class TAttFill {

protected:
   Color_t fFillColor; //fill area color
   Style_t fFillStyle; //fill area style

public:
   TAttFill();
   TAttFill(Color_t fcolor,Style_t fstyle);
   virtual ~TAttFill();
   void Copy(TAttFill &attfill) const;
   virtual Color_t GetFillColor() const { return fFillColor; }
   virtual Style_t GetFillStyle() const { return fFillStyle; }
   virtual Bool_t IsTransparent() const;
   virtual void Modify();
   virtual void ResetAttFill(Option_t *option="");
   virtual void SaveFillAttributes(ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1001);
   virtual void SetFillAttributes(); // *MENU*
   virtual void SetFillColor(Color_t fcolor) { fFillColor = fcolor; }
   virtual void SetFillStyle(Style_t fstyle) { fFillStyle = fstyle; }

   private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return TAttFill::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { TAttFill::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TAttFill.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 53; } //Fill area attributes
};

inline Bool_t TAttFill::IsTransparent() const
{ return fFillStyle >= 4000 && fFillStyle <= 4100 ? kTRUE : kFALSE; }
# 32 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TGraph.h" 2


# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TAttMarker.h" 1
// @(#)root/base:$Id: TAttMarker.h 38648 2011-03-29 08:02:56Z couet $
// Author: Rene Brun   12/05/95

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/





//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TAttMarker                                                           //
//                                                                      //
// Marker attributes.                                                   //
//                                                                      //
//////////////////////////////////////////////////////////////////////////
# 32 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TAttMarker.h"
class TAttMarker {

protected:
   Color_t fMarkerColor; //Marker color index
   Style_t fMarkerStyle; //Marker style
   Size_t fMarkerSize; //Marker size

public:
   TAttMarker();
   TAttMarker(Color_t color, Style_t style, Size_t msize);
   virtual ~TAttMarker();
           void Copy(TAttMarker &attmarker) const;
   virtual Color_t GetMarkerColor() const {return fMarkerColor;}
   virtual Style_t GetMarkerStyle() const {return fMarkerStyle;}
   virtual Size_t GetMarkerSize() const {return fMarkerSize;}
   virtual void Modify();
   virtual void ResetAttMarker(Option_t *toption="");
   virtual void SaveMarkerAttributes(ostream &out, const char *name, Int_t coldef=1, Int_t stydef=1, Int_t sizdef=1);
   virtual void SetMarkerAttributes(); // *MENU*
   virtual void SetMarkerColor(Color_t tcolor=1) { fMarkerColor = tcolor;}
   virtual void SetMarkerStyle(Style_t mstyle=1) { fMarkerStyle = mstyle;}
   virtual void SetMarkerSize(Size_t msize=1) { fMarkerSize = msize;}

   private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 2; } static void Dictionary(); virtual TClass *IsA() const { return TAttMarker::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { TAttMarker::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TAttMarker.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 55; }; //Marker attributes
};

   enum EMarkerStyle {kDot=1, kPlus, kStar, kCircle=4, kMultiply=5,
                      kFullDotSmall=6, kFullDotMedium=7, kFullDotLarge=8,
                      kFullCircle=20, kFullSquare=21, kFullTriangleUp=22,
                      kFullTriangleDown=23, kOpenCircle=24, kOpenSquare=25,
                      kOpenTriangleUp=26, kOpenDiamond=27, kOpenCross=28,
                      kFullStar=29, kOpenStar=30, kOpenTriangleDown=32,
                      kFullDiamond=33, kFullCross=34};
# 35 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TGraph.h" 2


# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TVectorFfwd.h" 1
/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/




//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TVectorF                                                             //
//                                                                      //
//  Forward declaration of TVectorT<Float_t>                            //
//                                                                      //
//////////////////////////////////////////////////////////////////////////





template<class Element> class TVectorT;
typedef TVectorT<Float_t> TVectorF;
# 38 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TGraph.h" 2


# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TVectorDfwd.h" 1
/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/




//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TVectorD                                                             //
//                                                                      //
//  Forward declaration of TVectorT<Double_t>                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////





template<class Element> class TVectorT;
typedef TVectorT<Double_t> TVectorD;
# 41 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TGraph.h" 2


class TBrowser;
class TAxis;
class TH1;
class TH1F;
class TCollection;
class TF1;
class TSpline;

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TFitResultPtr.h" 1
// @(#)root/mathcore:$Id: TFitResultPtr.h 31262 2009-11-18 07:38:37Z brun $
// Author: David Gonzalez Maline Tue Nov 10 15:01:24 2009

/*************************************************************************
 * Copyright (C) 1995-2009, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/




//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TFitResultPtr                                                        //
//                                                                      //
// Provides an indirection to TFitResult class and with a semantics     //
// identical to a TFitResult pointer                                    //
//                                                                      //
//                                                                      //
//////////////////////////////////////////////////////////////////////////





class TFitResult;

class TFitResultPtr {
public:

   TFitResultPtr(int status = -1): fStatus(status), fPointer(0) {};

   TFitResultPtr(TFitResult* p);

   TFitResultPtr(const TFitResultPtr& rhs);

   operator int() const { return fStatus; }

   TFitResult& operator*() const;

   TFitResult* operator->() const;

   TFitResult* Get() const { return fPointer; }

   TFitResultPtr& operator= (const TFitResultPtr& rhs);

   virtual ~TFitResultPtr();

private:

   int fStatus; // fit status code
   TFitResult* fPointer; // Smart Pointer to TFitResult class  

   private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return TFitResultPtr::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { TFitResultPtr::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TFitResultPtr.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 57; } //indirection to TFitResult
};
# 52 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TGraph.h" 2

class TGraph : public TNamed, public TAttLine, public TAttFill, public TAttMarker {

protected:

   Int_t fMaxSize; //!Current dimension of arrays fX and fY
   Int_t fNpoints; //Number of points <= fMaxSize
   Double_t *fX; //[fNpoints] array of X points
   Double_t *fY; //[fNpoints] array of Y points
   TList *fFunctions; //Pointer to list of functions (fits and user)
   TH1F *fHistogram; //Pointer to histogram used for drawing axis
   Double_t fMinimum; //Minimum value for plotting along y
   Double_t fMaximum; //Maximum value for plotting along y

   static void SwapValues(Double_t* arr, Int_t pos1, Int_t pos2);
   virtual void SwapPoints(Int_t pos1, Int_t pos2);

   virtual Double_t **Allocate(Int_t newsize);
   Double_t **AllocateArrays(Int_t Narrays, Int_t arraySize);
   virtual Bool_t CopyPoints(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin);
   virtual void CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin);
   Bool_t CtorAllocate();
   Double_t **ExpandAndCopy(Int_t size, Int_t iend);
   virtual void FillZero(Int_t begin, Int_t end, Bool_t from_ctor = kTRUE);
   Double_t **ShrinkAndCopy(Int_t size, Int_t iend);

public:
   // TGraph status bits
   enum {
      kClipFrame = (1ULL << (10)), // clip to the frame boundary
      kNotEditable = (1ULL << (18)) // bit set if graph is non editable
   };

   TGraph();
   TGraph(Int_t n);
   TGraph(Int_t n, const Int_t *x, const Int_t *y);
   TGraph(Int_t n, const Float_t *x, const Float_t *y);
   TGraph(Int_t n, const Double_t *x, const Double_t *y);
   TGraph(const TGraph &gr);
   TGraph& operator=(const TGraph&);
   TGraph(const TVectorF &vx, const TVectorF &vy);
   TGraph(const TVectorD &vx, const TVectorD &vy);
   TGraph(const TH1 *h);
   TGraph(const TF1 *f, Option_t *option="");
   TGraph(const char *filename, const char *format="%lg %lg", Option_t *option="");
   virtual ~TGraph();

   virtual void Apply(TF1 *f);
   virtual void Browse(TBrowser *b);
   virtual Double_t Chisquare(const TF1 *f1) const;
   static Bool_t CompareArg(const TGraph* gr, Int_t left, Int_t right);
   static Bool_t CompareX(const TGraph* gr, Int_t left, Int_t right);
   static Bool_t CompareY(const TGraph* gr, Int_t left, Int_t right);
   static Bool_t CompareRadius(const TGraph* gr, Int_t left, Int_t right);
   virtual void ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const;
   virtual Int_t DistancetoPrimitive(Int_t px, Int_t py);
   virtual void Draw(Option_t *chopt="");
   virtual void DrawGraph(Int_t n, const Int_t *x, const Int_t *y, Option_t *option="");
   virtual void DrawGraph(Int_t n, const Float_t *x, const Float_t *y, Option_t *option="");
   virtual void DrawGraph(Int_t n, const Double_t *x=0, const Double_t *y=0, Option_t *option="");
   virtual void DrawPanel(); // *MENU*
   virtual Double_t Eval(Double_t x, TSpline *spline=0, Option_t *option="") const;
   virtual void ExecuteEvent(Int_t event, Int_t px, Int_t py);
   virtual void Expand(Int_t newsize);
   virtual void Expand(Int_t newsize, Int_t step);
   virtual TObject *FindObject(const char *name) const;
   virtual TObject *FindObject(const TObject *obj) const;
   virtual TFitResultPtr Fit(const char *formula ,Option_t *option="" ,Option_t *goption="", Axis_t xmin=0, Axis_t xmax=0); // *MENU*
   virtual TFitResultPtr Fit(TF1 *f1 ,Option_t *option="" ,Option_t *goption="", Axis_t xmin=0, Axis_t xmax=0);
   virtual void FitPanel(); // *MENU*
   Bool_t GetEditable() const;
   TF1 *GetFunction(const char *name) const;
   TH1F *GetHistogram() const;
   TList *GetListOfFunctions() const { return fFunctions; }
   virtual Double_t GetCorrelationFactor() const;
   virtual Double_t GetCovariance() const;
   virtual Double_t GetMean(Int_t axis=1) const;
   virtual Double_t GetRMS(Int_t axis=1) const;
   Int_t GetMaxSize() const {return fMaxSize;}
   Int_t GetN() const {return fNpoints;}
   virtual Double_t GetErrorX(Int_t bin) const;
   virtual Double_t GetErrorY(Int_t bin) const;
   virtual Double_t GetErrorXhigh(Int_t bin) const;
   virtual Double_t GetErrorXlow(Int_t bin) const;
   virtual Double_t GetErrorYhigh(Int_t bin) const;
   virtual Double_t GetErrorYlow(Int_t bin) const;
   Double_t *GetX() const {return fX;}
   Double_t *GetY() const {return fY;}
   virtual Double_t *GetEX() const {return 0;}
   virtual Double_t *GetEY() const {return 0;}
   virtual Double_t *GetEXhigh() const {return 0;}
   virtual Double_t *GetEXlow() const {return 0;}
   virtual Double_t *GetEYhigh() const {return 0;}
   virtual Double_t *GetEYlow() const {return 0;}
   virtual Double_t *GetEXlowd() const {return 0;}
   virtual Double_t *GetEXhighd() const {return 0;}
   virtual Double_t *GetEYlowd() const {return 0;}
   virtual Double_t *GetEYhighd() const {return 0;}
   Double_t GetMaximum() const {return fMaximum;}
   Double_t GetMinimum() const {return fMinimum;}
   TAxis *GetXaxis() const ;
   TAxis *GetYaxis() const ;
   virtual Int_t GetPoint(Int_t i, Double_t &x, Double_t &y) const;

   virtual void InitExpo(Double_t xmin=0, Double_t xmax=0);
   virtual void InitGaus(Double_t xmin=0, Double_t xmax=0);
   virtual void InitPolynom(Double_t xmin=0, Double_t xmax=0);
   virtual Int_t InsertPoint(); // *MENU*
   virtual Double_t Integral(Int_t first=0, Int_t last=-1) const;
   virtual Bool_t IsEditable() const {return !TestBit(kNotEditable);}
   virtual Int_t IsInside(Double_t x, Double_t y) const;
   virtual void LeastSquareFit(Int_t m, Double_t *a, Double_t xmin=0, Double_t xmax=0);
   virtual void LeastSquareLinearFit(Int_t n, Double_t &a0, Double_t &a1, Int_t &ifail, Double_t xmin=0, Double_t xmax=0);
   virtual Int_t Merge(TCollection* list);
   virtual void Paint(Option_t *chopt="");
   void PaintGraph(Int_t npoints, const Double_t *x, const Double_t *y, Option_t *chopt);
   void PaintGrapHist(Int_t npoints, const Double_t *x, const Double_t *y, Option_t *chopt);
   virtual void PaintStats(TF1 *fit);
   virtual void Print(Option_t *chopt="") const;
   virtual void RecursiveRemove(TObject *obj);
   virtual Int_t RemovePoint(); // *MENU*
   virtual Int_t RemovePoint(Int_t ipoint);
   virtual void SavePrimitive(ostream &out, Option_t *option = "");
   virtual void SetEditable(Bool_t editable=kTRUE); // *TOGGLE* *GETTER=GetEditable
   virtual void SetHistogram(TH1F *h) {fHistogram = h;}
   virtual void SetMaximum(Double_t maximum=-1111); // *MENU*
   virtual void SetMinimum(Double_t minimum=-1111); // *MENU*
   virtual void Set(Int_t n);
   virtual void SetPoint(Int_t i, Double_t x, Double_t y);
   virtual void SetTitle(const char *title=""); // *MENU*
   virtual void Sort(Bool_t (*greater)(const TGraph*, Int_t, Int_t)=&TGraph::CompareX,
                              Bool_t ascending=kTRUE, Int_t low=0, Int_t high=-1111);
   virtual void UseCurrentStyle();
   void Zero(Int_t &k,Double_t AZ,Double_t BZ,Double_t E2,Double_t &X,Double_t &Y,Int_t maxiterations);

   private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 4; } static void Dictionary(); virtual TClass *IsA() const { return TGraph::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { TGraph::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TGraph.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 187; } //Graph graphics class
};

inline Double_t **TGraph::Allocate(Int_t newsize) {
   return AllocateArrays(2, newsize);
}
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCurve.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooPlotable.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooPlotable.h,v 1.14 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h" 1
/* @(#)root/base:$Id: Rtypes.h 43708 2012-04-12 10:19:00Z axel $ */

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooPlotable.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TString.h" 1
// @(#)root/base:$Id: TString.h 43133 2012-02-27 09:50:10Z rdm $
// Author: Fons Rademakers   04/08/95

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooPlotable.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooPrintable.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooPrintable.h,v 1.12 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 22 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooPlotable.h" 2

class TObject;
class RooArgSet;

class RooPlotable : public RooPrintable {
public:
  inline RooPlotable() : _ymin(0), _ymax(0), _normValue(0) { }
  inline virtual ~RooPlotable() { }

  inline const char* getYAxisLabel() const { return _yAxisLabel.Data(); }
  inline void setYAxisLabel(const char *label) { _yAxisLabel= label; }
  inline void updateYAxisLimits(Double_t y) {
    if(y > _ymax) _ymax= y;
    if(y < _ymin) _ymin= y;
  }
  inline void setYAxisLimits(Double_t ymin, Double_t ymax) {
    _ymin = ymin ;
    _ymax = ymax ;
  }
  inline Double_t getYAxisMin() const { return _ymin; }
  inline Double_t getYAxisMax() const { return _ymax; }

  // the normalization value refers to the full "fit range" instead of
  // the "plot range"
  virtual Double_t getFitRangeNEvt() const = 0;
  virtual Double_t getFitRangeNEvt(Double_t xlo, Double_t xhi) const = 0;
  virtual Double_t getFitRangeBinW() const = 0;

  virtual void printMultiline(std::ostream& os, Int_t contents, Bool_t verbose=kFALSE, TString indent= "") const;

  TObject *crossCast();
protected:
  TString _yAxisLabel;
  Double_t _ymin, _ymax, _normValue;
  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return RooPlotable::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooPlotable::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooPlotable.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 56; } // Abstract interface for plotable objects in a RooPlot
};
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCurve.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/list" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_list" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <list.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/list

#pragma ifndef PREC_STL_LIST
#pragma define PREC_STL_LIST
#pragma link off global PREC_STL_LIST;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from ANSI/ISO C++ 1997/Nov draft 
// Got some ideas from Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <iterator.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/iterator

#pragma ifndef PREC_STL_ITERATOR
#pragma define PREC_STL_ITERATOR
#pragma link off global PREC_STL_ITERATOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from STL HP implementation 1994
// Imported from STL SGI implementation 1997 
// Imported from ANSI/ISO C++ draft Nov 1997
// Modified by Masaharu Goto
// May need improvement for the latest standard


////////////////////////////////////////////////////////////////////////
// iterator_tag
////////////////////////////////////////////////////////////////////////
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag {};
struct bidirectional_iterator_tag {};
struct random_access_iterator_tag {};

////////////////////////////////////////////////////////////////////////
// iterator template
////////////////////////////////////////////////////////////////////////
template <class T, class Distance> struct input_iterator {};
struct output_iterator {};
template <class T, class Distance> struct forward_iterator {};
template <class T, class Distance> struct bidirectional_iterator {};
template <class T, class Distance> struct random_access_iterator {};

#pragma link off class output_iterator;







////////////////////////////////////////////////////////////////////////
// iterator_category overloaded function
////////////////////////////////////////////////////////////////////////
template <class T, class Distance>
inline input_iterator_tag
iterator_category(const input_iterator<T, Distance>&) {
    return input_iterator_tag();
}

inline output_iterator_tag iterator_category(const output_iterator&) {
    return output_iterator_tag();
}

#pragma link off function iterator_category(const output_iterator&);


template <class T, class Distance>
inline forward_iterator_tag
iterator_category(const forward_iterator<T, Distance>&) {
    return forward_iterator_tag();
}

template <class T, class Distance>
inline bidirectional_iterator_tag
iterator_category(const bidirectional_iterator<T, Distance>&) {
    return bidirectional_iterator_tag();
}

template <class T, class Distance>
inline random_access_iterator_tag
iterator_category(const random_access_iterator<T, Distance>&) {
    return random_access_iterator_tag();
}

template <class T>
inline random_access_iterator_tag
iterator_category(const T*) {
    return random_access_iterator_tag();
}


// iterator_traits, iterator and reverse_iterator template may not be
// needed for precompiled library interface 

////////////////////////////////////////////////////////////////////////
// iterator_traits
////////////////////////////////////////////////////////////////////////

template <class Iterator>
struct iterator_traits {
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type value_type;
  typedef typename Iterator::difference_type difference_type;
  typedef typename Iterator::pointer pointer;
  typedef typename Iterator::reference reference;
};

// template partial specialization, implement in cint5.15.14 1587
template <class T>
struct iterator_traits<T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
};

// incomplete implementation in cint5.15.14 1587, need some fix
// iterator_traits<const int*> is changed as iterator_traits<const int* const>
// or something, but cint5.15.14 can not handle this well
template <class T>
struct iterator_traits<const T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef const T* pointer;
  typedef const T& reference;
};

////////////////////////////////////////////////////////////////////////
// iterator
////////////////////////////////////////////////////////////////////////
template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator {
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
  typedef Category iterator_category;
};


////////////////////////////////////////////////////////////////////////
// reverse_iterator
////////////////////////////////////////////////////////////////////////






template <class Iterator>
class reverse_iterator
# 166 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
{




 public:
# 181 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
   typedef Iterator::pointer pointer;
   typedef Iterator::reference reference;
   typedef ptrdiff_t difference_type;


   reverse_iterator();
   //reverse_iterator(Iterator x);



   Iterator base() const; // explicit
   reference operator*() const;
   pointer operator->() const;
   reverse_iterator& operator++();
   reverse_iterator operator++(int);
   reverse_iterator& operator--();
   reverse_iterator operator--(int);
   reverse_iterator operator+ (difference_type n) const;
   reverse_iterator& operator+=(difference_type n);
   reverse_iterator operator- (difference_type n) const;
   reverse_iterator& operator-=(difference_type n);
   reference operator[](difference_type n) const;
};
# 932 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
// for g++ 3.1,3.2
namespace __gnu_cxx
{
  // This iterator adapter is 'normal' in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                    difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparaison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  // _GLIBCPP_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
     const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
} // namespace __gnu_cxx







#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 2
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <memory.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/memory

#pragma ifndef PREC_STL_MEMORY
#pragma define PREC_STL_MEMORY
#pragma link off global PREC_STL_MEMORY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////


template <class _Tp>
class allocator {
  //typedef alloc _Alloc;          // The underlying allocator.
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  typedef typename _Tp* pointer;
  typedef const typename _Tp * const_pointer;




  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() ;
  allocator(const allocator&) ;
  //template <class _Tp1> allocator(const allocator<_Tp1>&) ;
  ~allocator() ;

  pointer address(reference __x) const ;
  const_pointer address(const_reference __x) const ;

  // __n is permitted to be 0.  The C++ standard says nothing about what
  // the return value is when __n == 0.
  _Tp* allocate(size_type __n, const void* = 0) ;

  // __p is not permitted to be a null pointer.
  void deallocate(pointer __p, size_type __n);

  size_type max_size() const ;

  void construct(pointer __p, const _Tp& __val) ;
  void destroy(pointer __p) ;
};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;
  typedef void value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };
};
//////////////////////////////////////////////////////////////////////
# 205 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////

/**********************************************************************
* auto_ptr
**********************************************************************/
template <class X> class auto_ptr {
private:
  X* ptr;
  //template<class Y> struct auto_ptr_ref { };
public:
  typedef X element_type;
  explicit auto_ptr(X* p = 0) : ptr(p) {}
  auto_ptr(auto_ptr& a) {ptr=a.ptr;}

  // this implementation may not be correct
  template <class T> auto_ptr(auto_ptr<T>& a) {ptr=a.release();}
# 229 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  auto_ptr& operator=(auto_ptr& a) {
    if (a.ptr != ptr) {
      delete ptr;
      ptr = a.ptr;
    }
    return(*this);
  }

  // this implementation may not be correct
  template <class T> auto_ptr& operator=(auto_ptr<T>& a) {
    if (a.ptr != ptr) {
       delete ptr;
       ptr = a.release();
    }
    return(*this);
  }

  ~auto_ptr() { delete ptr; }

  X& operator*() const { return *ptr; }
  X* operator->() const { return ptr; }
  X* get() const { return ptr; }
  X* release() { X *old = ptr; ptr = 0; return 0; }
# 262 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  // auto_ptr conversions
  //auto_ptr(auto_ptr_ref<X>& x) { }
  //template<class Y> operator auto_ptr_ref<Y>() { return auto_ptr_ref<Y>(); }
  //template<class Y> operator auto_ptr<Y>() { return auto_ptr<T>(); }
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 2
# 28 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list" 2


template<class T,class Allocator=std::allocator<T> >
# 44 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
class list {
 public:
  typedef T value_type;
  typedef Allocator allocator_type;

  typedef void* void_pointer;
  //typedef __list_node<T> list_node;
  //typedef simple_alloc<list_node, Alloc> list_node_allocator;
  //typedef list_node* link_type;
  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
# 68 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
  class iterator
# 84 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
 {
   public:
    iterator() ;
    iterator(const iterator& x) ;

    iterator& operator=(const iterator& x) ;

    T& operator*() const ;

    T* operator->() const ;

    iterator& operator++();
    iterator operator++(int a);
    iterator& operator--();
    iterator operator--(int a);
    bool operator==(const iterator& x) ;

    bool operator!=(const iterator& x) ;





  };







  class reverse_iterator
# 131 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
 {
   public:
    reverse_iterator(const reverse_iterator& x) ;

    reverse_iterator& operator=(const reverse_iterator& x) ;

    T& operator*() const ;

    T* operator->() const ;

    reverse_iterator& operator++();
    reverse_iterator operator++(int a);
    reverse_iterator& operator--();
    reverse_iterator operator--(int a);




  };

  friend bool operator==(const list::reverse_iterator& x
                        ,const list::reverse_iterator& y) const;
  friend bool operator!=(const list::reverse_iterator& x
                        ,const list::reverse_iterator& y) const;

  typedef const iterator const_iterator;
  typedef const reverse_iterator const_reverse_iterator;
# 168 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
  list() ;
  iterator begin() ;
  iterator end() ;
  reverse_iterator rbegin() ;
  reverse_iterator rend() ;






  bool empty() const ;
  size_type size() const ;
  size_type max_size() const ;
  T& front() const ;
  T& back() const ;
  void swap(list& x) ;
  iterator insert(iterator position,const T& x);
  void insert(iterator position,T* first,T* last);
  void insert(iterator position,iterator first,iterator last);
  void insert(iterator position,size_type n,const T& x);
  void push_front(const T& x);
  void push_back(const T& x);
  void resize(size_type n);
  void resize(size_type n, T v);
  void erase(iterator position);
  void erase(iterator first,iterator last);
  void clear() ;
  void pop_front();
  void pop_back();
  list(size_type n,const T& value=T()) ;






  list(const T* first,const T* last) ;

  list(const_iterator first, const_iterator last) ;

  list(const list& x) ;
  ~list() ;
  list& operator=(const list& x) ;
  void splice(iterator position,list& x);
  void splice(iterator position,list& x,iterator i);
  void splice(iterator position,list& x,iterator first,iterator last);
  void remove(const T& value);
  void unique();
  void merge(list& x);
  void reverse();
  void sort();

  friend bool operator==(const list& x, const list& y);
  friend bool operator< (const list& x, const list& y);
  friend bool operator!=(const list& x, const list& y);
  friend bool operator> (const list& x, const list& y);
  friend bool operator>=(const list& x, const list& y);
  friend bool operator<=(const list& x, const list& y);

  // specialized algorithms:





#pragma ifndef G__NOALGORITHM
  // Generic algorithm


  // input iter
  friend list::iterator
    find(list::iterator first,list::iterator last,const T& value);
  // forward iter
  friend list::iterator
    find_end(list::iterator first1,list::iterator last1,
      list::iterator first2,list::iterator last2);
  friend list::iterator
    find_first_of(list::iterator first1,list::iterator last1,
           list::iterator first2,list::iterator last2);
  friend list::iterator
    adjacent_find(list::iterator first,list::iterator last);
  // input iter

  friend list::difference_type
    count(list::iterator first,list::iterator last,const T& value);






  friend bool
    equal(list::iterator first1,list::iterator last1,
          list::iterator first2);
  // forward iter
  friend list::iterator
    search(list::iterator first1,list::iterator last1,
           list::iterator first2,list::iterator last2);
  friend list::iterator
    search_n(list::iterator first,list::iterator last
             ,list::size_type count,const T& value);
  // input and output iter -> forward iter
  friend list::iterator
    copy(list::iterator first,list::iterator last,
         list::iterator result);
  // bidirectional iter
  friend list::iterator
    copy_backward(list::iterator first,list::iterator last,
                  list::iterator result);
  // just value_type
  friend void swap(T& a,T& b);
  // forward iter
  friend list::iterator
    swap_ranges(list::iterator first1,list::iterator last1,
                list::iterator first2);
  friend void iter_swap(list::iterator a,list::iterator b);
  friend void replace(list::iterator first,list::iterator last,
                      const T& old_value,const T& new_value);
  // input, output iter -> forward iter
  friend list::iterator
    replace_copy(list::iterator first,list::iterator last,
                 list::iterator result,
                 const T& old_value,const T& new_value);
  // forward iter
  friend void
    fill(list::iterator first,list::iterator last,const T& value);

  friend void
    fill_n(list::iterator first,list::size_type n,const T& value);

  friend list::iterator
    remove(list::iterator first,list::iterator last,const T& value);
  // input,output iter -> forward iter
  friend list::iterator
    remove_copy(list::iterator first,list::iterator last,
                list::iterator result,const T& value);
  friend list::iterator
    unique(list::iterator first,list::iterator last);
  friend list::iterator
    unique_copy(list::iterator first,list::iterator last,
                list::iterator result);
  friend void reverse(list::iterator first,list::iterator last);
  friend list::iterator
     reverse_copy(list::iterator first,list::iterator last,
                  list::iterator result);
  // forward iter
  friend void rotate(list::iterator first,list::iterator mid,
                     list::iterator last);
  // forward iter
  friend list::iterator
    rotate_copy(list::iterator first,list::iterator mid,
                list::iterator last,list::iterator result);
# 336 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
  // forward iter
  friend list::iterator
    lower_bound(list::iterator first,list::iterator last,const T& value);
  friend list::iterator
    upper_bound(list::iterator first,list::iterator last,const T& value);




  friend bool binary_search(list::iterator first,list::iterator last,
                            const T& value);
  friend list::iterator merge(list::iterator first1,list::iterator last1,
                                list::iterator first2,list::iterator last2,
                                list::iterator result);
  friend void inplace_merge(list::iterator first,list::iterator middle,
                            list::iterator last);
  friend bool includes(list::iterator first1,list::iterator last1,
                       list::iterator first2,list::iterator last2);
  friend list::iterator
    set_union(list::iterator first1,list::iterator last1,
              list::iterator first2,list::iterator last2,
              list::iterator result);
  friend list::iterator
    set_intersection(list::iterator first1,list::iterator last1,
                     list::iterator first2,list::iterator last2,
                     list::iterator result);
  friend list::iterator
    set_difference(list::iterator first1,list::iterator last1,
                   list::iterator first2,list::iterator last2,
                   list::iterator result);
  friend list::iterator
    set_symmetric_difference(list::iterator first1,list::iterator last1,
                             list::iterator first2,list::iterator last2,
                             list::iterator result);







  // min,max, just value_type
  friend const T& min(const T& a,const T& b);
  friend const T& max(const T& a,const T& b);
  // forward iter
  friend list::iterator
    min_element(list::iterator first,list::iterator last);
  friend list::iterator
    max_element(list::iterator first,list::iterator last);
  // input iter
  friend bool
    lexicographical_compare(list::iterator first1,list::iterator last1,
                            list::iterator first2,list::iterator last2);
  // bidirectional iter
  friend bool next_permutation(list::iterator first,list::iterator last);
  friend bool prev_permutation(list::iterator first,list::iterator last);
# 417 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
#pragma endif

  // Generic algorithm
  //friend void reverse(list::iterator first,list::iterator last);
  //friend void reverse(list::reverse_iterator first,list::reverse_itetator last);


  // iterator_category resolution
  //friend bidirectional_iterator_tag iterator_category(list::iterator x);
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_list" 2
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/list" 2
}
# 22 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCurve.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/vector" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_vector" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <vector.dll>
#pragma include_noerr <vectorbool.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/vector

#pragma ifndef PREC_STL_VECTOR
#pragma define PREC_STL_VECTOR
#pragma link off global PREC_STL_VECTOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from ANSI/ISO C++ 1997/Nov draft 
// Got some ideas from Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <iterator.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/iterator

#pragma ifndef PREC_STL_ITERATOR
#pragma define PREC_STL_ITERATOR
#pragma link off global PREC_STL_ITERATOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from STL HP implementation 1994
// Imported from STL SGI implementation 1997 
// Imported from ANSI/ISO C++ draft Nov 1997
// Modified by Masaharu Goto
// May need improvement for the latest standard


////////////////////////////////////////////////////////////////////////
// iterator_tag
////////////////////////////////////////////////////////////////////////
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag {};
struct bidirectional_iterator_tag {};
struct random_access_iterator_tag {};

////////////////////////////////////////////////////////////////////////
// iterator template
////////////////////////////////////////////////////////////////////////
template <class T, class Distance> struct input_iterator {};
struct output_iterator {};
template <class T, class Distance> struct forward_iterator {};
template <class T, class Distance> struct bidirectional_iterator {};
template <class T, class Distance> struct random_access_iterator {};

#pragma link off class output_iterator;







////////////////////////////////////////////////////////////////////////
// iterator_category overloaded function
////////////////////////////////////////////////////////////////////////
template <class T, class Distance>
inline input_iterator_tag
iterator_category(const input_iterator<T, Distance>&) {
    return input_iterator_tag();
}

inline output_iterator_tag iterator_category(const output_iterator&) {
    return output_iterator_tag();
}

#pragma link off function iterator_category(const output_iterator&);


template <class T, class Distance>
inline forward_iterator_tag
iterator_category(const forward_iterator<T, Distance>&) {
    return forward_iterator_tag();
}

template <class T, class Distance>
inline bidirectional_iterator_tag
iterator_category(const bidirectional_iterator<T, Distance>&) {
    return bidirectional_iterator_tag();
}

template <class T, class Distance>
inline random_access_iterator_tag
iterator_category(const random_access_iterator<T, Distance>&) {
    return random_access_iterator_tag();
}

template <class T>
inline random_access_iterator_tag
iterator_category(const T*) {
    return random_access_iterator_tag();
}


// iterator_traits, iterator and reverse_iterator template may not be
// needed for precompiled library interface 

////////////////////////////////////////////////////////////////////////
// iterator_traits
////////////////////////////////////////////////////////////////////////

template <class Iterator>
struct iterator_traits {
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type value_type;
  typedef typename Iterator::difference_type difference_type;
  typedef typename Iterator::pointer pointer;
  typedef typename Iterator::reference reference;
};

// template partial specialization, implement in cint5.15.14 1587
template <class T>
struct iterator_traits<T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
};

// incomplete implementation in cint5.15.14 1587, need some fix
// iterator_traits<const int*> is changed as iterator_traits<const int* const>
// or something, but cint5.15.14 can not handle this well
template <class T>
struct iterator_traits<const T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef const T* pointer;
  typedef const T& reference;
};

////////////////////////////////////////////////////////////////////////
// iterator
////////////////////////////////////////////////////////////////////////
template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator {
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
  typedef Category iterator_category;
};


////////////////////////////////////////////////////////////////////////
// reverse_iterator
////////////////////////////////////////////////////////////////////////






template <class Iterator>
class reverse_iterator
# 166 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
{




 public:
# 181 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
   typedef Iterator::pointer pointer;
   typedef Iterator::reference reference;
   typedef ptrdiff_t difference_type;


   reverse_iterator();
   //reverse_iterator(Iterator x);



   Iterator base() const; // explicit
   reference operator*() const;
   pointer operator->() const;
   reverse_iterator& operator++();
   reverse_iterator operator++(int);
   reverse_iterator& operator--();
   reverse_iterator operator--(int);
   reverse_iterator operator+ (difference_type n) const;
   reverse_iterator& operator+=(difference_type n);
   reverse_iterator operator- (difference_type n) const;
   reverse_iterator& operator-=(difference_type n);
   reference operator[](difference_type n) const;
};
# 932 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
// for g++ 3.1,3.2
namespace __gnu_cxx
{
  // This iterator adapter is 'normal' in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                    difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparaison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  // _GLIBCPP_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
     const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
} // namespace __gnu_cxx







#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 2
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <memory.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/memory

#pragma ifndef PREC_STL_MEMORY
#pragma define PREC_STL_MEMORY
#pragma link off global PREC_STL_MEMORY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////


template <class _Tp>
class allocator {
  //typedef alloc _Alloc;          // The underlying allocator.
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  typedef typename _Tp* pointer;
  typedef const typename _Tp * const_pointer;




  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() ;
  allocator(const allocator&) ;
  //template <class _Tp1> allocator(const allocator<_Tp1>&) ;
  ~allocator() ;

  pointer address(reference __x) const ;
  const_pointer address(const_reference __x) const ;

  // __n is permitted to be 0.  The C++ standard says nothing about what
  // the return value is when __n == 0.
  _Tp* allocate(size_type __n, const void* = 0) ;

  // __p is not permitted to be a null pointer.
  void deallocate(pointer __p, size_type __n);

  size_type max_size() const ;

  void construct(pointer __p, const _Tp& __val) ;
  void destroy(pointer __p) ;
};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;
  typedef void value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };
};
//////////////////////////////////////////////////////////////////////
# 205 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////

/**********************************************************************
* auto_ptr
**********************************************************************/
template <class X> class auto_ptr {
private:
  X* ptr;
  //template<class Y> struct auto_ptr_ref { };
public:
  typedef X element_type;
  explicit auto_ptr(X* p = 0) : ptr(p) {}
  auto_ptr(auto_ptr& a) {ptr=a.ptr;}

  // this implementation may not be correct
  template <class T> auto_ptr(auto_ptr<T>& a) {ptr=a.release();}
# 229 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  auto_ptr& operator=(auto_ptr& a) {
    if (a.ptr != ptr) {
      delete ptr;
      ptr = a.ptr;
    }
    return(*this);
  }

  // this implementation may not be correct
  template <class T> auto_ptr& operator=(auto_ptr<T>& a) {
    if (a.ptr != ptr) {
       delete ptr;
       ptr = a.release();
    }
    return(*this);
  }

  ~auto_ptr() { delete ptr; }

  X& operator*() const { return *ptr; }
  X* operator->() const { return ptr; }
  X* get() const { return ptr; }
  X* release() { X *old = ptr; ptr = 0; return 0; }
# 262 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  // auto_ptr conversions
  //auto_ptr(auto_ptr_ref<X>& x) { }
  //template<class Y> operator auto_ptr_ref<Y>() { return auto_ptr_ref<Y>(); }
  //template<class Y> operator auto_ptr<Y>() { return auto_ptr<T>(); }
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 2
# 28 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <utility.dll>


#pragma include_noerr <pair.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/utility

#pragma ifndef PREC_STL_UTILITY
#pragma define PREC_STL_UTILITY
#pragma link off global PREC_STL_UTILITY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

template <class T1, class T2>
struct pair {
  T1 first;
  T2 second;
  pair() : first(T1()), second(T2()) {}
  pair(const T1& a, const T2& b) : first(a), second(b) {}
 private:
  pair& operator=(const pair& x){first=x.first;second=x.second;return *this;}
};

#pragma endif
# 17 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 2
# 29 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector" 2
# 37 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
template<class T,class Allocator=std::allocator<T> >
# 49 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
class vector {
 public:
  typedef T value_type;


  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
# 218 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
  class iterator {
   public:
     typedef vector::pointer pointer;
     typedef vector::const_pointer const_pointer;
     typedef vector::reference reference;
     typedef vector::const_reference const_reference;
     typedef vector::size_type size_type;
     typedef vector::difference_type difference_type;

      iterator();
      explicit iterator(const pointer& __i) ;
      // Allow iterator to const_iterator conversion
      template<typename _Iter> inline iterator(const iterator& __i);

      // Forward iterator requirements
      reference operator*() const ;
      pointer operator->() const ;
      iterator& operator++();
      iterator operator++(int) ;

      // Bidirectional iterator requirements
      iterator& operator--() ;
      iterator operator--(int) ;

      // Random access iterator requirements
      reference operator[](const difference_type& __n) const;
      iterator& operator+=(const difference_type& __n);
      iterator operator+(const difference_type& __n) const;
      iterator& operator-=(const difference_type& __n);
      iterator operator-(const difference_type& __n) const;
      const pointer& base() const ;

      iterator operator=(const iterator& x) ;

  };

  friend bool operator==(const vector::iterator& x,const vector::iterator& y)const;
  friend bool operator!=(const vector::iterator& x,const vector::iterator& y)const;
  friend bool operator<(const vector::iterator& x,const vector::iterator& y)const;
  friend bool operator>(const vector::iterator& x,const vector::iterator& y)const;
  friend bool operator<=(const vector::iterator& x,const vector::iterator& y)const;
  friend bool operator>=(const vector::iterator& x,const vector::iterator& y)const;
  friend vector::iterator::difference_type operator-(const vector::iterator& x,const vector::iterator& y)const;
  friend vector::iterator operator+(const vector::iterator::difference_type x,const vector::iterator& y)const;

  typedef const iterator const_iterator;
# 355 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
  typedef reverse_iterator<const_iterator> const_reverse_iterator;
  typedef reverse_iterator<iterator> reverse_iterator;
# 398 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
  friend bool operator==(const vector::reverse_iterator& x
                        ,const vector::reverse_iterator& y) const;
  friend bool operator!=(const vector::reverse_iterator& x
                        ,const vector::reverse_iterator& y) const;






  friend bool operator==(vector::const_iterator& x
                        ,vector::const_iterator& y) const;
  friend bool operator!=(vector::const_iterator& x
                        ,vector::const_iterator& y) const;
# 422 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
  reference at(size_type n);
  const_reference at(size_type n) const;

  iterator begin(void) ;
  iterator end(void) ;
  reverse_iterator rbegin(void) ;
  reverse_iterator rend(void) ;






  size_type size(void) const ;
  size_type max_size(void) const ;
  void resize(size_type sz) ;
  void resize(size_type sz, T c) ;
  size_type capacity(void) const ;
  bool empty(void) const ;
  reference operator[](size_type n) ;
  const_reference operator[](size_type n) const;
  vector(void) ;
  vector(size_type n,const T& value=T()) ;
  vector(const vector& x) ;
  vector(const_iterator first,const_iterator last) ;
  ~vector(void) ;
  vector& operator=(const vector& x);
  void reserve(size_type n) ;
  T& front(void) ;
  T& back(void) ;
  void push_back(const T& x) ;
  void swap(vector& x);
  iterator insert(iterator position,const T& x);
  void insert(iterator position,const_iterator first,const_iterator last);
  void insert(iterator position,size_type n,const T& x);
  void pop_back(void) ;
  void erase(iterator position) ;
  void erase(iterator first,iterator last) ;
  void clear() ;


  friend bool operator==(const vector& x, const vector& y);
  friend bool operator< (const vector& x, const vector& y);
  friend bool operator!=(const vector& x, const vector& y);
  friend bool operator> (const vector& x, const vector& y);
  friend bool operator>=(const vector& x, const vector& y);
  friend bool operator<=(const vector& x, const vector& y);



  // specialized algorithms:






#pragma ifndef G__NOALGORITHM

  // Generic algorithm


  // input iter
  friend vector::iterator
    find(vector::iterator first,vector::iterator last,const T& value);
  // forward iter
  friend vector::iterator
    find_end(vector::iterator first1,vector::iterator last1,
      vector::iterator first2,vector::iterator last2);
  friend vector::iterator
    find_first_of(vector::iterator first1,vector::iterator last1,
           vector::iterator first2,vector::iterator last2);
  friend vector::iterator
    adjacent_find(vector::iterator first,vector::iterator last);
  // input iter

  friend vector::difference_type
    count(vector::iterator first,vector::iterator last,const T& value);






  friend bool
    equal(vector::iterator first1,vector::iterator last1,
          vector::iterator first2);
  // forward iter
  friend vector::iterator
    search(vector::iterator first1,vector::iterator last1,
           vector::iterator first2,vector::iterator last2);
  friend vector::iterator
    search_n(vector::iterator first,vector::iterator last
             ,vector::size_type count,const T& value);
  // input and output iter -> forward iter
  friend vector::iterator
    copy(vector::iterator first,vector::iterator last,
         vector::iterator result);
  // bidirectional iter
  friend vector::iterator
    copy_backward(vector::iterator first,vector::iterator last,
                  vector::iterator result);
  // just value_type
  friend void swap(T& a,T& b);
  // forward iter
  friend vector::iterator
    swap_ranges(vector::iterator first1,vector::iterator last1,
                vector::iterator first2);
  friend void iter_swap(vector::iterator a,vector::iterator b);
  friend void replace(vector::iterator first,vector::iterator last,
                      const T& old_value,const T& new_value);
  // input, output iter -> forward iter
  friend vector::iterator
    replace_copy(vector::iterator first,vector::iterator last,
                 vector::iterator result,
                 const T& old_value,const T& new_value);
  // forward iter
  friend void
    fill(vector::iterator first,vector::iterator last,const T& value);

  friend void
    fill_n(vector::iterator first,vector::size_type n,const T& value);

  friend vector::iterator
    remove(vector::iterator first,vector::iterator last,const T& value);
  // input,output iter -> forward iter
  friend vector::iterator
    remove_copy(vector::iterator first,vector::iterator last,
                vector::iterator result,const T& value);
  friend vector::iterator
    unique(vector::iterator first,vector::iterator last);
  friend vector::iterator
    unique_copy(vector::iterator first,vector::iterator last,
                vector::iterator result);
  friend void reverse(vector::iterator first,vector::iterator last);
  friend vector::iterator
     reverse_copy(vector::iterator first,vector::iterator last,
                  vector::iterator result);
  // forward iter

  friend void rotate(vector::iterator first,vector::iterator mid,
                     vector::iterator last);

  // forward iter
  friend vector::iterator
    rotate_copy(vector::iterator first,vector::iterator mid,
                vector::iterator last,vector::iterator result);
  // randomaccess iter
  friend void random_shuffle(vector::iterator first,vector::iterator last);
  // randomaccess iter
  friend void sort(vector::iterator first,vector::iterator last);
  friend void stable_sort(vector::iterator first,vector::iterator last);
  friend void partial_sort(vector::iterator first,vector::iterator mid,
                           vector::iterator last);
  friend vector::iterator
    partial_sort_copy(vector::iterator first,vector::iterator last,
                      vector::iterator result_first,
                      vector::iterator result_last);
  friend void nth_element(vector::iterator first,vector::iterator nth,
                          vector::iterator last);
  // forward iter
  friend vector::iterator
    lower_bound(vector::iterator first,vector::iterator last,const T& value);
  friend vector::iterator
    upper_bound(vector::iterator first,vector::iterator last,const T& value);




  friend bool binary_search(vector::iterator first,vector::iterator last,
                            const T& value);
  friend vector::iterator merge(vector::iterator first1,vector::iterator last1,
                                vector::iterator first2,vector::iterator last2,
                                vector::iterator result);
  friend void inplace_merge(vector::iterator first,vector::iterator middle,
                            vector::iterator last);
  friend bool includes(vector::iterator first1,vector::iterator last1,
                       vector::iterator first2,vector::iterator last2);
  friend vector::iterator
    set_union(vector::iterator first1,vector::iterator last1,
              vector::iterator first2,vector::iterator last2,
              vector::iterator result);
  friend vector::iterator
    set_intersection(vector::iterator first1,vector::iterator last1,
                     vector::iterator first2,vector::iterator last2,
                     vector::iterator result);
  friend vector::iterator
    set_difference(vector::iterator first1,vector::iterator last1,
                   vector::iterator first2,vector::iterator last2,
                   vector::iterator result);
  friend vector::iterator
    set_symmetric_difference(vector::iterator first1,vector::iterator last1,
                             vector::iterator first2,vector::iterator last2,
                             vector::iterator result);
  // random access
  friend void push_heap(vector::iterator first,vector::iterator last);
  friend void pop_heap(vector::iterator first,vector::iterator last);
  friend void make_heap(vector::iterator first,vector::iterator last);
  friend void sort_heap(vector::iterator first,vector::iterator last);
  // min,max, just value_type
  friend const T& min(const T& a,const T& b);
  friend const T& max(const T& a,const T& b);
  // forward iter
  friend vector::iterator
    min_element(vector::iterator first,vector::iterator last);
  friend vector::iterator
    max_element(vector::iterator first,vector::iterator last);
  // input iter
  friend bool
    lexicographical_compare(vector::iterator first1,vector::iterator last1,
                            vector::iterator first2,vector::iterator last2);
  // bidirectional iter
  friend bool next_permutation(vector::iterator first,vector::iterator last);
  friend bool prev_permutation(vector::iterator first,vector::iterator last);
# 662 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
#pragma endif

  // iterator_category resolution
  //friend random_access_iterator_tag iterator_category(vector::iterator x);

};
# 837 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
#pragma endif
# 15 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_vector" 2
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/vector" 2
}
# 23 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCurve.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TMatrixDfwd.h" 1
/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/




//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TMatrixD                                                             //
//                                                                      //
//  Forward declaration of TMatrixT<Double_t>                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////





template<class Element> class TMatrixT;
typedef TMatrixT<Double_t> TMatrixD;
# 24 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCurve.h" 2

class RooAbsReal;
class RooRealVar;
class RooAbsFunc;
class RooArgSet;
class RooAbsRealLValue ;
class RooHist ;

class RooCurve : public TGraph, public RooPlotable {
public:
  RooCurve();
  enum WingMode { NoWings=0 ,Straight=1, Extended=2 } ;
  RooCurve(const RooAbsReal &func, RooAbsRealLValue &x, Double_t xlo, Double_t xhi, Int_t xbins,
    Double_t scaleFactor= 1, const RooArgSet *normVars= 0, Double_t prec= 1e-3, Double_t resolution= 1e-3,
    Bool_t shiftToZero=kFALSE, WingMode wmode=Extended, Int_t nEvalError=-1, Int_t doEEVal=kFALSE, Double_t eeVal=0,
    Bool_t showProgress=kFALSE);
  RooCurve(const char *name, const char *title, const RooAbsFunc &func, Double_t xlo,
    Double_t xhi, UInt_t minPoints, Double_t prec= 1e-3, Double_t resolution= 1e-3,
    Bool_t shiftToZero=kFALSE, WingMode wmode=Extended, Int_t nEvalError=-1, Int_t doEEVal=kFALSE, Double_t eeVal=0);
  virtual ~RooCurve();

  RooCurve(const char* name, const char* title, const RooCurve& c1, const RooCurve& c2, Double_t scale1=1., Double_t scale2=1.) ;

  void addPoint(Double_t x, Double_t y);

  Double_t getFitRangeBinW() const;
  Double_t getFitRangeNEvt(Double_t xlo, Double_t xhi) const ;
  Double_t getFitRangeNEvt() const;


  virtual void printName(std::ostream& os) const ;
  virtual void printTitle(std::ostream& os) const ;
  virtual void printClassName(std::ostream& os) const ;
  virtual void printMultiline(std::ostream& os, Int_t contents, Bool_t verbose=kFALSE, TString indent="") const;

  inline virtual void Print(Option_t *options= 0) const {
    // Printing interface
    printStream(defaultPrintStream(),defaultPrintContents(options),defaultPrintStyle(options));
  }

  Double_t chiSquare(const RooHist& hist, int nFitParam) const ;
  Int_t findPoint(Double_t value, Double_t tolerance=1e-10) const ;
  Double_t average(Double_t lo, Double_t hi) const ;
  Double_t interpolate(Double_t x, Double_t tolerance=1e-10) const ;

  Bool_t isIdentical(const RooCurve& other, Double_t tol=1e-6) const ;

  RooCurve* makeErrorBand(const std::vector<RooCurve*>& variations, Double_t Z=1) const ;
  RooCurve* makeErrorBand(const std::vector<RooCurve*>& plusVar, const std::vector<RooCurve*>& minusVar, const TMatrixD& V, Double_t Z=1) const ;

protected:

  void calcBandInterval(const std::vector<RooCurve*>& variations,Int_t i,Double_t Z,Double_t& lo, Double_t& hi, Bool_t approxGauss) const ;
  void calcBandInterval(const std::vector<RooCurve*>& plusVar, const std::vector<RooCurve*>& minusVar, Int_t i, const TMatrixD& V,
   Double_t Z,Double_t& lo, Double_t& hi) const ;

  void initialize();
  void addPoints(const RooAbsFunc &func, Double_t xlo, Double_t xhi,
   Int_t minPoints, Double_t prec, Double_t resolution, WingMode wmode,
   Int_t numee=0, Bool_t doEEVal=kFALSE, Double_t eeVal=0.,std::list<Double_t>* samplingHint=0) ;
  void addRange(const RooAbsFunc& func, Double_t x1, Double_t x2, Double_t y1,
  Double_t y2, Double_t minDy, Double_t minDx,
  Int_t numee=0, Bool_t doEEVal=kFALSE, Double_t eeVal=0.) ;


  void shiftCurveToZero(Double_t prevYMax) ;

  Bool_t _showProgress ; //! Show progress indication when adding points

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return RooCurve::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooCurve::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCurve.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 93; } // 1-dimensional smooth curve for use in RooPlots
};
# 22 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsReal.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooArgSet.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooArgSet.h,v 1.45 2007/08/09 19:55:47 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsCollection.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooAbsCollection.h,v 1.26 2007/08/09 19:55:47 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TString.h" 1
// @(#)root/base:$Id: TString.h 43133 2012-02-27 09:50:10Z rdm $
// Author: Fons Rademakers   04/08/95

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsCollection.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsArg.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooAbsArg.h,v 1.93 2007/07/16 21:04:28 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsCollection.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooPrintable.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooPrintable.h,v 1.12 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 22 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsCollection.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooLinkedList.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooLinkedList.h,v 1.15 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 23 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsCollection.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCmdArg.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooCmdArg.h,v 1.10 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 24 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsCollection.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooLinkedListIter.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooLinkedListIter.h,v 1.11 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 25 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsCollection.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/string" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_string" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// string
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/string" 2
}
# 26 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsCollection.h" 2

class RooAbsCollection : public TObject, public RooPrintable {
public:

  // Constructors, assignment etc.
  RooAbsCollection();
  RooAbsCollection(const char *name);
  virtual TObject* clone(const char* newname) const = 0 ;
  virtual TObject* create(const char* newname) const = 0 ;
  virtual TObject* Clone(const char* newname=0) const {
    return clone(newname?newname:GetName()) ;
  }
  virtual ~RooAbsCollection();

  // Create a copy of an existing list. New variables cannot be added
  // to a copied list. The variables in the copied list are independent
  // of the original variables.
  RooAbsCollection(const RooAbsCollection& other, const char *name="");
  RooAbsCollection& operator=(const RooAbsCollection& other);
  RooAbsCollection& assignValueOnly(const RooAbsCollection& other, Bool_t oneSafe=kFALSE) ;
  void assignFast(const RooAbsCollection& other, Bool_t setValDirty=kTRUE) ;

  // Copy list and contents (and optionally 'deep' servers)
  RooAbsCollection *snapshot(Bool_t deepCopy=kTRUE) const ;
  Bool_t snapshot(RooAbsCollection& output, Bool_t deepCopy=kTRUE) const ;

  // Hash table control
  void setHashTableSize(Int_t i) {
    // Set size of internal hash table to i (should be a prime number)
    _list.setHashTableSize(i) ;
  }
  Int_t getHashTableSize() const {
    // Return size of internal hash table
    return _list.getHashTableSize() ;
  }

  // List content management
  virtual Bool_t add(const RooAbsArg& var, Bool_t silent=kFALSE) ;
  virtual Bool_t addOwned(RooAbsArg& var, Bool_t silent=kFALSE);
  virtual RooAbsArg *addClone(const RooAbsArg& var, Bool_t silent=kFALSE) ;
  virtual Bool_t replace(const RooAbsArg& var1, const RooAbsArg& var2) ;
  virtual Bool_t remove(const RooAbsArg& var, Bool_t silent=kFALSE, Bool_t matchByNameOnly=kFALSE) ;
  virtual void removeAll() ;

  virtual Bool_t add(const RooAbsCollection& list, Bool_t silent=kFALSE) ;
  virtual Bool_t addOwned(const RooAbsCollection& list, Bool_t silent=kFALSE);
  virtual void addClone(const RooAbsCollection& list, Bool_t silent=kFALSE);
  Bool_t replace(const RooAbsCollection &other);
  Bool_t remove(const RooAbsCollection& list, Bool_t silent=kFALSE, Bool_t matchByNameOnly=kFALSE) ;

  // Group operations on AbsArgs
  void setAttribAll(const Text_t* name, Bool_t value=kTRUE) ;

  // List search methods
  RooAbsArg *find(const char *name) const ;
  RooAbsArg *find(const RooAbsArg&) const ;

  Bool_t contains(const RooAbsArg& var) const {
    // Returns true if object with same name as var is contained in this collection
    return (0 == find(var)) ? kFALSE:kTRUE;
  }
  Bool_t containsInstance(const RooAbsArg& var) const {
    // Returns true if var is contained in this collection
    return (0 == _list.FindObject(&var)) ? kFALSE:kTRUE;
  }
  RooAbsCollection* selectByAttrib(const char* name, Bool_t value) const ;
  RooAbsCollection* selectCommon(const RooAbsCollection& refColl) const ;
  RooAbsCollection* selectByName(const char* nameList, Bool_t verbose=kFALSE) const ;
  Bool_t equals(const RooAbsCollection& otherColl) const ;
  Bool_t overlaps(const RooAbsCollection& otherColl) const ;

  // export subset of THashList interface
  inline TIterator* createIterator(Bool_t dir = kIterForward) const {
    // Create and return an iterator over the elements in this collection
    return _list.MakeIterator(dir);
  }

  RooLinkedListIter iterator(Bool_t dir = kIterForward) const ;
  RooFIter fwdIterator() const { return RooFIter(&_list); }

  inline Int_t getSize() const {
    // Return the number of elements in the collection
    return _list.GetSize();
  }
  inline RooAbsArg *first() const {
    // Return the first element in this collection
    return (RooAbsArg*)_list.First();
  }

  inline virtual void Print(Option_t *options= 0) const {
    // Printing interface (human readable)
    printStream(defaultPrintStream(),defaultPrintContents(options),defaultPrintStyle(options));
  }
  std::string contentsString() const ;


  virtual void printName(std::ostream& os) const ;
  virtual void printTitle(std::ostream& os) const ;
  virtual void printClassName(std::ostream& os) const ;
  virtual void printValue(std::ostream& os) const ;
  virtual void printMultiline(std::ostream& os, Int_t contents, Bool_t verbose=kFALSE, TString indent="") const ;

  virtual Int_t defaultPrintContents(Option_t* opt) const ;

  // Latex printing methods
  void printLatex(const RooCmdArg& arg1=RooCmdArg(), const RooCmdArg& arg2=RooCmdArg(),
    const RooCmdArg& arg3=RooCmdArg(), const RooCmdArg& arg4=RooCmdArg(),
    const RooCmdArg& arg5=RooCmdArg(), const RooCmdArg& arg6=RooCmdArg(),
    const RooCmdArg& arg7=RooCmdArg(), const RooCmdArg& arg8=RooCmdArg()) const ;
  void printLatex(std::ostream& ofs, Int_t ncol, const char* option="NEYU", Int_t sigDigit=1,
                  const RooLinkedList& siblingLists=RooLinkedList(), const RooCmdArg* formatCmd=0) const ;

  void setName(const char *name) {
    // Set name of collection
    _name= name;
  }
  const char* GetName() const {
    // Return namer of collection
    return _name.Data() ;
  }
  Bool_t isOwning() const {
    // Does collection own contents?
    return _ownCont ;
  }

  Bool_t allInRange(const char* rangeSpec) const ;

  void dump() const ;

  void releaseOwnership() { _ownCont = kFALSE ; }
  void takeOwnership() { _ownCont = kTRUE ; }

  void sort(Bool_t ascend=kTRUE) { _list.Sort(ascend) ; }

protected:

  friend class RooMultiCatIter ;

  RooLinkedList _list ; // Actual object store

  Bool_t _ownCont; // Flag to identify a list that owns its contents.
  TString _name; // Our name.
  Bool_t _allRRV ; // All contents are RRV

  void safeDeleteList() ;

  // Support for snapshot method 
  Bool_t addServerClonesToList(const RooAbsArg& var) ;

  inline TNamed* structureTag() { if (_structureTag==0) makeStructureTag() ; return _structureTag ; }
  inline TNamed* typedStructureTag() { if (_typedStructureTag==0) makeTypedStructureTag() ; return _typedStructureTag ; }

  mutable TNamed* _structureTag ; //! Structure tag
  mutable TNamed* _typedStructureTag ; //! Typed structure tag

  inline void clearStructureTags() { _structureTag=0 ; _typedStructureTag = 0 ; }

  void makeStructureTag() ;
  void makeTypedStructureTag() ;

private:

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 2; } static void Dictionary(); virtual TClass *IsA() const { return RooAbsCollection::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooAbsCollection::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsCollection.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 188; } // Collection of RooAbsArg objects
};
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooArgSet.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooErrorHandler.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooErrorHandler.h,v 1.4 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2002, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/stdlib.h" 1



#pragma setstdstruct






typedef unsigned int wchar_t;
#pragma include_noerr <stdfunc.dll>
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooErrorHandler.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/signal.h" 1
# 12 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/signal.h"
/* non ANSI signals */
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooErrorHandler.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h" 1
/* @(#)root/base:$Id: Rtypes.h 43708 2012-04-12 10:19:00Z axel $ */

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 22 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooErrorHandler.h" 2

class RooErrorHandler
{
public:
  // Soft assert function that interrupts macro execution but doesn't kill ROOT
  static void softAssert(Bool_t condition) { if (!condition) abort() ; }

  // Soft abort function that interrupts macro execution but doesn't kill ROOT
  static void softAbort() { raise(11) ; }
} ;
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooArgSet.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/map" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_map" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <pair.dll>
#pragma include_noerr <map.dll>
#pragma include_noerr <map2.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/map

#pragma ifndef PREC_STL_MAP
#pragma define PREC_STL_MAP
#pragma link off global PREC_STL_MAP;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from ANSI/ISO C++ 1997/Nov draft 
// Got some ideas from Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <utility.dll>


#pragma include_noerr <pair.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/utility

#pragma ifndef PREC_STL_UTILITY
#pragma define PREC_STL_UTILITY
#pragma link off global PREC_STL_UTILITY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

template <class T1, class T2>
struct pair {
  T1 first;
  T2 second;
  pair() : first(T1()), second(T2()) {}
  pair(const T1& a, const T2& b) : first(a), second(b) {}
 private:
  pair& operator=(const pair& x){first=x.first;second=x.second;return *this;}
};

#pragma endif
# 17 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 2
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <memory.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/memory

#pragma ifndef PREC_STL_MEMORY
#pragma define PREC_STL_MEMORY
#pragma link off global PREC_STL_MEMORY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////


template <class _Tp>
class allocator {
  //typedef alloc _Alloc;          // The underlying allocator.
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  typedef typename _Tp* pointer;
  typedef const typename _Tp * const_pointer;




  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() ;
  allocator(const allocator&) ;
  //template <class _Tp1> allocator(const allocator<_Tp1>&) ;
  ~allocator() ;

  pointer address(reference __x) const ;
  const_pointer address(const_reference __x) const ;

  // __n is permitted to be 0.  The C++ standard says nothing about what
  // the return value is when __n == 0.
  _Tp* allocate(size_type __n, const void* = 0) ;

  // __p is not permitted to be a null pointer.
  void deallocate(pointer __p, size_type __n);

  size_type max_size() const ;

  void construct(pointer __p, const _Tp& __val) ;
  void destroy(pointer __p) ;
};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;
  typedef void value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };
};
//////////////////////////////////////////////////////////////////////
# 205 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////

/**********************************************************************
* auto_ptr
**********************************************************************/
template <class X> class auto_ptr {
private:
  X* ptr;
  //template<class Y> struct auto_ptr_ref { };
public:
  typedef X element_type;
  explicit auto_ptr(X* p = 0) : ptr(p) {}
  auto_ptr(auto_ptr& a) {ptr=a.ptr;}

  // this implementation may not be correct
  template <class T> auto_ptr(auto_ptr<T>& a) {ptr=a.release();}
# 229 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  auto_ptr& operator=(auto_ptr& a) {
    if (a.ptr != ptr) {
      delete ptr;
      ptr = a.ptr;
    }
    return(*this);
  }

  // this implementation may not be correct
  template <class T> auto_ptr& operator=(auto_ptr<T>& a) {
    if (a.ptr != ptr) {
       delete ptr;
       ptr = a.release();
    }
    return(*this);
  }

  ~auto_ptr() { delete ptr; }

  X& operator*() const { return *ptr; }
  X* operator->() const { return ptr; }
  X* get() const { return ptr; }
  X* release() { X *old = ptr; ptr = 0; return 0; }
# 262 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  // auto_ptr conversions
  //auto_ptr(auto_ptr_ref<X>& x) { }
  //template<class Y> operator auto_ptr_ref<Y>() { return auto_ptr_ref<Y>(); }
  //template<class Y> operator auto_ptr<Y>() { return auto_ptr<T>(); }
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 2
# 28 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <iterator.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/iterator

#pragma ifndef PREC_STL_ITERATOR
#pragma define PREC_STL_ITERATOR
#pragma link off global PREC_STL_ITERATOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from STL HP implementation 1994
// Imported from STL SGI implementation 1997 
// Imported from ANSI/ISO C++ draft Nov 1997
// Modified by Masaharu Goto
// May need improvement for the latest standard


////////////////////////////////////////////////////////////////////////
// iterator_tag
////////////////////////////////////////////////////////////////////////
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag {};
struct bidirectional_iterator_tag {};
struct random_access_iterator_tag {};

////////////////////////////////////////////////////////////////////////
// iterator template
////////////////////////////////////////////////////////////////////////
template <class T, class Distance> struct input_iterator {};
struct output_iterator {};
template <class T, class Distance> struct forward_iterator {};
template <class T, class Distance> struct bidirectional_iterator {};
template <class T, class Distance> struct random_access_iterator {};

#pragma link off class output_iterator;







////////////////////////////////////////////////////////////////////////
// iterator_category overloaded function
////////////////////////////////////////////////////////////////////////
template <class T, class Distance>
inline input_iterator_tag
iterator_category(const input_iterator<T, Distance>&) {
    return input_iterator_tag();
}

inline output_iterator_tag iterator_category(const output_iterator&) {
    return output_iterator_tag();
}

#pragma link off function iterator_category(const output_iterator&);


template <class T, class Distance>
inline forward_iterator_tag
iterator_category(const forward_iterator<T, Distance>&) {
    return forward_iterator_tag();
}

template <class T, class Distance>
inline bidirectional_iterator_tag
iterator_category(const bidirectional_iterator<T, Distance>&) {
    return bidirectional_iterator_tag();
}

template <class T, class Distance>
inline random_access_iterator_tag
iterator_category(const random_access_iterator<T, Distance>&) {
    return random_access_iterator_tag();
}

template <class T>
inline random_access_iterator_tag
iterator_category(const T*) {
    return random_access_iterator_tag();
}


// iterator_traits, iterator and reverse_iterator template may not be
// needed for precompiled library interface 

////////////////////////////////////////////////////////////////////////
// iterator_traits
////////////////////////////////////////////////////////////////////////

template <class Iterator>
struct iterator_traits {
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type value_type;
  typedef typename Iterator::difference_type difference_type;
  typedef typename Iterator::pointer pointer;
  typedef typename Iterator::reference reference;
};

// template partial specialization, implement in cint5.15.14 1587
template <class T>
struct iterator_traits<T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
};

// incomplete implementation in cint5.15.14 1587, need some fix
// iterator_traits<const int*> is changed as iterator_traits<const int* const>
// or something, but cint5.15.14 can not handle this well
template <class T>
struct iterator_traits<const T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef const T* pointer;
  typedef const T& reference;
};

////////////////////////////////////////////////////////////////////////
// iterator
////////////////////////////////////////////////////////////////////////
template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator {
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
  typedef Category iterator_category;
};


////////////////////////////////////////////////////////////////////////
// reverse_iterator
////////////////////////////////////////////////////////////////////////






template <class Iterator>
class reverse_iterator
# 166 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
{




 public:
# 181 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
   typedef Iterator::pointer pointer;
   typedef Iterator::reference reference;
   typedef ptrdiff_t difference_type;


   reverse_iterator();
   //reverse_iterator(Iterator x);



   Iterator base() const; // explicit
   reference operator*() const;
   pointer operator->() const;
   reverse_iterator& operator++();
   reverse_iterator operator++(int);
   reverse_iterator& operator--();
   reverse_iterator operator--(int);
   reverse_iterator operator+ (difference_type n) const;
   reverse_iterator& operator+=(difference_type n);
   reverse_iterator operator- (difference_type n) const;
   reverse_iterator& operator-=(difference_type n);
   reference operator[](difference_type n) const;
};
# 932 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
// for g++ 3.1,3.2
namespace __gnu_cxx
{
  // This iterator adapter is 'normal' in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                    difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparaison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  // _GLIBCPP_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
     const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
} // namespace __gnu_cxx







#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 2
# 29 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_functional" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <functional.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/functional" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/functional

#pragma ifndef PREC_STL_FUNCTIONAL
#pragma define PREC_STL_FUNCTIONAL
#pragma link off global PREC_STL_FUNCTIONAL;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab

// clause _lib.base_, base:
template <class Arg, class Result>
struct unary_function
{
  typedef Arg argument_type;
  typedef Result result_type;
};


template <class Arg1, class Arg2, class Result>
struct binary_function
{
  typedef Arg1 first_argument_type;
  typedef Arg2 second_argument_type;
  typedef Result result_type;
};


// clause _lib.arithmetic.operations_, arithmetic operations:
template <class T> struct plus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct minus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct multiplies : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct divides : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};

template <class T> struct modulus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};

template <class T> struct negate : unary_function<T,T> {
  T operator()(const T& x) const;
};


// clause _lib.comparisons_, comparisons:
template <class T> struct equal_to : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct not_equal_to : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct greater : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct less : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct greater_equal : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct less_equal : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};


// clause _lib.logical.operations_, logical operations:
template <class T> struct logical_and : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct logical_or : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct logical_not : unary_function<T,bool> {
  bool operator()(const T& x) const;
};


// clause _lib.negators_, negators:
template <class Predicate>
class unary_negate
  : public unary_function<Predicate::argument_type, bool>
{
public:
  explicit unary_negate(const Predicate& pred);
  bool operator()(const argument_type& x) const;
};






template <class Predicate>
class binary_negate
  : public binary_function<Predicate::first_argument_type,
                           Predicate::second_argument_type, bool>
{
public:
  explicit binary_negate(const Predicate& pred);
  bool operator()(const first_argument_type& x,
                  const second_argument_type& y) const;
};

// operations omitted (cint can't handle template forward decls...)







// clause _lib.binders_, binders:
template <class Operation>
class binder1st
  : public unary_function<Operation::second_argument_type,
                          Operation::result_type>
{
protected:
  Operation op;
  Operation::first_argument_type value;
public:
  binder1st(const Operation& x, const Operation::first_argument_type& y);
  result_type operator()(const argument_type& x) const;
};


// operations omitted (cint can't handle template forward decls...)





template <class Operation>
class binder2nd
  : public unary_function<Operation::first_argument_type,
                          Operation::result_type>
{
protected:
  Operation op;
  Operation::second_argument_type value;
public:
  binder2nd(const Operation& x, const Operation::second_argument_type& y);
  result_type operator()(const argument_type& x) const;
};


// operations omitted (cint can't handle template forward decls...)






// clause _lib.function.pointer.adaptors_, adaptors:
template <class Arg, class Result>
class pointer_to_unary_function
  : public unary_function<Arg, Result>
{
public:
  explicit pointer_to_unary_function(Result (*f)(Arg));
  Result operator()(Arg x) const;
};

// operations omitted (cint can't handle template forward decls...)





template <class Arg1, class Arg2, class Result>
class pointer_to_binary_function
  : public binary_function<Arg1,Arg2,Result>
{
public:
  explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));
  Result operator()(Arg1 x, Arg2 y) const;
};

// operations omitted (cint can't handle template forward decls...)






// omit these for now.
# 230 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/functional"
#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_functional" 2
# 30 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map" 2

//////////////////////////////////////////////////////////////////////////

template<class Key,class T,class Compare=std::less<Key>
        ,class Allocator=std::allocator<pair<const Key, T> > >
# 63 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map"
class map {
 public:
  typedef Key key_type;
  typedef T mapped_type;



  typedef pair<Key,T> value_type;

  typedef Compare key_compare;
  typedef Allocator allocator_type;

  //typedef Key*                                     pointer;
  //typedef const Key*                               const_pointer;
  //typedef Key&                                     reference;
  //typedef const Key&                               const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
# 90 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map"
  class iterator
# 103 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map"
 {
   public:
    iterator() ;
    iterator(const iterator& x) ;

    iterator& operator=(const iterator& x) ;

    value_type& operator*() ;

    value_type* operator->() ;

    iterator& operator++();
    iterator operator++(int a);
    iterator& operator--();
    iterator operator--(int a);

    bool operator==(const iterator& x) ;
    bool operator!=(const iterator& x) ;




  };
# 134 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map"
  class reverse_iterator
# 147 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map"
 {
   public:
    reverse_iterator(const reverse_iterator& x);

    reverse_iterator& operator=(const reverse_iterator& x) ;

    value_type& operator*() ;

    value_type* operator->() ;

    reverse_iterator& operator++();
    reverse_iterator operator++(int a);
    reverse_iterator& operator--();
    reverse_iterator operator--(int a);
   private:
  };

  friend bool operator==(const map::reverse_iterator& x
                        ,const map::reverse_iterator& y) const;
  friend bool operator!=(const map::reverse_iterator& x
                        ,const map::reverse_iterator& y) const;


  typedef const iterator const_iterator;
  typedef const reverse_iterator const_reverse_iterator;

  // _lib.map.cons_ construct/copy/destroy:
  map();






  map(iterator first, iterator last);
  map(reverse_iterator first, reverse_iterator last);

  map(const map& x);
  ~map();
  map& operator=(const map& x);
  // iterators:
  iterator begin();
  iterator end();
  reverse_iterator rbegin();
  reverse_iterator rend();






  // capacity:
  bool empty() const;
  size_type size() const;
  size_type max_size() const;
  // _lib.map.access_ element access:
  T& operator[](const Key& x);
  // modifiers:
  pair<map::iterator, bool> insert(const value_type& x);
  iterator insert(iterator position, const value_type& x);





  void insert(iterator first, iterator last);
  void insert(reverse_iterator first, reverse_iterator last);

  void erase(iterator position);
  size_type erase(const Key& x);
  void erase(iterator first, iterator last);
  void swap(map&);
  void clear();
  // observers:
  //key_compare   key_comp() const;
  //value_compare value_comp() const;
  // _lib.map.ops_ map operations:
  iterator find(const Key& x);
  //const_iterator find(const Key& x) const;
  size_type count(const Key& x) const;
  iterator lower_bound(const Key& x);
  //const_iterator lower_bound(const Key& x) const;
  iterator upper_bound(const Key& x);
  //const_iterator upper_bound(const Key& x) const;





  friend bool operator==(const map& x, const map& y);
  friend bool operator< (const map& x, const map& y);
  friend bool operator!=(const map& x, const map& y);
  friend bool operator> (const map& x, const map& y);
  friend bool operator>=(const map& x, const map& y);
  friend bool operator<=(const map& x, const map& y);
  // specialized algorithms:





#pragma ifndef G__NOALGORITHM
  // Generic algorithm
  friend map::iterator
    search(map::iterator first1,map::iterator last1,
           map::iterator first2,map::iterator last2);
#pragma endif

  // iterator_category resolution
  //friend bidirectional_iterator_tag iterator_category(map::iterator x);

};

//////////////////////////////////////////////////////////////////////////

#pragma endif
# 16 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_map" 2
# 26 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_map"
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_multimap" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

//#pragma include_noerr <pair.dll> 
#pragma include_noerr <multimap.dll>
#pragma include_noerr <multimap2.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/multimap

#pragma ifndef PREC_STL_MULTIMAP
#pragma define PREC_STL_MULTIMAP
#pragma link off global PREC_STL_MULTIMAP;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from ANSI/ISO C++ 1997/Nov draft 
// Got some ideas from Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <utility.dll>


#pragma include_noerr <pair.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/utility

#pragma ifndef PREC_STL_UTILITY
#pragma define PREC_STL_UTILITY
#pragma link off global PREC_STL_UTILITY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

template <class T1, class T2>
struct pair {
  T1 first;
  T2 second;
  pair() : first(T1()), second(T2()) {}
  pair(const T1& a, const T2& b) : first(a), second(b) {}
 private:
  pair& operator=(const pair& x){first=x.first;second=x.second;return *this;}
};

#pragma endif
# 17 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 2
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <memory.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/memory

#pragma ifndef PREC_STL_MEMORY
#pragma define PREC_STL_MEMORY
#pragma link off global PREC_STL_MEMORY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////


template <class _Tp>
class allocator {
  //typedef alloc _Alloc;          // The underlying allocator.
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  typedef typename _Tp* pointer;
  typedef const typename _Tp * const_pointer;




  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() ;
  allocator(const allocator&) ;
  //template <class _Tp1> allocator(const allocator<_Tp1>&) ;
  ~allocator() ;

  pointer address(reference __x) const ;
  const_pointer address(const_reference __x) const ;

  // __n is permitted to be 0.  The C++ standard says nothing about what
  // the return value is when __n == 0.
  _Tp* allocate(size_type __n, const void* = 0) ;

  // __p is not permitted to be a null pointer.
  void deallocate(pointer __p, size_type __n);

  size_type max_size() const ;

  void construct(pointer __p, const _Tp& __val) ;
  void destroy(pointer __p) ;
};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;
  typedef void value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };
};
//////////////////////////////////////////////////////////////////////
# 205 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////

/**********************************************************************
* auto_ptr
**********************************************************************/
template <class X> class auto_ptr {
private:
  X* ptr;
  //template<class Y> struct auto_ptr_ref { };
public:
  typedef X element_type;
  explicit auto_ptr(X* p = 0) : ptr(p) {}
  auto_ptr(auto_ptr& a) {ptr=a.ptr;}

  // this implementation may not be correct
  template <class T> auto_ptr(auto_ptr<T>& a) {ptr=a.release();}
# 229 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  auto_ptr& operator=(auto_ptr& a) {
    if (a.ptr != ptr) {
      delete ptr;
      ptr = a.ptr;
    }
    return(*this);
  }

  // this implementation may not be correct
  template <class T> auto_ptr& operator=(auto_ptr<T>& a) {
    if (a.ptr != ptr) {
       delete ptr;
       ptr = a.release();
    }
    return(*this);
  }

  ~auto_ptr() { delete ptr; }

  X& operator*() const { return *ptr; }
  X* operator->() const { return ptr; }
  X* get() const { return ptr; }
  X* release() { X *old = ptr; ptr = 0; return 0; }
# 262 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  // auto_ptr conversions
  //auto_ptr(auto_ptr_ref<X>& x) { }
  //template<class Y> operator auto_ptr_ref<Y>() { return auto_ptr_ref<Y>(); }
  //template<class Y> operator auto_ptr<Y>() { return auto_ptr<T>(); }
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 2
# 28 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <iterator.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/iterator

#pragma ifndef PREC_STL_ITERATOR
#pragma define PREC_STL_ITERATOR
#pragma link off global PREC_STL_ITERATOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from STL HP implementation 1994
// Imported from STL SGI implementation 1997 
// Imported from ANSI/ISO C++ draft Nov 1997
// Modified by Masaharu Goto
// May need improvement for the latest standard


////////////////////////////////////////////////////////////////////////
// iterator_tag
////////////////////////////////////////////////////////////////////////
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag {};
struct bidirectional_iterator_tag {};
struct random_access_iterator_tag {};

////////////////////////////////////////////////////////////////////////
// iterator template
////////////////////////////////////////////////////////////////////////
template <class T, class Distance> struct input_iterator {};
struct output_iterator {};
template <class T, class Distance> struct forward_iterator {};
template <class T, class Distance> struct bidirectional_iterator {};
template <class T, class Distance> struct random_access_iterator {};

#pragma link off class output_iterator;







////////////////////////////////////////////////////////////////////////
// iterator_category overloaded function
////////////////////////////////////////////////////////////////////////
template <class T, class Distance>
inline input_iterator_tag
iterator_category(const input_iterator<T, Distance>&) {
    return input_iterator_tag();
}

inline output_iterator_tag iterator_category(const output_iterator&) {
    return output_iterator_tag();
}

#pragma link off function iterator_category(const output_iterator&);


template <class T, class Distance>
inline forward_iterator_tag
iterator_category(const forward_iterator<T, Distance>&) {
    return forward_iterator_tag();
}

template <class T, class Distance>
inline bidirectional_iterator_tag
iterator_category(const bidirectional_iterator<T, Distance>&) {
    return bidirectional_iterator_tag();
}

template <class T, class Distance>
inline random_access_iterator_tag
iterator_category(const random_access_iterator<T, Distance>&) {
    return random_access_iterator_tag();
}

template <class T>
inline random_access_iterator_tag
iterator_category(const T*) {
    return random_access_iterator_tag();
}


// iterator_traits, iterator and reverse_iterator template may not be
// needed for precompiled library interface 

////////////////////////////////////////////////////////////////////////
// iterator_traits
////////////////////////////////////////////////////////////////////////

template <class Iterator>
struct iterator_traits {
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type value_type;
  typedef typename Iterator::difference_type difference_type;
  typedef typename Iterator::pointer pointer;
  typedef typename Iterator::reference reference;
};

// template partial specialization, implement in cint5.15.14 1587
template <class T>
struct iterator_traits<T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
};

// incomplete implementation in cint5.15.14 1587, need some fix
// iterator_traits<const int*> is changed as iterator_traits<const int* const>
// or something, but cint5.15.14 can not handle this well
template <class T>
struct iterator_traits<const T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef const T* pointer;
  typedef const T& reference;
};

////////////////////////////////////////////////////////////////////////
// iterator
////////////////////////////////////////////////////////////////////////
template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator {
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
  typedef Category iterator_category;
};


////////////////////////////////////////////////////////////////////////
// reverse_iterator
////////////////////////////////////////////////////////////////////////






template <class Iterator>
class reverse_iterator
# 166 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
{




 public:
# 181 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
   typedef Iterator::pointer pointer;
   typedef Iterator::reference reference;
   typedef ptrdiff_t difference_type;


   reverse_iterator();
   //reverse_iterator(Iterator x);



   Iterator base() const; // explicit
   reference operator*() const;
   pointer operator->() const;
   reverse_iterator& operator++();
   reverse_iterator operator++(int);
   reverse_iterator& operator--();
   reverse_iterator operator--(int);
   reverse_iterator operator+ (difference_type n) const;
   reverse_iterator& operator+=(difference_type n);
   reverse_iterator operator- (difference_type n) const;
   reverse_iterator& operator-=(difference_type n);
   reference operator[](difference_type n) const;
};
# 932 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
// for g++ 3.1,3.2
namespace __gnu_cxx
{
  // This iterator adapter is 'normal' in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                    difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparaison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  // _GLIBCPP_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
     const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
} // namespace __gnu_cxx







#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 2
# 29 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_functional" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <functional.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/functional" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/functional

#pragma ifndef PREC_STL_FUNCTIONAL
#pragma define PREC_STL_FUNCTIONAL
#pragma link off global PREC_STL_FUNCTIONAL;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab

// clause _lib.base_, base:
template <class Arg, class Result>
struct unary_function
{
  typedef Arg argument_type;
  typedef Result result_type;
};


template <class Arg1, class Arg2, class Result>
struct binary_function
{
  typedef Arg1 first_argument_type;
  typedef Arg2 second_argument_type;
  typedef Result result_type;
};


// clause _lib.arithmetic.operations_, arithmetic operations:
template <class T> struct plus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct minus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct multiplies : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct divides : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};

template <class T> struct modulus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};

template <class T> struct negate : unary_function<T,T> {
  T operator()(const T& x) const;
};


// clause _lib.comparisons_, comparisons:
template <class T> struct equal_to : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct not_equal_to : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct greater : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct less : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct greater_equal : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct less_equal : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};


// clause _lib.logical.operations_, logical operations:
template <class T> struct logical_and : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct logical_or : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct logical_not : unary_function<T,bool> {
  bool operator()(const T& x) const;
};


// clause _lib.negators_, negators:
template <class Predicate>
class unary_negate
  : public unary_function<Predicate::argument_type, bool>
{
public:
  explicit unary_negate(const Predicate& pred);
  bool operator()(const argument_type& x) const;
};






template <class Predicate>
class binary_negate
  : public binary_function<Predicate::first_argument_type,
                           Predicate::second_argument_type, bool>
{
public:
  explicit binary_negate(const Predicate& pred);
  bool operator()(const first_argument_type& x,
                  const second_argument_type& y) const;
};

// operations omitted (cint can't handle template forward decls...)







// clause _lib.binders_, binders:
template <class Operation>
class binder1st
  : public unary_function<Operation::second_argument_type,
                          Operation::result_type>
{
protected:
  Operation op;
  Operation::first_argument_type value;
public:
  binder1st(const Operation& x, const Operation::first_argument_type& y);
  result_type operator()(const argument_type& x) const;
};


// operations omitted (cint can't handle template forward decls...)





template <class Operation>
class binder2nd
  : public unary_function<Operation::first_argument_type,
                          Operation::result_type>
{
protected:
  Operation op;
  Operation::second_argument_type value;
public:
  binder2nd(const Operation& x, const Operation::second_argument_type& y);
  result_type operator()(const argument_type& x) const;
};


// operations omitted (cint can't handle template forward decls...)






// clause _lib.function.pointer.adaptors_, adaptors:
template <class Arg, class Result>
class pointer_to_unary_function
  : public unary_function<Arg, Result>
{
public:
  explicit pointer_to_unary_function(Result (*f)(Arg));
  Result operator()(Arg x) const;
};

// operations omitted (cint can't handle template forward decls...)





template <class Arg1, class Arg2, class Result>
class pointer_to_binary_function
  : public binary_function<Arg1,Arg2,Result>
{
public:
  explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));
  Result operator()(Arg1 x, Arg2 y) const;
};

// operations omitted (cint can't handle template forward decls...)






// omit these for now.
# 230 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/functional"
#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_functional" 2
# 30 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap" 2

//////////////////////////////////////////////////////////////////////////

// This does not work yet. Don't know why.
template<class Key,class T,class Compare=std::less<Key>
        ,class Allocator=std::allocator<pair<const Key,T> > >
# 63 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap"
class multimap {
 public:
  typedef Key key_type;
  typedef T mapped_type;
  typedef pair<Key,T> value_type;
  //typedef pair<const Key,T>                         value_type;
  typedef Compare key_compare;
  typedef Allocator allocator_type;

  //typedef Key*                                     pointer;
  //typedef const Key*                               const_pointer;
  //typedef Key&                                     reference;
  //typedef const Key&                               const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
# 87 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap"
  class iterator
# 100 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap"
 {
   public:
    iterator() ;
    iterator(const iterator& x) ;

    iterator& operator=(const iterator& x) ;

    value_type& operator*() ;

    value_type* operator->() ;

    iterator& operator++();
    iterator operator++(int a);
    iterator& operator--();
    iterator operator--(int a);

    bool operator==(const iterator& x) ;
    bool operator!=(const iterator& x) ;




  };
# 131 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap"
  class reverse_iterator
# 144 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap"
 {
   public:
    reverse_iterator(const reverse_iterator& x);

    reverse_iterator& operator=(const reverse_iterator& x) ;

    value_type& operator*() ;

    value_type* operator->() ;

    reverse_iterator& operator++();
    reverse_iterator operator++(int a);
    reverse_iterator& operator--();
    reverse_iterator operator--(int a);
   private:
  };

  friend bool operator==(const multimap::reverse_iterator& x
                        ,const multimap::reverse_iterator& y) const;
  friend bool operator!=(const multimap::reverse_iterator& x
                        ,const multimap::reverse_iterator& y) const;


  typedef const iterator const_iterator;
  typedef const reverse_iterator const_reverse_iterator;

  // _lib.multimap.cons_ construct/copy/destroy:
  multimap();






  multimap(iterator first, iterator last);
  multimap(reverse_iterator first, reverse_iterator last);

  multimap(const multimap& x);
  ~multimap();
  multimap& operator=(const multimap& x);
  // iterators:
  iterator begin();
  iterator end();
  reverse_iterator rbegin();
  reverse_iterator rend();






  // capacity:
  bool empty() const;
  size_type size() const;
  size_type max_size() const;
  // _lib.multimap.access_ element access:
  //T& operator[](const Key& x);
  // modifiers:
  iterator insert(const value_type& x);
  iterator insert(iterator position, const value_type& x);





  void insert(iterator first, iterator last);
  void insert(reverse_iterator first, reverse_iterator last);

  void erase(iterator position);
  size_type erase(const Key& x);
  void erase(iterator first, iterator last);
  void swap(multimap&);
  void clear();
  // observers:
  //key_compare   key_comp() const;
  //value_compare value_comp() const;
  // _lib.multimap.ops_ multimap operations:
  iterator find(const Key& x);
  //const_iterator find(const Key& x) const;
  size_type count(const Key& x) const;
  iterator lower_bound(const Key& x);
  //const_iterator lower_bound(const Key& x) const;
  iterator upper_bound(const Key& x);
  //const_iterator upper_bound(const Key& x) const;





  friend bool operator==(const multimap& x, const multimap& y);
  friend bool operator< (const multimap& x, const multimap& y);
  friend bool operator!=(const multimap& x, const multimap& y);
  friend bool operator> (const multimap& x, const multimap& y);
  friend bool operator>=(const multimap& x, const multimap& y);
  friend bool operator<=(const multimap& x, const multimap& y);
  // specialized algorithms:





#pragma ifndef G__NOALGORITHM
  // Generic algorithm
  friend multimap::iterator
    search(multimap::iterator first1,multimap::iterator last1,
           multimap::iterator first2,multimap::iterator last2);
#pragma endif


  // Generic algorithm
  //friend void reverse(multimap::iterator first,multimap::iterator last);
  //friend void reverse(multimap::reverse_iterator first,multimap::reverse_itetator last);

  // iterator_category resolution
  //friend bidirectional_iterator_tag iterator_category(multimap::iterator x);

};

//////////////////////////////////////////////////////////////////////////

#pragma endif
# 16 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_multimap" 2
# 26 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_map" 2
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/map" 2
}
# 22 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooArgSet.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iostream" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iostream.h" 1
/* /% C++ %/ */
/***********************************************************************
 * cint (C/C++ interpreter)
 ************************************************************************
 * I/O stream header file iostream.h
 ************************************************************************
 * Description:
 *  CINT iostream header file
 ************************************************************************
 * Copyright(c) 1995~1999  Masaharu Goto 
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
# 11 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iostream" 2
}
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/_iostream" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// include/_iostream

std::ostream& operator<<(std::ostream& ostr,std::G__CINT_ENDL& i)
 {return(std::endl(ostr));}
std::ostream& operator<<(std::ostream& ostr,std::G__CINT_ENDS& i)
 {return(std::ends(ostr));}
std::ostream& operator<<(std::ostream& ostr,std::G__CINT_FLUSH& i)
 {return(std::flush(ostr));}

std::istream& operator>>(std::istream& istr,std::G__CINT_ws& i)
 {return(std::ws(istr));}
std::istream& operator>>(std::istream& istr,std::G__CINT_WS& i)
 {return(std::WS(istr));}


std::ostream& operator<<(std::ostream& ostr,std::G__CINT_IOFLAGS& f) {
   ostr.setf(f.flag, f.mask);
  return ostr;
}
std::istream& operator>>(std::istream& istr,std::G__CINT_IOFLAGS& f) {
  istr.setf(f.flag, f.mask);
  return istr;
}

std::ostream& operator<<(std::ostream& ostr,std::G__CINT_NOSUPPORT& i) {
  fprintf(stderr,"Limitation: dec,hex,oct manipurator not supported\n");
  return(ostr);
}
std::istream& operator<<(std::istream& istr,std::G__CINT_NOSUPPORT& i) {
  fprintf(stderr,"Limitation: dec,hex,oct manipurator not supported\n");
  return(istr);
}


std::ostream& operator<<(std::ostream& ostr,long long i) {
  char buf[200];
#pragma ifndef G__TMPLTIOS
  if (ostr.flags() & ios::hex)
#pragma else
  if (ostr.flags() & ios_base::hex)
#pragma endif
     sprintf(buf,"%llx",i);
  else
     sprintf(buf,"%lld",i);
  ostr << buf ;
  return(ostr);
}
std::ostream& operator<<(std::ostream& ostr,unsigned long long i) {
  char buf[200];
#pragma ifndef G__TMPLTIOS
  if (ostr.flags() & ios::hex)
#pragma else
  if (ostr.flags() & ios_base::hex)
#pragma endif
     sprintf(buf,"%llx",i);
  else
     sprintf(buf,"%llu",i);
  ostr << buf ;
  return(ostr);
}
std::ostream& operator<<(std::ostream& ostr,long double i) {
  char buf[200];
  sprintf(buf,"%Lg",i);
  ostr << buf ;
  return(ostr);
}
std::istream& operator>>(std::istream& istr,long long &i) {
  char buf[200];
  istr >> buf ;
  sscanf(buf,"%lld",&i);
  return(istr);
}
std::istream& operator>>(std::istream& istr,unsigned long long &i) {
  char buf[200];
  istr >> buf ;
#pragma ifndef G__TMPLTIOS
  if (ostr.flags() & ios::hex)
#pragma else
  if (ostr.flags() & ios_base::hex)
#pragma endif
     sscanf(buf,"%llx",&i);
  else
     sscanf(buf,"%llu",&i);
  return(istr);
}
std::istream& operator>>(std::istream& istr,long double &i) {
  char buf[200];
  istr >> buf ;
  sscanf(buf,"%Lg",&i);
  return(istr);
}


// Value evaluation
//template<class T> int G__ateval(const T* x) {return(0);}
//template<class T> int G__ateval(const T& x) {return(0);}
int G__ateval(const char* const &x) {return(0);}
//int G__ateval(const void* const &x) {return(0);}
int G__ateval(double x) {return(0);}
int G__ateval(float x) {return(0);}
int G__ateval(bool x) {return(0);}
int G__ateval(char x) {return(0);}
int G__ateval(short x) {return(0);}
int G__ateval(int x) {return(0);}
int G__ateval(long x) {return(0);}
int G__ateval(unsigned char x) {return(0);}
int G__ateval(unsigned short x) {return(0);}
int G__ateval(unsigned int x) {return(0);}
int G__ateval(unsigned long x) {return(0);}
# 127 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/_iostream"
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iomanip.h" 1
/* /% C++ %/ */
/***********************************************************************
 * cint (C/C++ interpreter)
 ************************************************************************
 * I/O manipulator header for iomanip.h
 ************************************************************************
 * Description:
 *  CINT IOMANIP header file
 ************************************************************************
 * Author                  Masaharu Goto 
 * Copyright(c) 1995~1999  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
# 127 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/_iostream" 2
# 12 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iostream" 2
# 23 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooArgSet.h" 2

class RooArgList ;




class RooArgSet : public RooAbsCollection {
public:


  void* operator new (size_t bytes);
  void operator delete (void *ptr);


  // Constructors, assignment etc.
  RooArgSet();
  RooArgSet(const RooArgList& list) ;
  RooArgSet(const RooArgList& list, const RooAbsArg* var1) ;
  explicit RooArgSet(const TCollection& tcoll, const char* name="") ;
  explicit RooArgSet(const char *name);
  RooArgSet(const RooArgSet& set1, const RooArgSet& set2,
     const char *name="");
  RooArgSet(const RooAbsArg& var1,
     const char *name="");
  RooArgSet(const RooAbsArg& var1, const RooAbsArg& var2,
     const char *name="");
  RooArgSet(const RooAbsArg& var1, const RooAbsArg& var2,
     const RooAbsArg& var3,
     const char *name="");
  RooArgSet(const RooAbsArg& var1, const RooAbsArg& var2,
     const RooAbsArg& var3, const RooAbsArg& var4,
     const char *name="");
  RooArgSet(const RooAbsArg& var1, const RooAbsArg& var2,
     const RooAbsArg& var3, const RooAbsArg& var4,
     const RooAbsArg& var5,
     const char *name="");
  RooArgSet(const RooAbsArg& var1, const RooAbsArg& var2,
     const RooAbsArg& var3, const RooAbsArg& var4,
     const RooAbsArg& var5, const RooAbsArg& var6,
     const char *name="");
  RooArgSet(const RooAbsArg& var1, const RooAbsArg& var2,
            const RooAbsArg& var3, const RooAbsArg& var4,
     const RooAbsArg& var5, const RooAbsArg& var6,
     const RooAbsArg& var7,
     const char *name="");
  RooArgSet(const RooAbsArg& var1, const RooAbsArg& var2,
            const RooAbsArg& var3, const RooAbsArg& var4,
     const RooAbsArg& var5, const RooAbsArg& var6,
     const RooAbsArg& var7, const RooAbsArg& var8,
     const char *name="");
  RooArgSet(const RooAbsArg& var1, const RooAbsArg& var2,
            const RooAbsArg& var3, const RooAbsArg& var4,
     const RooAbsArg& var5, const RooAbsArg& var6,
     const RooAbsArg& var7, const RooAbsArg& var8,
     const RooAbsArg& var9, const char *name="");

  virtual ~RooArgSet();
  // Create a copy of an existing list. New variables cannot be added
  // to a copied list. The variables in the copied list are independent
  // of the original variables.
  RooArgSet(const RooArgSet& other, const char *name="");
  virtual TObject* clone(const char* newname) const { return new RooArgSet(*this,newname); }
  virtual TObject* create(const char* newname) const { return new RooArgSet(newname); }
  RooArgSet& operator=(const RooArgSet& other) { RooAbsCollection::operator=(other) ; return *this ;}

  virtual Bool_t add(const RooAbsArg& var, Bool_t silent=kFALSE) ;
  virtual Bool_t add(const RooAbsCollection& list, Bool_t silent=kFALSE) {
    // Add all elements in list to collection
    return RooAbsCollection::add(list,silent) ;
  }
  virtual Bool_t addOwned(RooAbsArg& var, Bool_t silent=kFALSE);
  virtual Bool_t addOwned(const RooAbsCollection& list, Bool_t silent=kFALSE) {
    // Add all elements in list as owned components to collection
    return RooAbsCollection::addOwned(list,silent) ;
  }
  virtual RooAbsArg *addClone(const RooAbsArg& var, Bool_t silent=kFALSE) ;
  virtual void addClone(const RooAbsCollection& list, Bool_t silent=kFALSE) {
    // Add owned clone of all elements of list to collection
    RooAbsCollection::addClone(list,silent) ;
  }

  RooAbsArg& operator[](const char* name) const ;

  virtual Bool_t readFromStream(std::istream& is, Bool_t compact, Bool_t verbose=kFALSE) {
    // I/O streaming interface (machine readable)
    return readFromStream(is, compact, 0, 0, verbose) ;
  }
  Bool_t readFromStream(std::istream& is, Bool_t compact, const char* flagReadAtt, const char* section, Bool_t verbose=kFALSE) ;
  virtual void writeToStream(std::ostream& os, Bool_t compact, const char* section=0) const;
  void writeToFile(const char* fileName) const ;
  Bool_t readFromFile(const char* fileName, const char* flagReadAtt=0, const char* section=0, Bool_t verbose=kFALSE) ;

  // Utilities functions when used as configuration object
  Double_t getRealValue(const char* name, Double_t defVal=0, Bool_t verbose=kFALSE) const ;
  const char* getCatLabel(const char* name, const char* defVal="", Bool_t verbose=kFALSE) const ;
  Int_t getCatIndex(const char* name, Int_t defVal=0, Bool_t verbose=kFALSE) const ;
  const char* getStringValue(const char* name, const char* defVal="", Bool_t verbose=kFALSE) const ;
  Bool_t setRealValue(const char* name, Double_t newVal=0, Bool_t verbose=kFALSE) ;
  Bool_t setCatLabel(const char* name, const char* newVal="", Bool_t verbose=kFALSE) ;
  Bool_t setCatIndex(const char* name, Int_t newVal=0, Bool_t verbose=kFALSE) ;
  Bool_t setStringValue(const char* name, const char* newVal="", Bool_t verbose=kFALSE) ;

  static void cleanup() ;

  Bool_t isInRange(const char* rangeSpec) ;

protected:

  Bool_t checkForDup(const RooAbsArg& arg, Bool_t silent) const ;

  static char* _poolBegin ; //! Start of memory pool
  static char* _poolCur ; //! Next free slot in memory pool
  static char* _poolEnd ; //! End of memory pool  

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return RooArgSet::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooArgSet::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooArgSet.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 137; } // Set of RooAbsArg objects
};
# 23 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsReal.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooArgList.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooArgList.h,v 1.14 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsCollection.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooAbsCollection.h,v 1.26 2007/08/09 19:55:47 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooArgList.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooErrorHandler.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooErrorHandler.h,v 1.4 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2002, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooArgList.h" 2

class RooArgList : public RooAbsCollection {
public:

  // Constructors, assignment etc.
  RooArgList();
  RooArgList(const RooArgSet& set) ;
  explicit RooArgList(const TCollection& tcoll, const char* name="") ;
  explicit RooArgList(const char *name);
  RooArgList(const RooAbsArg& var1,
      const char *name="");
  RooArgList(const RooAbsArg& var1, const RooAbsArg& var2,
      const char *name="");
  RooArgList(const RooAbsArg& var1, const RooAbsArg& var2,
      const RooAbsArg& var3,
      const char *name="");
  RooArgList(const RooAbsArg& var1, const RooAbsArg& var2,
      const RooAbsArg& var3, const RooAbsArg& var4,
      const char *name="");
  RooArgList(const RooAbsArg& var1, const RooAbsArg& var2,
      const RooAbsArg& var3, const RooAbsArg& var4,
      const RooAbsArg& var5,
      const char *name="");
  RooArgList(const RooAbsArg& var1, const RooAbsArg& var2,
      const RooAbsArg& var3, const RooAbsArg& var4,
      const RooAbsArg& var5, const RooAbsArg& var6,
      const char *name="");
  RooArgList(const RooAbsArg& var1, const RooAbsArg& var2,
      const RooAbsArg& var3, const RooAbsArg& var4,
      const RooAbsArg& var5, const RooAbsArg& var6,
      const RooAbsArg& var7,
      const char *name="");
  RooArgList(const RooAbsArg& var1, const RooAbsArg& var2,
      const RooAbsArg& var3, const RooAbsArg& var4,
      const RooAbsArg& var5, const RooAbsArg& var6,
      const RooAbsArg& var7, const RooAbsArg& var8,
      const char *name="");
  RooArgList(const RooAbsArg& var1, const RooAbsArg& var2,
      const RooAbsArg& var3, const RooAbsArg& var4,
      const RooAbsArg& var5, const RooAbsArg& var6,
      const RooAbsArg& var7, const RooAbsArg& var8,
      const RooAbsArg& var9, const char *name="");

  virtual ~RooArgList();
  // Create a copy of an existing list. New variables cannot be added
  // to a copied list. The variables in the copied list are independent
  // of the original variables.
  RooArgList(const RooArgList& other, const char *name="");
  virtual TObject* clone(const char* newname) const { return new RooArgList(*this,newname); }
  virtual TObject* create(const char* newname) const { return new RooArgList(newname); }
  RooArgList& operator=(const RooArgList& other) { RooAbsCollection::operator=(other) ; return *this ; }

  inline void sort(Bool_t reverse=kFALSE) {
    // Sort list in requested order
    _list.Sort(!reverse) ;
  }
  inline Int_t index(const RooAbsArg* arg) const {
    // Returns index of given arg, or -1 if arg is not in list
    return _list.IndexOf(arg) ;
  }
  inline Int_t index(const char* name) const {
    // Returns index of given arg, or -1 if arg is not in list
    return _list.IndexOf(name) ;
  }
  inline RooAbsArg* at(Int_t idx) const {
    // Return object at given index, or 0 if index is out of range
    return (RooAbsArg*) _list.At(idx) ;
  }

  // I/O streaming interface (machine readable)
  virtual Bool_t readFromStream(std::istream& is, Bool_t compact, Bool_t verbose=kFALSE) ;
  virtual void writeToStream(std::ostream& os, Bool_t compact) ;

  RooAbsArg& operator[](Int_t idx) const ;

protected:

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return RooArgList::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooArgList::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooArgList.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 98; } // Ordered list of RooAbsArg objects
};
# 24 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsReal.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooGlobalFunc.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooGlobalFunc.h,v 1.14 2007/07/16 21:04:28 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCmdArg.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooCmdArg.h,v 1.10 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooGlobalFunc.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/map" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_map" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <pair.dll>
#pragma include_noerr <map.dll>
#pragma include_noerr <map2.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/map

#pragma ifndef PREC_STL_MAP
#pragma define PREC_STL_MAP
#pragma link off global PREC_STL_MAP;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from ANSI/ISO C++ 1997/Nov draft 
// Got some ideas from Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <utility.dll>


#pragma include_noerr <pair.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/utility

#pragma ifndef PREC_STL_UTILITY
#pragma define PREC_STL_UTILITY
#pragma link off global PREC_STL_UTILITY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

template <class T1, class T2>
struct pair {
  T1 first;
  T2 second;
  pair() : first(T1()), second(T2()) {}
  pair(const T1& a, const T2& b) : first(a), second(b) {}
 private:
  pair& operator=(const pair& x){first=x.first;second=x.second;return *this;}
};

#pragma endif
# 17 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 2
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <memory.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/memory

#pragma ifndef PREC_STL_MEMORY
#pragma define PREC_STL_MEMORY
#pragma link off global PREC_STL_MEMORY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////


template <class _Tp>
class allocator {
  //typedef alloc _Alloc;          // The underlying allocator.
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  typedef typename _Tp* pointer;
  typedef const typename _Tp * const_pointer;




  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() ;
  allocator(const allocator&) ;
  //template <class _Tp1> allocator(const allocator<_Tp1>&) ;
  ~allocator() ;

  pointer address(reference __x) const ;
  const_pointer address(const_reference __x) const ;

  // __n is permitted to be 0.  The C++ standard says nothing about what
  // the return value is when __n == 0.
  _Tp* allocate(size_type __n, const void* = 0) ;

  // __p is not permitted to be a null pointer.
  void deallocate(pointer __p, size_type __n);

  size_type max_size() const ;

  void construct(pointer __p, const _Tp& __val) ;
  void destroy(pointer __p) ;
};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;
  typedef void value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };
};
//////////////////////////////////////////////////////////////////////
# 205 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////

/**********************************************************************
* auto_ptr
**********************************************************************/
template <class X> class auto_ptr {
private:
  X* ptr;
  //template<class Y> struct auto_ptr_ref { };
public:
  typedef X element_type;
  explicit auto_ptr(X* p = 0) : ptr(p) {}
  auto_ptr(auto_ptr& a) {ptr=a.ptr;}

  // this implementation may not be correct
  template <class T> auto_ptr(auto_ptr<T>& a) {ptr=a.release();}
# 229 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  auto_ptr& operator=(auto_ptr& a) {
    if (a.ptr != ptr) {
      delete ptr;
      ptr = a.ptr;
    }
    return(*this);
  }

  // this implementation may not be correct
  template <class T> auto_ptr& operator=(auto_ptr<T>& a) {
    if (a.ptr != ptr) {
       delete ptr;
       ptr = a.release();
    }
    return(*this);
  }

  ~auto_ptr() { delete ptr; }

  X& operator*() const { return *ptr; }
  X* operator->() const { return ptr; }
  X* get() const { return ptr; }
  X* release() { X *old = ptr; ptr = 0; return 0; }
# 262 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  // auto_ptr conversions
  //auto_ptr(auto_ptr_ref<X>& x) { }
  //template<class Y> operator auto_ptr_ref<Y>() { return auto_ptr_ref<Y>(); }
  //template<class Y> operator auto_ptr<Y>() { return auto_ptr<T>(); }
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 2
# 28 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <iterator.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/iterator

#pragma ifndef PREC_STL_ITERATOR
#pragma define PREC_STL_ITERATOR
#pragma link off global PREC_STL_ITERATOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from STL HP implementation 1994
// Imported from STL SGI implementation 1997 
// Imported from ANSI/ISO C++ draft Nov 1997
// Modified by Masaharu Goto
// May need improvement for the latest standard


////////////////////////////////////////////////////////////////////////
// iterator_tag
////////////////////////////////////////////////////////////////////////
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag {};
struct bidirectional_iterator_tag {};
struct random_access_iterator_tag {};

////////////////////////////////////////////////////////////////////////
// iterator template
////////////////////////////////////////////////////////////////////////
template <class T, class Distance> struct input_iterator {};
struct output_iterator {};
template <class T, class Distance> struct forward_iterator {};
template <class T, class Distance> struct bidirectional_iterator {};
template <class T, class Distance> struct random_access_iterator {};

#pragma link off class output_iterator;







////////////////////////////////////////////////////////////////////////
// iterator_category overloaded function
////////////////////////////////////////////////////////////////////////
template <class T, class Distance>
inline input_iterator_tag
iterator_category(const input_iterator<T, Distance>&) {
    return input_iterator_tag();
}

inline output_iterator_tag iterator_category(const output_iterator&) {
    return output_iterator_tag();
}

#pragma link off function iterator_category(const output_iterator&);


template <class T, class Distance>
inline forward_iterator_tag
iterator_category(const forward_iterator<T, Distance>&) {
    return forward_iterator_tag();
}

template <class T, class Distance>
inline bidirectional_iterator_tag
iterator_category(const bidirectional_iterator<T, Distance>&) {
    return bidirectional_iterator_tag();
}

template <class T, class Distance>
inline random_access_iterator_tag
iterator_category(const random_access_iterator<T, Distance>&) {
    return random_access_iterator_tag();
}

template <class T>
inline random_access_iterator_tag
iterator_category(const T*) {
    return random_access_iterator_tag();
}


// iterator_traits, iterator and reverse_iterator template may not be
// needed for precompiled library interface 

////////////////////////////////////////////////////////////////////////
// iterator_traits
////////////////////////////////////////////////////////////////////////

template <class Iterator>
struct iterator_traits {
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type value_type;
  typedef typename Iterator::difference_type difference_type;
  typedef typename Iterator::pointer pointer;
  typedef typename Iterator::reference reference;
};

// template partial specialization, implement in cint5.15.14 1587
template <class T>
struct iterator_traits<T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
};

// incomplete implementation in cint5.15.14 1587, need some fix
// iterator_traits<const int*> is changed as iterator_traits<const int* const>
// or something, but cint5.15.14 can not handle this well
template <class T>
struct iterator_traits<const T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef const T* pointer;
  typedef const T& reference;
};

////////////////////////////////////////////////////////////////////////
// iterator
////////////////////////////////////////////////////////////////////////
template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator {
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
  typedef Category iterator_category;
};


////////////////////////////////////////////////////////////////////////
// reverse_iterator
////////////////////////////////////////////////////////////////////////






template <class Iterator>
class reverse_iterator
# 166 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
{




 public:
# 181 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
   typedef Iterator::pointer pointer;
   typedef Iterator::reference reference;
   typedef ptrdiff_t difference_type;


   reverse_iterator();
   //reverse_iterator(Iterator x);



   Iterator base() const; // explicit
   reference operator*() const;
   pointer operator->() const;
   reverse_iterator& operator++();
   reverse_iterator operator++(int);
   reverse_iterator& operator--();
   reverse_iterator operator--(int);
   reverse_iterator operator+ (difference_type n) const;
   reverse_iterator& operator+=(difference_type n);
   reverse_iterator operator- (difference_type n) const;
   reverse_iterator& operator-=(difference_type n);
   reference operator[](difference_type n) const;
};
# 932 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
// for g++ 3.1,3.2
namespace __gnu_cxx
{
  // This iterator adapter is 'normal' in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                    difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparaison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  // _GLIBCPP_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
     const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
} // namespace __gnu_cxx







#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 2
# 29 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_functional" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <functional.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/functional" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/functional

#pragma ifndef PREC_STL_FUNCTIONAL
#pragma define PREC_STL_FUNCTIONAL
#pragma link off global PREC_STL_FUNCTIONAL;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab

// clause _lib.base_, base:
template <class Arg, class Result>
struct unary_function
{
  typedef Arg argument_type;
  typedef Result result_type;
};


template <class Arg1, class Arg2, class Result>
struct binary_function
{
  typedef Arg1 first_argument_type;
  typedef Arg2 second_argument_type;
  typedef Result result_type;
};


// clause _lib.arithmetic.operations_, arithmetic operations:
template <class T> struct plus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct minus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct multiplies : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct divides : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};

template <class T> struct modulus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};

template <class T> struct negate : unary_function<T,T> {
  T operator()(const T& x) const;
};


// clause _lib.comparisons_, comparisons:
template <class T> struct equal_to : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct not_equal_to : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct greater : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct less : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct greater_equal : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct less_equal : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};


// clause _lib.logical.operations_, logical operations:
template <class T> struct logical_and : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct logical_or : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct logical_not : unary_function<T,bool> {
  bool operator()(const T& x) const;
};


// clause _lib.negators_, negators:
template <class Predicate>
class unary_negate
  : public unary_function<Predicate::argument_type, bool>
{
public:
  explicit unary_negate(const Predicate& pred);
  bool operator()(const argument_type& x) const;
};






template <class Predicate>
class binary_negate
  : public binary_function<Predicate::first_argument_type,
                           Predicate::second_argument_type, bool>
{
public:
  explicit binary_negate(const Predicate& pred);
  bool operator()(const first_argument_type& x,
                  const second_argument_type& y) const;
};

// operations omitted (cint can't handle template forward decls...)







// clause _lib.binders_, binders:
template <class Operation>
class binder1st
  : public unary_function<Operation::second_argument_type,
                          Operation::result_type>
{
protected:
  Operation op;
  Operation::first_argument_type value;
public:
  binder1st(const Operation& x, const Operation::first_argument_type& y);
  result_type operator()(const argument_type& x) const;
};


// operations omitted (cint can't handle template forward decls...)





template <class Operation>
class binder2nd
  : public unary_function<Operation::first_argument_type,
                          Operation::result_type>
{
protected:
  Operation op;
  Operation::second_argument_type value;
public:
  binder2nd(const Operation& x, const Operation::second_argument_type& y);
  result_type operator()(const argument_type& x) const;
};


// operations omitted (cint can't handle template forward decls...)






// clause _lib.function.pointer.adaptors_, adaptors:
template <class Arg, class Result>
class pointer_to_unary_function
  : public unary_function<Arg, Result>
{
public:
  explicit pointer_to_unary_function(Result (*f)(Arg));
  Result operator()(Arg x) const;
};

// operations omitted (cint can't handle template forward decls...)





template <class Arg1, class Arg2, class Result>
class pointer_to_binary_function
  : public binary_function<Arg1,Arg2,Result>
{
public:
  explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));
  Result operator()(Arg1 x, Arg2 y) const;
};

// operations omitted (cint can't handle template forward decls...)






// omit these for now.
# 230 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/functional"
#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_functional" 2
# 30 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map" 2

//////////////////////////////////////////////////////////////////////////

template<class Key,class T,class Compare=std::less<Key>
        ,class Allocator=std::allocator<pair<const Key, T> > >
# 63 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map"
class map {
 public:
  typedef Key key_type;
  typedef T mapped_type;



  typedef pair<Key,T> value_type;

  typedef Compare key_compare;
  typedef Allocator allocator_type;

  //typedef Key*                                     pointer;
  //typedef const Key*                               const_pointer;
  //typedef Key&                                     reference;
  //typedef const Key&                               const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
# 90 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map"
  class iterator
# 103 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map"
 {
   public:
    iterator() ;
    iterator(const iterator& x) ;

    iterator& operator=(const iterator& x) ;

    value_type& operator*() ;

    value_type* operator->() ;

    iterator& operator++();
    iterator operator++(int a);
    iterator& operator--();
    iterator operator--(int a);

    bool operator==(const iterator& x) ;
    bool operator!=(const iterator& x) ;




  };
# 134 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map"
  class reverse_iterator
# 147 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map"
 {
   public:
    reverse_iterator(const reverse_iterator& x);

    reverse_iterator& operator=(const reverse_iterator& x) ;

    value_type& operator*() ;

    value_type* operator->() ;

    reverse_iterator& operator++();
    reverse_iterator operator++(int a);
    reverse_iterator& operator--();
    reverse_iterator operator--(int a);
   private:
  };

  friend bool operator==(const map::reverse_iterator& x
                        ,const map::reverse_iterator& y) const;
  friend bool operator!=(const map::reverse_iterator& x
                        ,const map::reverse_iterator& y) const;


  typedef const iterator const_iterator;
  typedef const reverse_iterator const_reverse_iterator;

  // _lib.map.cons_ construct/copy/destroy:
  map();






  map(iterator first, iterator last);
  map(reverse_iterator first, reverse_iterator last);

  map(const map& x);
  ~map();
  map& operator=(const map& x);
  // iterators:
  iterator begin();
  iterator end();
  reverse_iterator rbegin();
  reverse_iterator rend();






  // capacity:
  bool empty() const;
  size_type size() const;
  size_type max_size() const;
  // _lib.map.access_ element access:
  T& operator[](const Key& x);
  // modifiers:
  pair<map::iterator, bool> insert(const value_type& x);
  iterator insert(iterator position, const value_type& x);





  void insert(iterator first, iterator last);
  void insert(reverse_iterator first, reverse_iterator last);

  void erase(iterator position);
  size_type erase(const Key& x);
  void erase(iterator first, iterator last);
  void swap(map&);
  void clear();
  // observers:
  //key_compare   key_comp() const;
  //value_compare value_comp() const;
  // _lib.map.ops_ map operations:
  iterator find(const Key& x);
  //const_iterator find(const Key& x) const;
  size_type count(const Key& x) const;
  iterator lower_bound(const Key& x);
  //const_iterator lower_bound(const Key& x) const;
  iterator upper_bound(const Key& x);
  //const_iterator upper_bound(const Key& x) const;





  friend bool operator==(const map& x, const map& y);
  friend bool operator< (const map& x, const map& y);
  friend bool operator!=(const map& x, const map& y);
  friend bool operator> (const map& x, const map& y);
  friend bool operator>=(const map& x, const map& y);
  friend bool operator<=(const map& x, const map& y);
  // specialized algorithms:





#pragma ifndef G__NOALGORITHM
  // Generic algorithm
  friend map::iterator
    search(map::iterator first1,map::iterator last1,
           map::iterator first2,map::iterator last2);
#pragma endif

  // iterator_category resolution
  //friend bidirectional_iterator_tag iterator_category(map::iterator x);

};

//////////////////////////////////////////////////////////////////////////

#pragma endif
# 16 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_map" 2
# 26 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_map"
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_multimap" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

//#pragma include_noerr <pair.dll> 
#pragma include_noerr <multimap.dll>
#pragma include_noerr <multimap2.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/multimap

#pragma ifndef PREC_STL_MULTIMAP
#pragma define PREC_STL_MULTIMAP
#pragma link off global PREC_STL_MULTIMAP;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from ANSI/ISO C++ 1997/Nov draft 
// Got some ideas from Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <utility.dll>


#pragma include_noerr <pair.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/utility

#pragma ifndef PREC_STL_UTILITY
#pragma define PREC_STL_UTILITY
#pragma link off global PREC_STL_UTILITY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

template <class T1, class T2>
struct pair {
  T1 first;
  T2 second;
  pair() : first(T1()), second(T2()) {}
  pair(const T1& a, const T2& b) : first(a), second(b) {}
 private:
  pair& operator=(const pair& x){first=x.first;second=x.second;return *this;}
};

#pragma endif
# 17 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 2
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <memory.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/memory

#pragma ifndef PREC_STL_MEMORY
#pragma define PREC_STL_MEMORY
#pragma link off global PREC_STL_MEMORY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////


template <class _Tp>
class allocator {
  //typedef alloc _Alloc;          // The underlying allocator.
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  typedef typename _Tp* pointer;
  typedef const typename _Tp * const_pointer;




  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() ;
  allocator(const allocator&) ;
  //template <class _Tp1> allocator(const allocator<_Tp1>&) ;
  ~allocator() ;

  pointer address(reference __x) const ;
  const_pointer address(const_reference __x) const ;

  // __n is permitted to be 0.  The C++ standard says nothing about what
  // the return value is when __n == 0.
  _Tp* allocate(size_type __n, const void* = 0) ;

  // __p is not permitted to be a null pointer.
  void deallocate(pointer __p, size_type __n);

  size_type max_size() const ;

  void construct(pointer __p, const _Tp& __val) ;
  void destroy(pointer __p) ;
};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;
  typedef void value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };
};
//////////////////////////////////////////////////////////////////////
# 205 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////

/**********************************************************************
* auto_ptr
**********************************************************************/
template <class X> class auto_ptr {
private:
  X* ptr;
  //template<class Y> struct auto_ptr_ref { };
public:
  typedef X element_type;
  explicit auto_ptr(X* p = 0) : ptr(p) {}
  auto_ptr(auto_ptr& a) {ptr=a.ptr;}

  // this implementation may not be correct
  template <class T> auto_ptr(auto_ptr<T>& a) {ptr=a.release();}
# 229 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  auto_ptr& operator=(auto_ptr& a) {
    if (a.ptr != ptr) {
      delete ptr;
      ptr = a.ptr;
    }
    return(*this);
  }

  // this implementation may not be correct
  template <class T> auto_ptr& operator=(auto_ptr<T>& a) {
    if (a.ptr != ptr) {
       delete ptr;
       ptr = a.release();
    }
    return(*this);
  }

  ~auto_ptr() { delete ptr; }

  X& operator*() const { return *ptr; }
  X* operator->() const { return ptr; }
  X* get() const { return ptr; }
  X* release() { X *old = ptr; ptr = 0; return 0; }
# 262 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  // auto_ptr conversions
  //auto_ptr(auto_ptr_ref<X>& x) { }
  //template<class Y> operator auto_ptr_ref<Y>() { return auto_ptr_ref<Y>(); }
  //template<class Y> operator auto_ptr<Y>() { return auto_ptr<T>(); }
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 2
# 28 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <iterator.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/iterator

#pragma ifndef PREC_STL_ITERATOR
#pragma define PREC_STL_ITERATOR
#pragma link off global PREC_STL_ITERATOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from STL HP implementation 1994
// Imported from STL SGI implementation 1997 
// Imported from ANSI/ISO C++ draft Nov 1997
// Modified by Masaharu Goto
// May need improvement for the latest standard


////////////////////////////////////////////////////////////////////////
// iterator_tag
////////////////////////////////////////////////////////////////////////
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag {};
struct bidirectional_iterator_tag {};
struct random_access_iterator_tag {};

////////////////////////////////////////////////////////////////////////
// iterator template
////////////////////////////////////////////////////////////////////////
template <class T, class Distance> struct input_iterator {};
struct output_iterator {};
template <class T, class Distance> struct forward_iterator {};
template <class T, class Distance> struct bidirectional_iterator {};
template <class T, class Distance> struct random_access_iterator {};

#pragma link off class output_iterator;







////////////////////////////////////////////////////////////////////////
// iterator_category overloaded function
////////////////////////////////////////////////////////////////////////
template <class T, class Distance>
inline input_iterator_tag
iterator_category(const input_iterator<T, Distance>&) {
    return input_iterator_tag();
}

inline output_iterator_tag iterator_category(const output_iterator&) {
    return output_iterator_tag();
}

#pragma link off function iterator_category(const output_iterator&);


template <class T, class Distance>
inline forward_iterator_tag
iterator_category(const forward_iterator<T, Distance>&) {
    return forward_iterator_tag();
}

template <class T, class Distance>
inline bidirectional_iterator_tag
iterator_category(const bidirectional_iterator<T, Distance>&) {
    return bidirectional_iterator_tag();
}

template <class T, class Distance>
inline random_access_iterator_tag
iterator_category(const random_access_iterator<T, Distance>&) {
    return random_access_iterator_tag();
}

template <class T>
inline random_access_iterator_tag
iterator_category(const T*) {
    return random_access_iterator_tag();
}


// iterator_traits, iterator and reverse_iterator template may not be
// needed for precompiled library interface 

////////////////////////////////////////////////////////////////////////
// iterator_traits
////////////////////////////////////////////////////////////////////////

template <class Iterator>
struct iterator_traits {
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type value_type;
  typedef typename Iterator::difference_type difference_type;
  typedef typename Iterator::pointer pointer;
  typedef typename Iterator::reference reference;
};

// template partial specialization, implement in cint5.15.14 1587
template <class T>
struct iterator_traits<T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
};

// incomplete implementation in cint5.15.14 1587, need some fix
// iterator_traits<const int*> is changed as iterator_traits<const int* const>
// or something, but cint5.15.14 can not handle this well
template <class T>
struct iterator_traits<const T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef const T* pointer;
  typedef const T& reference;
};

////////////////////////////////////////////////////////////////////////
// iterator
////////////////////////////////////////////////////////////////////////
template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator {
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
  typedef Category iterator_category;
};


////////////////////////////////////////////////////////////////////////
// reverse_iterator
////////////////////////////////////////////////////////////////////////






template <class Iterator>
class reverse_iterator
# 166 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
{




 public:
# 181 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
   typedef Iterator::pointer pointer;
   typedef Iterator::reference reference;
   typedef ptrdiff_t difference_type;


   reverse_iterator();
   //reverse_iterator(Iterator x);



   Iterator base() const; // explicit
   reference operator*() const;
   pointer operator->() const;
   reverse_iterator& operator++();
   reverse_iterator operator++(int);
   reverse_iterator& operator--();
   reverse_iterator operator--(int);
   reverse_iterator operator+ (difference_type n) const;
   reverse_iterator& operator+=(difference_type n);
   reverse_iterator operator- (difference_type n) const;
   reverse_iterator& operator-=(difference_type n);
   reference operator[](difference_type n) const;
};
# 932 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
// for g++ 3.1,3.2
namespace __gnu_cxx
{
  // This iterator adapter is 'normal' in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                    difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparaison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  // _GLIBCPP_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
     const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
} // namespace __gnu_cxx







#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 2
# 29 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_functional" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <functional.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/functional" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/functional

#pragma ifndef PREC_STL_FUNCTIONAL
#pragma define PREC_STL_FUNCTIONAL
#pragma link off global PREC_STL_FUNCTIONAL;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab

// clause _lib.base_, base:
template <class Arg, class Result>
struct unary_function
{
  typedef Arg argument_type;
  typedef Result result_type;
};


template <class Arg1, class Arg2, class Result>
struct binary_function
{
  typedef Arg1 first_argument_type;
  typedef Arg2 second_argument_type;
  typedef Result result_type;
};


// clause _lib.arithmetic.operations_, arithmetic operations:
template <class T> struct plus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct minus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct multiplies : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct divides : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};

template <class T> struct modulus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};

template <class T> struct negate : unary_function<T,T> {
  T operator()(const T& x) const;
};


// clause _lib.comparisons_, comparisons:
template <class T> struct equal_to : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct not_equal_to : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct greater : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct less : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct greater_equal : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct less_equal : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};


// clause _lib.logical.operations_, logical operations:
template <class T> struct logical_and : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct logical_or : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct logical_not : unary_function<T,bool> {
  bool operator()(const T& x) const;
};


// clause _lib.negators_, negators:
template <class Predicate>
class unary_negate
  : public unary_function<Predicate::argument_type, bool>
{
public:
  explicit unary_negate(const Predicate& pred);
  bool operator()(const argument_type& x) const;
};






template <class Predicate>
class binary_negate
  : public binary_function<Predicate::first_argument_type,
                           Predicate::second_argument_type, bool>
{
public:
  explicit binary_negate(const Predicate& pred);
  bool operator()(const first_argument_type& x,
                  const second_argument_type& y) const;
};

// operations omitted (cint can't handle template forward decls...)







// clause _lib.binders_, binders:
template <class Operation>
class binder1st
  : public unary_function<Operation::second_argument_type,
                          Operation::result_type>
{
protected:
  Operation op;
  Operation::first_argument_type value;
public:
  binder1st(const Operation& x, const Operation::first_argument_type& y);
  result_type operator()(const argument_type& x) const;
};


// operations omitted (cint can't handle template forward decls...)





template <class Operation>
class binder2nd
  : public unary_function<Operation::first_argument_type,
                          Operation::result_type>
{
protected:
  Operation op;
  Operation::second_argument_type value;
public:
  binder2nd(const Operation& x, const Operation::second_argument_type& y);
  result_type operator()(const argument_type& x) const;
};


// operations omitted (cint can't handle template forward decls...)






// clause _lib.function.pointer.adaptors_, adaptors:
template <class Arg, class Result>
class pointer_to_unary_function
  : public unary_function<Arg, Result>
{
public:
  explicit pointer_to_unary_function(Result (*f)(Arg));
  Result operator()(Arg x) const;
};

// operations omitted (cint can't handle template forward decls...)





template <class Arg1, class Arg2, class Result>
class pointer_to_binary_function
  : public binary_function<Arg1,Arg2,Result>
{
public:
  explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));
  Result operator()(Arg1 x, Arg2 y) const;
};

// operations omitted (cint can't handle template forward decls...)






// omit these for now.
# 230 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/functional"
#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_functional" 2
# 30 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap" 2

//////////////////////////////////////////////////////////////////////////

// This does not work yet. Don't know why.
template<class Key,class T,class Compare=std::less<Key>
        ,class Allocator=std::allocator<pair<const Key,T> > >
# 63 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap"
class multimap {
 public:
  typedef Key key_type;
  typedef T mapped_type;
  typedef pair<Key,T> value_type;
  //typedef pair<const Key,T>                         value_type;
  typedef Compare key_compare;
  typedef Allocator allocator_type;

  //typedef Key*                                     pointer;
  //typedef const Key*                               const_pointer;
  //typedef Key&                                     reference;
  //typedef const Key&                               const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
# 87 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap"
  class iterator
# 100 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap"
 {
   public:
    iterator() ;
    iterator(const iterator& x) ;

    iterator& operator=(const iterator& x) ;

    value_type& operator*() ;

    value_type* operator->() ;

    iterator& operator++();
    iterator operator++(int a);
    iterator& operator--();
    iterator operator--(int a);

    bool operator==(const iterator& x) ;
    bool operator!=(const iterator& x) ;




  };
# 131 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap"
  class reverse_iterator
# 144 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap"
 {
   public:
    reverse_iterator(const reverse_iterator& x);

    reverse_iterator& operator=(const reverse_iterator& x) ;

    value_type& operator*() ;

    value_type* operator->() ;

    reverse_iterator& operator++();
    reverse_iterator operator++(int a);
    reverse_iterator& operator--();
    reverse_iterator operator--(int a);
   private:
  };

  friend bool operator==(const multimap::reverse_iterator& x
                        ,const multimap::reverse_iterator& y) const;
  friend bool operator!=(const multimap::reverse_iterator& x
                        ,const multimap::reverse_iterator& y) const;


  typedef const iterator const_iterator;
  typedef const reverse_iterator const_reverse_iterator;

  // _lib.multimap.cons_ construct/copy/destroy:
  multimap();






  multimap(iterator first, iterator last);
  multimap(reverse_iterator first, reverse_iterator last);

  multimap(const multimap& x);
  ~multimap();
  multimap& operator=(const multimap& x);
  // iterators:
  iterator begin();
  iterator end();
  reverse_iterator rbegin();
  reverse_iterator rend();






  // capacity:
  bool empty() const;
  size_type size() const;
  size_type max_size() const;
  // _lib.multimap.access_ element access:
  //T& operator[](const Key& x);
  // modifiers:
  iterator insert(const value_type& x);
  iterator insert(iterator position, const value_type& x);





  void insert(iterator first, iterator last);
  void insert(reverse_iterator first, reverse_iterator last);

  void erase(iterator position);
  size_type erase(const Key& x);
  void erase(iterator first, iterator last);
  void swap(multimap&);
  void clear();
  // observers:
  //key_compare   key_comp() const;
  //value_compare value_comp() const;
  // _lib.multimap.ops_ multimap operations:
  iterator find(const Key& x);
  //const_iterator find(const Key& x) const;
  size_type count(const Key& x) const;
  iterator lower_bound(const Key& x);
  //const_iterator lower_bound(const Key& x) const;
  iterator upper_bound(const Key& x);
  //const_iterator upper_bound(const Key& x) const;





  friend bool operator==(const multimap& x, const multimap& y);
  friend bool operator< (const multimap& x, const multimap& y);
  friend bool operator!=(const multimap& x, const multimap& y);
  friend bool operator> (const multimap& x, const multimap& y);
  friend bool operator>=(const multimap& x, const multimap& y);
  friend bool operator<=(const multimap& x, const multimap& y);
  // specialized algorithms:





#pragma ifndef G__NOALGORITHM
  // Generic algorithm
  friend multimap::iterator
    search(multimap::iterator first1,multimap::iterator last1,
           multimap::iterator first2,multimap::iterator last2);
#pragma endif


  // Generic algorithm
  //friend void reverse(multimap::iterator first,multimap::iterator last);
  //friend void reverse(multimap::reverse_iterator first,multimap::reverse_itetator last);

  // iterator_category resolution
  //friend bidirectional_iterator_tag iterator_category(multimap::iterator x);

};

//////////////////////////////////////////////////////////////////////////

#pragma endif
# 16 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_multimap" 2
# 26 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_map" 2
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/map" 2
}
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooGlobalFunc.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/string" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_string" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// string
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/string" 2
}
# 22 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooGlobalFunc.h" 2
//#include "RooDataHist.h"
//#include "RooAbsPdf.h"
//#include "RooRealConstant.h"
//#include "RooMsgService.h"

class RooDataHist ;
class RooDataSet ;
class RooFitResult ;
class RooAbsPdf ;
class RooAbsRealLValue ;
class RooRealConstant ;
class RooMsgService ;
class RooFormulaVar ;
class RooAbsData ;
class RooArgSet ;
class RooCategory ;
class RooAbsReal ;
class RooAbsBinning ;
class RooAbsCollection ;
class RooAbsPdf ;
class RooConstVar ;
class RooRealVar ;
class RooAbsCategory ;
class RooNumIntConfig ;
class RooArgList ;
class RooAbsCollection ;
class TH1 ;
class TF1 ;
class TF2 ;
class TF3 ;
class TTree ;

namespace RooFit {

enum MsgLevel { DEBUG=0, INFO=1, PROGRESS=2, WARNING=3, ERROR=4, FATAL=5 } ;
enum MsgTopic { Generation=1, Minimization=2, Plotting=4, Fitting=8, Integration=16, LinkStateMgmt=32,
  Eval=64, Caching=128, Optimization=256, ObjectHandling=512, InputArguments=1024, Tracing=2048,
  Contents=4096, DataHandling=8192, NumIntegration=16384 } ;

// RooAbsReal::plotOn arguments
RooCmdArg DrawOption(const char* opt) ;
RooCmdArg Normalization(Double_t scaleFactor) ;
RooCmdArg Slice(const RooArgSet& sliceSet) ;
RooCmdArg Slice(RooCategory& cat, const char* label) ;
RooCmdArg Project(const RooArgSet& projSet) ;
RooCmdArg ProjWData(const RooAbsData& projData, Bool_t binData=kFALSE) ;
RooCmdArg ProjWData(const RooArgSet& projSet, const RooAbsData& projData, Bool_t binData=kFALSE) ;
RooCmdArg Asymmetry(const RooCategory& cat) ;
RooCmdArg Precision(Double_t prec) ;
RooCmdArg ShiftToZero() ;
RooCmdArg Range(const char* rangeName, Bool_t adjustNorm=kTRUE) ;
RooCmdArg Range(Double_t lo, Double_t hi, Bool_t adjustNorm=kTRUE) ;
RooCmdArg NormRange(const char* rangeNameList) ;
RooCmdArg VLines() ;
RooCmdArg LineColor(Color_t color) ;
RooCmdArg LineStyle(Style_t style) ;
RooCmdArg LineWidth(Width_t width) ;
RooCmdArg FillColor(Color_t color) ;
RooCmdArg FillStyle(Style_t style) ;
RooCmdArg ProjectionRange(const char* rangeName) ;
RooCmdArg Name(const char* name) ;
RooCmdArg Invisible() ;
RooCmdArg AddTo(const char* name, double wgtSel=1.0, double wgtOther=1.0) ;
RooCmdArg EvalErrorValue(Double_t value) ;
RooCmdArg MoveToBack() ;
RooCmdArg VisualizeError(const RooDataSet& paramData, Double_t Z=1) ;
RooCmdArg VisualizeError(const RooFitResult& fitres, Double_t Z=1, Bool_t linearMethod=kTRUE) ;
RooCmdArg VisualizeError(const RooFitResult& fitres, const RooArgSet& param, Double_t Z=1, Bool_t linearMethod=kTRUE) ;
RooCmdArg ShowProgress() ;

// RooAbsPdf::plotOn arguments
RooCmdArg Normalization(Double_t scaleFactor, Int_t scaleType) ;
RooCmdArg Components(const RooArgSet& compSet) ;
RooCmdArg Components(const char* compSpec) ;

// RooAbsData::plotOn arguments
RooCmdArg Cut(const char* cutSpec) ;
RooCmdArg Cut(const RooFormulaVar& cutVar) ;
RooCmdArg Binning(const RooAbsBinning& binning) ;
RooCmdArg Binning(const char* binningName) ;
RooCmdArg Binning(Int_t nBins, Double_t xlo=0., Double_t xhi=0.) ;
RooCmdArg MarkerStyle(Style_t style) ;
RooCmdArg MarkerSize(Size_t size) ;
RooCmdArg MarkerColor(Color_t color) ;
RooCmdArg CutRange(const char* rangeName) ;
RooCmdArg XErrorSize(Double_t width) ;
RooCmdArg RefreshNorm() ;
RooCmdArg Efficiency(const RooCategory& cat) ;
RooCmdArg Rescale(Double_t factor) ;

// RooDataHist::ctor arguments
RooCmdArg Weight(Double_t wgt) ;
RooCmdArg Index(RooCategory& icat) ;
RooCmdArg Import(const char* state, TH1& histo) ;
RooCmdArg Import(const std::map<std::string,TH1*>&) ;
RooCmdArg Import(const char* state, RooDataHist& dhist) ;
RooCmdArg Import(const std::map<std::string,RooDataHist*>&) ;
RooCmdArg Import(TH1& histo, Bool_t importDensity=kFALSE) ;

// RooDataSet::ctor arguments
RooCmdArg WeightVar(const char* name, Bool_t reinterpretAsWeight=kFALSE) ;
RooCmdArg WeightVar(const RooRealVar& arg, Bool_t reinterpretAsWeight=kFALSE) ;
RooCmdArg Import(const char* state, RooDataSet& data) ;
RooCmdArg Import(const std::map<std::string,RooDataSet*>& ) ;
RooCmdArg Link(const char* state, RooAbsData& data) ;
RooCmdArg Link(const std::map<std::string,RooAbsData*>&) ;
RooCmdArg Import(RooDataSet& data) ;
RooCmdArg Import(TTree& tree) ;
RooCmdArg ImportFromFile(const char* fname, const char* tname) ;
RooCmdArg StoreError(const RooArgSet& aset) ;
RooCmdArg StoreAsymError(const RooArgSet& aset) ;
RooCmdArg OwnLinked() ;

// RooChi2Var::ctor arguments
RooCmdArg Extended(Bool_t flag=kTRUE) ;
RooCmdArg DataError(Int_t) ;
RooCmdArg NumCPU(Int_t nCPU, Bool_t interleave=kFALSE) ;

// RooAbsPdf::printLatex arguments
RooCmdArg Columns(Int_t ncol) ;
RooCmdArg OutputFile(const char* fileName) ;
RooCmdArg Format(const char* format, Int_t sigDigit) ;
RooCmdArg Format(const char* what, const RooCmdArg& arg1=RooCmdArg::none(), const RooCmdArg& arg2=RooCmdArg::none(),
                 const RooCmdArg& arg3=RooCmdArg::none(),const RooCmdArg& arg4=RooCmdArg::none(),
                 const RooCmdArg& arg5=RooCmdArg::none(),const RooCmdArg& arg6=RooCmdArg::none(),
                 const RooCmdArg& arg7=RooCmdArg::none(),const RooCmdArg& arg8=RooCmdArg::none()) ;
RooCmdArg Sibling(const RooAbsCollection& sibling) ;

// RooAbsRealLValue::frame arguments
RooCmdArg Title(const char* name) ;
RooCmdArg Bins(Int_t nbin) ;
RooCmdArg AutoSymRange(const RooAbsData& data, Double_t marginFactor=0.1) ;
RooCmdArg AutoRange(const RooAbsData& data, Double_t marginFactor=0.1) ;

// RooAbsData::createHistogram arguments
RooCmdArg AutoSymBinning(Int_t nbins=100, Double_t marginFactor=0.1) ;
RooCmdArg AutoBinning(Int_t nbins=100, Double_t marginFactor=0.1) ;

// RooAbsReal::fillHistogram arguments
RooCmdArg IntegratedObservables(const RooArgSet& intObs) ;

// RooAbsData::reduce arguments
RooCmdArg SelectVars(const RooArgSet& vars) ;
RooCmdArg EventRange(Int_t nStart, Int_t nStop) ;

// RooAbsPdf::fitTo arguments
RooCmdArg FitOptions(const char* opts) ;
RooCmdArg Optimize(Int_t flag=2) ;
RooCmdArg ProjectedObservables(const RooArgSet& set) ; // obsolete, for backward compatibility
RooCmdArg ConditionalObservables(const RooArgSet& set) ;
RooCmdArg Verbose(Bool_t flag=kTRUE) ;
RooCmdArg Save(Bool_t flag=kTRUE) ;
RooCmdArg Timer(Bool_t flag=kTRUE) ;
RooCmdArg PrintLevel(Int_t code) ;
RooCmdArg Warnings(Bool_t flag=kTRUE) ;
RooCmdArg Strategy(Int_t code) ;
RooCmdArg InitialHesse(Bool_t flag=kTRUE) ;
RooCmdArg Hesse(Bool_t flag=kTRUE) ;
RooCmdArg Minos(Bool_t flag=kTRUE) ;
RooCmdArg Minos(const RooArgSet& minosArgs) ;
RooCmdArg SplitRange(Bool_t flag=kTRUE) ;
RooCmdArg SumCoefRange(const char* rangeName) ;
RooCmdArg Constrain(const RooArgSet& params) ;
RooCmdArg GlobalObservables(const RooArgSet& globs) ;
RooCmdArg GlobalObservablesTag(const char* tagName) ;
RooCmdArg Constrained() ;
RooCmdArg ExternalConstraints(const RooArgSet& constraintPdfs) ;
RooCmdArg PrintEvalErrors(Int_t numErrors) ;
RooCmdArg EvalErrorWall(Bool_t flag) ;
RooCmdArg SumW2Error(Bool_t flag) ;
RooCmdArg CloneData(Bool_t flag) ;
RooCmdArg Integrate(Bool_t flag) ;
RooCmdArg Minimizer(const char* type, const char* alg=0) ;
RooCmdArg Offset(Bool_t flag=kTRUE) ;

// RooAbsPdf::paramOn arguments
RooCmdArg Label(const char* str) ;
RooCmdArg Layout(Double_t xmin, Double_t xmax=0.99, Double_t ymin=0.95) ;
RooCmdArg Parameters(const RooArgSet& params) ;
RooCmdArg ShowConstants(Bool_t flag=kTRUE) ;

// RooTreeData::statOn arguments
RooCmdArg What(const char* str) ;

// RooProdPdf::ctor arguments
RooCmdArg Conditional(const RooArgSet& pdfSet, const RooArgSet& depSet, Bool_t depsAreCond=kFALSE) ;

// RooAbsPdf::generate arguments
RooCmdArg ProtoData(const RooDataSet& protoData, Bool_t randomizeOrder=kFALSE, Bool_t resample=kFALSE) ;
RooCmdArg NumEvents(Int_t numEvents) ;
RooCmdArg NumEvents(Double_t numEvents) ;
RooCmdArg AutoBinned(Bool_t flag=kTRUE) ;
RooCmdArg GenBinned(const char* tag) ;
RooCmdArg AllBinned() ;
RooCmdArg ExpectedData(Bool_t flag=kTRUE) ;
RooCmdArg Asimov(Bool_t flag=kTRUE) ;

// RooAbsRealLValue::createHistogram arguments
RooCmdArg YVar(const RooAbsRealLValue& var, const RooCmdArg& arg=RooCmdArg::none()) ;
RooCmdArg ZVar(const RooAbsRealLValue& var, const RooCmdArg& arg=RooCmdArg::none()) ;
RooCmdArg AxisLabel(const char* name) ;
RooCmdArg Scaling(Bool_t flag) ;

// RooAbsReal::createIntegral arguments
RooCmdArg NormSet(const RooArgSet& nset) ;
RooCmdArg NumIntConfig(const RooNumIntConfig& cfg) ;

// RooMCStudy::ctor arguments
RooCmdArg Silence(Bool_t flag=kTRUE) ;
RooCmdArg FitModel(RooAbsPdf& pdf) ;
RooCmdArg FitOptions(const RooCmdArg& arg1 ,const RooCmdArg& arg2=RooCmdArg::none(),
                     const RooCmdArg& arg3=RooCmdArg::none(),const RooCmdArg& arg4=RooCmdArg::none(),
                     const RooCmdArg& arg5=RooCmdArg::none(),const RooCmdArg& arg6=RooCmdArg::none()) ;
RooCmdArg Binned(Bool_t flag=kTRUE) ;

// RooMCStudy::plot* arguments
RooCmdArg Frame(const RooCmdArg& arg1 ,const RooCmdArg& arg2=RooCmdArg::none(),
                const RooCmdArg& arg3=RooCmdArg::none(),const RooCmdArg& arg4=RooCmdArg::none(),
                const RooCmdArg& arg5=RooCmdArg::none(),const RooCmdArg& arg6=RooCmdArg::none()) ;
RooCmdArg FrameBins(Int_t nbins) ;
RooCmdArg FrameRange(Double_t xlo, Double_t xhi) ;
RooCmdArg FitGauss(Bool_t flag=kTRUE) ;

// RooRealVar::format arguments
RooCmdArg AutoPrecision(Int_t ndigit=2) ;
RooCmdArg FixedPrecision(Int_t ndigit=2) ;
RooCmdArg TLatexStyle(Bool_t flag=kTRUE) ;
RooCmdArg LatexStyle(Bool_t flag=kTRUE) ;
RooCmdArg LatexTableStyle(Bool_t flag=kTRUE) ;
RooCmdArg VerbatimName(Bool_t flag=kTRUE) ;

// RooMsgService::addReportingStream arguments
RooCmdArg Topic(Int_t topic) ;
RooCmdArg ObjectName(const char* name) ;
RooCmdArg ClassName(const char* name) ;
RooCmdArg BaseClassName(const char* name) ;
RooCmdArg TagName(const char* name) ;
RooCmdArg OutputStream(std::ostream& os) ;
RooCmdArg Prefix(Bool_t flag) ;
RooCmdArg Color(Color_t color) ;


// RooWorkspace::import() arguments
RooCmdArg RenameConflictNodes(const char* suffix) ;
RooCmdArg RenameAllNodes(const char* suffix) ;
RooCmdArg RenameAllVariables(const char* suffix) ;
RooCmdArg RenameAllVariablesExcept(const char* suffix,const char* exceptionList) ;
RooCmdArg RenameVariable(const char* inputName, const char* outputName) ;
RooCmdArg Rename(const char* suffix) ;
RooCmdArg RecycleConflictNodes(Bool_t flag=kTRUE) ;

// RooSimCloneTool::build() arguments
RooCmdArg SplitParam(const char* varname, const char* catname) ;
RooCmdArg SplitParam(const RooRealVar& var, const RooAbsCategory& cat) ;
RooCmdArg SplitParamConstrained(const char* varname, const char* catname, const char* rsname) ;
RooCmdArg SplitParamConstrained(const RooRealVar& var, const RooAbsCategory& cat, const char* rsname) ;
RooCmdArg Restrict(const char* catName, const char* stateNameList) ;

// RooAbsPdf::createCdf() arguments
RooCmdArg SupNormSet(const RooArgSet& nset) ;
RooCmdArg ScanParameters(Int_t nbins,Int_t intOrder) ;
RooCmdArg ScanNumCdf() ;
RooCmdArg ScanAllCdf() ;
RooCmdArg ScanNoCdf() ;

RooConstVar& RooConst(Double_t val) ;


}

namespace RooFitShortHand {

RooArgSet S(const RooAbsArg& v1) ;
RooArgSet S(const RooAbsArg& v1, const RooAbsArg& v2) ;
RooArgSet S(const RooAbsArg& v1, const RooAbsArg& v2, const RooAbsArg& v3) ;
RooArgSet S(const RooAbsArg& v1, const RooAbsArg& v2, const RooAbsArg& v3, const RooAbsArg& v4) ;
RooArgSet S(const RooAbsArg& v1, const RooAbsArg& v2, const RooAbsArg& v3, const RooAbsArg& v4, const RooAbsArg& v5) ;
RooArgSet S(const RooAbsArg& v1, const RooAbsArg& v2, const RooAbsArg& v3, const RooAbsArg& v4, const RooAbsArg& v5,
            const RooAbsArg& v6) ;
RooArgSet S(const RooAbsArg& v1, const RooAbsArg& v2, const RooAbsArg& v3, const RooAbsArg& v4, const RooAbsArg& v5,
            const RooAbsArg& v6, const RooAbsArg& v7) ;
RooArgSet S(const RooAbsArg& v1, const RooAbsArg& v2, const RooAbsArg& v3, const RooAbsArg& v4, const RooAbsArg& v5,
            const RooAbsArg& v6, const RooAbsArg& v7, const RooAbsArg& v8) ;
RooArgSet S(const RooAbsArg& v1, const RooAbsArg& v2, const RooAbsArg& v3, const RooAbsArg& v4, const RooAbsArg& v5,
            const RooAbsArg& v6, const RooAbsArg& v7, const RooAbsArg& v8, const RooAbsArg& v9) ;

RooArgList L(const RooAbsArg& v1) ;
RooArgList L(const RooAbsArg& v1, const RooAbsArg& v2) ;
RooArgList L(const RooAbsArg& v1, const RooAbsArg& v2, const RooAbsArg& v3) ;
RooArgList L(const RooAbsArg& v1, const RooAbsArg& v2, const RooAbsArg& v3, const RooAbsArg& v4) ;
RooArgList L(const RooAbsArg& v1, const RooAbsArg& v2, const RooAbsArg& v3, const RooAbsArg& v4, const RooAbsArg& v5) ;
RooArgList L(const RooAbsArg& v1, const RooAbsArg& v2, const RooAbsArg& v3, const RooAbsArg& v4, const RooAbsArg& v5,
             const RooAbsArg& v6) ;
RooArgList L(const RooAbsArg& v1, const RooAbsArg& v2, const RooAbsArg& v3, const RooAbsArg& v4, const RooAbsArg& v5,
             const RooAbsArg& v6, const RooAbsArg& v7) ;
RooArgList L(const RooAbsArg& v1, const RooAbsArg& v2, const RooAbsArg& v3, const RooAbsArg& v4, const RooAbsArg& v5,
             const RooAbsArg& v6, const RooAbsArg& v7, const RooAbsArg& v8) ;
RooArgList L(const RooAbsArg& v1, const RooAbsArg& v2, const RooAbsArg& v3, const RooAbsArg& v4, const RooAbsArg& v5,
             const RooAbsArg& v6, const RooAbsArg& v7, const RooAbsArg& v8, const RooAbsArg& v9) ;

RooConstVar& C(Double_t value) ;

} // End namespace ShortHand

class RooGlobalFunc {};
# 25 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsReal.h" 2

class RooArgList ;
class RooDataSet ;
class RooPlot;
class RooRealVar;
class RooAbsFunc;
class RooAbsCategoryLValue ;
class RooCategory ;
class RooLinkedList ;
class RooNumIntConfig ;
class RooDataHist ;
class RooFunctor ;
class RooGenFunction ;
class RooMultiGenFunction ;
class RooFitResult ;
class RooMoment ;
class RooDerivative ;
class RooVectorDataStore ;

class TH1;
class TH1F;
class TH2F;
class TH3F;

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/list" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_list" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <list.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/list

#pragma ifndef PREC_STL_LIST
#pragma define PREC_STL_LIST
#pragma link off global PREC_STL_LIST;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from ANSI/ISO C++ 1997/Nov draft 
// Got some ideas from Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <iterator.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/iterator

#pragma ifndef PREC_STL_ITERATOR
#pragma define PREC_STL_ITERATOR
#pragma link off global PREC_STL_ITERATOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from STL HP implementation 1994
// Imported from STL SGI implementation 1997 
// Imported from ANSI/ISO C++ draft Nov 1997
// Modified by Masaharu Goto
// May need improvement for the latest standard


////////////////////////////////////////////////////////////////////////
// iterator_tag
////////////////////////////////////////////////////////////////////////
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag {};
struct bidirectional_iterator_tag {};
struct random_access_iterator_tag {};

////////////////////////////////////////////////////////////////////////
// iterator template
////////////////////////////////////////////////////////////////////////
template <class T, class Distance> struct input_iterator {};
struct output_iterator {};
template <class T, class Distance> struct forward_iterator {};
template <class T, class Distance> struct bidirectional_iterator {};
template <class T, class Distance> struct random_access_iterator {};

#pragma link off class output_iterator;







////////////////////////////////////////////////////////////////////////
// iterator_category overloaded function
////////////////////////////////////////////////////////////////////////
template <class T, class Distance>
inline input_iterator_tag
iterator_category(const input_iterator<T, Distance>&) {
    return input_iterator_tag();
}

inline output_iterator_tag iterator_category(const output_iterator&) {
    return output_iterator_tag();
}

#pragma link off function iterator_category(const output_iterator&);


template <class T, class Distance>
inline forward_iterator_tag
iterator_category(const forward_iterator<T, Distance>&) {
    return forward_iterator_tag();
}

template <class T, class Distance>
inline bidirectional_iterator_tag
iterator_category(const bidirectional_iterator<T, Distance>&) {
    return bidirectional_iterator_tag();
}

template <class T, class Distance>
inline random_access_iterator_tag
iterator_category(const random_access_iterator<T, Distance>&) {
    return random_access_iterator_tag();
}

template <class T>
inline random_access_iterator_tag
iterator_category(const T*) {
    return random_access_iterator_tag();
}


// iterator_traits, iterator and reverse_iterator template may not be
// needed for precompiled library interface 

////////////////////////////////////////////////////////////////////////
// iterator_traits
////////////////////////////////////////////////////////////////////////

template <class Iterator>
struct iterator_traits {
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type value_type;
  typedef typename Iterator::difference_type difference_type;
  typedef typename Iterator::pointer pointer;
  typedef typename Iterator::reference reference;
};

// template partial specialization, implement in cint5.15.14 1587
template <class T>
struct iterator_traits<T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
};

// incomplete implementation in cint5.15.14 1587, need some fix
// iterator_traits<const int*> is changed as iterator_traits<const int* const>
// or something, but cint5.15.14 can not handle this well
template <class T>
struct iterator_traits<const T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef const T* pointer;
  typedef const T& reference;
};

////////////////////////////////////////////////////////////////////////
// iterator
////////////////////////////////////////////////////////////////////////
template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator {
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
  typedef Category iterator_category;
};


////////////////////////////////////////////////////////////////////////
// reverse_iterator
////////////////////////////////////////////////////////////////////////






template <class Iterator>
class reverse_iterator
# 166 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
{




 public:
# 181 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
   typedef Iterator::pointer pointer;
   typedef Iterator::reference reference;
   typedef ptrdiff_t difference_type;


   reverse_iterator();
   //reverse_iterator(Iterator x);



   Iterator base() const; // explicit
   reference operator*() const;
   pointer operator->() const;
   reverse_iterator& operator++();
   reverse_iterator operator++(int);
   reverse_iterator& operator--();
   reverse_iterator operator--(int);
   reverse_iterator operator+ (difference_type n) const;
   reverse_iterator& operator+=(difference_type n);
   reverse_iterator operator- (difference_type n) const;
   reverse_iterator& operator-=(difference_type n);
   reference operator[](difference_type n) const;
};
# 932 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
// for g++ 3.1,3.2
namespace __gnu_cxx
{
  // This iterator adapter is 'normal' in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                    difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparaison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  // _GLIBCPP_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
     const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
} // namespace __gnu_cxx







#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 2
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <memory.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/memory

#pragma ifndef PREC_STL_MEMORY
#pragma define PREC_STL_MEMORY
#pragma link off global PREC_STL_MEMORY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////


template <class _Tp>
class allocator {
  //typedef alloc _Alloc;          // The underlying allocator.
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  typedef typename _Tp* pointer;
  typedef const typename _Tp * const_pointer;




  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() ;
  allocator(const allocator&) ;
  //template <class _Tp1> allocator(const allocator<_Tp1>&) ;
  ~allocator() ;

  pointer address(reference __x) const ;
  const_pointer address(const_reference __x) const ;

  // __n is permitted to be 0.  The C++ standard says nothing about what
  // the return value is when __n == 0.
  _Tp* allocate(size_type __n, const void* = 0) ;

  // __p is not permitted to be a null pointer.
  void deallocate(pointer __p, size_type __n);

  size_type max_size() const ;

  void construct(pointer __p, const _Tp& __val) ;
  void destroy(pointer __p) ;
};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;
  typedef void value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };
};
//////////////////////////////////////////////////////////////////////
# 205 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////

/**********************************************************************
* auto_ptr
**********************************************************************/
template <class X> class auto_ptr {
private:
  X* ptr;
  //template<class Y> struct auto_ptr_ref { };
public:
  typedef X element_type;
  explicit auto_ptr(X* p = 0) : ptr(p) {}
  auto_ptr(auto_ptr& a) {ptr=a.ptr;}

  // this implementation may not be correct
  template <class T> auto_ptr(auto_ptr<T>& a) {ptr=a.release();}
# 229 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  auto_ptr& operator=(auto_ptr& a) {
    if (a.ptr != ptr) {
      delete ptr;
      ptr = a.ptr;
    }
    return(*this);
  }

  // this implementation may not be correct
  template <class T> auto_ptr& operator=(auto_ptr<T>& a) {
    if (a.ptr != ptr) {
       delete ptr;
       ptr = a.release();
    }
    return(*this);
  }

  ~auto_ptr() { delete ptr; }

  X& operator*() const { return *ptr; }
  X* operator->() const { return ptr; }
  X* get() const { return ptr; }
  X* release() { X *old = ptr; ptr = 0; return 0; }
# 262 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  // auto_ptr conversions
  //auto_ptr(auto_ptr_ref<X>& x) { }
  //template<class Y> operator auto_ptr_ref<Y>() { return auto_ptr_ref<Y>(); }
  //template<class Y> operator auto_ptr<Y>() { return auto_ptr<T>(); }
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 2
# 28 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list" 2


template<class T,class Allocator=std::allocator<T> >
# 44 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
class list {
 public:
  typedef T value_type;
  typedef Allocator allocator_type;

  typedef void* void_pointer;
  //typedef __list_node<T> list_node;
  //typedef simple_alloc<list_node, Alloc> list_node_allocator;
  //typedef list_node* link_type;
  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
# 68 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
  class iterator
# 84 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
 {
   public:
    iterator() ;
    iterator(const iterator& x) ;

    iterator& operator=(const iterator& x) ;

    T& operator*() const ;

    T* operator->() const ;

    iterator& operator++();
    iterator operator++(int a);
    iterator& operator--();
    iterator operator--(int a);
    bool operator==(const iterator& x) ;

    bool operator!=(const iterator& x) ;





  };







  class reverse_iterator
# 131 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
 {
   public:
    reverse_iterator(const reverse_iterator& x) ;

    reverse_iterator& operator=(const reverse_iterator& x) ;

    T& operator*() const ;

    T* operator->() const ;

    reverse_iterator& operator++();
    reverse_iterator operator++(int a);
    reverse_iterator& operator--();
    reverse_iterator operator--(int a);




  };

  friend bool operator==(const list::reverse_iterator& x
                        ,const list::reverse_iterator& y) const;
  friend bool operator!=(const list::reverse_iterator& x
                        ,const list::reverse_iterator& y) const;

  typedef const iterator const_iterator;
  typedef const reverse_iterator const_reverse_iterator;
# 168 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
  list() ;
  iterator begin() ;
  iterator end() ;
  reverse_iterator rbegin() ;
  reverse_iterator rend() ;






  bool empty() const ;
  size_type size() const ;
  size_type max_size() const ;
  T& front() const ;
  T& back() const ;
  void swap(list& x) ;
  iterator insert(iterator position,const T& x);
  void insert(iterator position,T* first,T* last);
  void insert(iterator position,iterator first,iterator last);
  void insert(iterator position,size_type n,const T& x);
  void push_front(const T& x);
  void push_back(const T& x);
  void resize(size_type n);
  void resize(size_type n, T v);
  void erase(iterator position);
  void erase(iterator first,iterator last);
  void clear() ;
  void pop_front();
  void pop_back();
  list(size_type n,const T& value=T()) ;






  list(const T* first,const T* last) ;

  list(const_iterator first, const_iterator last) ;

  list(const list& x) ;
  ~list() ;
  list& operator=(const list& x) ;
  void splice(iterator position,list& x);
  void splice(iterator position,list& x,iterator i);
  void splice(iterator position,list& x,iterator first,iterator last);
  void remove(const T& value);
  void unique();
  void merge(list& x);
  void reverse();
  void sort();

  friend bool operator==(const list& x, const list& y);
  friend bool operator< (const list& x, const list& y);
  friend bool operator!=(const list& x, const list& y);
  friend bool operator> (const list& x, const list& y);
  friend bool operator>=(const list& x, const list& y);
  friend bool operator<=(const list& x, const list& y);

  // specialized algorithms:





#pragma ifndef G__NOALGORITHM
  // Generic algorithm


  // input iter
  friend list::iterator
    find(list::iterator first,list::iterator last,const T& value);
  // forward iter
  friend list::iterator
    find_end(list::iterator first1,list::iterator last1,
      list::iterator first2,list::iterator last2);
  friend list::iterator
    find_first_of(list::iterator first1,list::iterator last1,
           list::iterator first2,list::iterator last2);
  friend list::iterator
    adjacent_find(list::iterator first,list::iterator last);
  // input iter

  friend list::difference_type
    count(list::iterator first,list::iterator last,const T& value);






  friend bool
    equal(list::iterator first1,list::iterator last1,
          list::iterator first2);
  // forward iter
  friend list::iterator
    search(list::iterator first1,list::iterator last1,
           list::iterator first2,list::iterator last2);
  friend list::iterator
    search_n(list::iterator first,list::iterator last
             ,list::size_type count,const T& value);
  // input and output iter -> forward iter
  friend list::iterator
    copy(list::iterator first,list::iterator last,
         list::iterator result);
  // bidirectional iter
  friend list::iterator
    copy_backward(list::iterator first,list::iterator last,
                  list::iterator result);
  // just value_type
  friend void swap(T& a,T& b);
  // forward iter
  friend list::iterator
    swap_ranges(list::iterator first1,list::iterator last1,
                list::iterator first2);
  friend void iter_swap(list::iterator a,list::iterator b);
  friend void replace(list::iterator first,list::iterator last,
                      const T& old_value,const T& new_value);
  // input, output iter -> forward iter
  friend list::iterator
    replace_copy(list::iterator first,list::iterator last,
                 list::iterator result,
                 const T& old_value,const T& new_value);
  // forward iter
  friend void
    fill(list::iterator first,list::iterator last,const T& value);

  friend void
    fill_n(list::iterator first,list::size_type n,const T& value);

  friend list::iterator
    remove(list::iterator first,list::iterator last,const T& value);
  // input,output iter -> forward iter
  friend list::iterator
    remove_copy(list::iterator first,list::iterator last,
                list::iterator result,const T& value);
  friend list::iterator
    unique(list::iterator first,list::iterator last);
  friend list::iterator
    unique_copy(list::iterator first,list::iterator last,
                list::iterator result);
  friend void reverse(list::iterator first,list::iterator last);
  friend list::iterator
     reverse_copy(list::iterator first,list::iterator last,
                  list::iterator result);
  // forward iter
  friend void rotate(list::iterator first,list::iterator mid,
                     list::iterator last);
  // forward iter
  friend list::iterator
    rotate_copy(list::iterator first,list::iterator mid,
                list::iterator last,list::iterator result);
# 336 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
  // forward iter
  friend list::iterator
    lower_bound(list::iterator first,list::iterator last,const T& value);
  friend list::iterator
    upper_bound(list::iterator first,list::iterator last,const T& value);




  friend bool binary_search(list::iterator first,list::iterator last,
                            const T& value);
  friend list::iterator merge(list::iterator first1,list::iterator last1,
                                list::iterator first2,list::iterator last2,
                                list::iterator result);
  friend void inplace_merge(list::iterator first,list::iterator middle,
                            list::iterator last);
  friend bool includes(list::iterator first1,list::iterator last1,
                       list::iterator first2,list::iterator last2);
  friend list::iterator
    set_union(list::iterator first1,list::iterator last1,
              list::iterator first2,list::iterator last2,
              list::iterator result);
  friend list::iterator
    set_intersection(list::iterator first1,list::iterator last1,
                     list::iterator first2,list::iterator last2,
                     list::iterator result);
  friend list::iterator
    set_difference(list::iterator first1,list::iterator last1,
                   list::iterator first2,list::iterator last2,
                   list::iterator result);
  friend list::iterator
    set_symmetric_difference(list::iterator first1,list::iterator last1,
                             list::iterator first2,list::iterator last2,
                             list::iterator result);







  // min,max, just value_type
  friend const T& min(const T& a,const T& b);
  friend const T& max(const T& a,const T& b);
  // forward iter
  friend list::iterator
    min_element(list::iterator first,list::iterator last);
  friend list::iterator
    max_element(list::iterator first,list::iterator last);
  // input iter
  friend bool
    lexicographical_compare(list::iterator first1,list::iterator last1,
                            list::iterator first2,list::iterator last2);
  // bidirectional iter
  friend bool next_permutation(list::iterator first,list::iterator last);
  friend bool prev_permutation(list::iterator first,list::iterator last);
# 417 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
#pragma endif

  // Generic algorithm
  //friend void reverse(list::iterator first,list::iterator last);
  //friend void reverse(list::reverse_iterator first,list::reverse_itetator last);


  // iterator_category resolution
  //friend bidirectional_iterator_tag iterator_category(list::iterator x);
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_list" 2
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/list" 2
}
# 50 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsReal.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/string" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_string" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// string
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/string" 2
}
# 51 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsReal.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iostream" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iostream.h" 1
/* /% C++ %/ */
/***********************************************************************
 * cint (C/C++ interpreter)
 ************************************************************************
 * I/O stream header file iostream.h
 ************************************************************************
 * Description:
 *  CINT iostream header file
 ************************************************************************
 * Copyright(c) 1995~1999  Masaharu Goto 
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
# 11 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iostream" 2
}
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/_iostream" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// include/_iostream

std::ostream& operator<<(std::ostream& ostr,std::G__CINT_ENDL& i)
 {return(std::endl(ostr));}
std::ostream& operator<<(std::ostream& ostr,std::G__CINT_ENDS& i)
 {return(std::ends(ostr));}
std::ostream& operator<<(std::ostream& ostr,std::G__CINT_FLUSH& i)
 {return(std::flush(ostr));}

std::istream& operator>>(std::istream& istr,std::G__CINT_ws& i)
 {return(std::ws(istr));}
std::istream& operator>>(std::istream& istr,std::G__CINT_WS& i)
 {return(std::WS(istr));}


std::ostream& operator<<(std::ostream& ostr,std::G__CINT_IOFLAGS& f) {
   ostr.setf(f.flag, f.mask);
  return ostr;
}
std::istream& operator>>(std::istream& istr,std::G__CINT_IOFLAGS& f) {
  istr.setf(f.flag, f.mask);
  return istr;
}

std::ostream& operator<<(std::ostream& ostr,std::G__CINT_NOSUPPORT& i) {
  fprintf(stderr,"Limitation: dec,hex,oct manipurator not supported\n");
  return(ostr);
}
std::istream& operator<<(std::istream& istr,std::G__CINT_NOSUPPORT& i) {
  fprintf(stderr,"Limitation: dec,hex,oct manipurator not supported\n");
  return(istr);
}


std::ostream& operator<<(std::ostream& ostr,long long i) {
  char buf[200];
#pragma ifndef G__TMPLTIOS
  if (ostr.flags() & ios::hex)
#pragma else
  if (ostr.flags() & ios_base::hex)
#pragma endif
     sprintf(buf,"%llx",i);
  else
     sprintf(buf,"%lld",i);
  ostr << buf ;
  return(ostr);
}
std::ostream& operator<<(std::ostream& ostr,unsigned long long i) {
  char buf[200];
#pragma ifndef G__TMPLTIOS
  if (ostr.flags() & ios::hex)
#pragma else
  if (ostr.flags() & ios_base::hex)
#pragma endif
     sprintf(buf,"%llx",i);
  else
     sprintf(buf,"%llu",i);
  ostr << buf ;
  return(ostr);
}
std::ostream& operator<<(std::ostream& ostr,long double i) {
  char buf[200];
  sprintf(buf,"%Lg",i);
  ostr << buf ;
  return(ostr);
}
std::istream& operator>>(std::istream& istr,long long &i) {
  char buf[200];
  istr >> buf ;
  sscanf(buf,"%lld",&i);
  return(istr);
}
std::istream& operator>>(std::istream& istr,unsigned long long &i) {
  char buf[200];
  istr >> buf ;
#pragma ifndef G__TMPLTIOS
  if (ostr.flags() & ios::hex)
#pragma else
  if (ostr.flags() & ios_base::hex)
#pragma endif
     sscanf(buf,"%llx",&i);
  else
     sscanf(buf,"%llu",&i);
  return(istr);
}
std::istream& operator>>(std::istream& istr,long double &i) {
  char buf[200];
  istr >> buf ;
  sscanf(buf,"%Lg",&i);
  return(istr);
}


// Value evaluation
//template<class T> int G__ateval(const T* x) {return(0);}
//template<class T> int G__ateval(const T& x) {return(0);}
int G__ateval(const char* const &x) {return(0);}
//int G__ateval(const void* const &x) {return(0);}
int G__ateval(double x) {return(0);}
int G__ateval(float x) {return(0);}
int G__ateval(bool x) {return(0);}
int G__ateval(char x) {return(0);}
int G__ateval(short x) {return(0);}
int G__ateval(int x) {return(0);}
int G__ateval(long x) {return(0);}
int G__ateval(unsigned char x) {return(0);}
int G__ateval(unsigned short x) {return(0);}
int G__ateval(unsigned int x) {return(0);}
int G__ateval(unsigned long x) {return(0);}
# 127 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/_iostream"
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iomanip.h" 1
/* /% C++ %/ */
/***********************************************************************
 * cint (C/C++ interpreter)
 ************************************************************************
 * I/O manipulator header for iomanip.h
 ************************************************************************
 * Description:
 *  CINT IOMANIP header file
 ************************************************************************
 * Author                  Masaharu Goto 
 * Copyright(c) 1995~1999  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
# 127 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/_iostream" 2
# 12 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iostream" 2
# 52 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsReal.h" 2

class RooAbsReal : public RooAbsArg {
public:
  // Constructors, assignment etc
  RooAbsReal() ;
  RooAbsReal(const char *name, const char *title, const char *unit= "") ;
  RooAbsReal(const char *name, const char *title, Double_t minVal, Double_t maxVal,
      const char *unit= "") ;
  RooAbsReal(const RooAbsReal& other, const char* name=0);
  virtual ~RooAbsReal();

  // Return value and unit accessors
  inline Double_t getVal(const RooArgSet* set=0) const {
/*     if (_fast && !_inhibitDirty && std::string("RooHistFunc")==IsA()->GetName()) std::cout << "RooAbsReal::getVal(" << GetName() << ") CLEAN value = " << _value << std::endl ;  */

    return (_fast && !_inhibitDirty) ? _value : getValV(set) ;



  }
  inline Double_t getVal(const RooArgSet& set) const { return _fast ? _value : getValV(&set) ; }

  virtual Double_t getValV(const RooArgSet* set=0) const ;

  Double_t getPropagatedError(const RooFitResult& fr) ;

  Bool_t operator==(Double_t value) const ;
  virtual Bool_t operator==(const RooAbsArg& other) ;
  inline const Text_t *getUnit() const {
    // Return string with unit description
    return _unit.Data();
  }
  inline void setUnit(const char *unit) {
    // Set unit description to given string
    _unit= unit;
  }
  TString getTitle(Bool_t appendUnit= kFALSE) const;

  // Lightweight interface adaptors (caller takes ownership)
  RooAbsFunc *bindVars(const RooArgSet &vars, const RooArgSet* nset=0, Bool_t clipInvalid=kFALSE) const;

  // Create a fundamental-type object that can hold our value.
  RooAbsArg *createFundamental(const char* newname=0) const;

  // Analytical integration support
  virtual Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName=0) const ;
  virtual Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName=0) const ;
  virtual Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName=0) const ;
  virtual Double_t analyticalIntegral(Int_t code, const char* rangeName=0) const ;
  virtual Bool_t forceAnalyticalInt(const RooAbsArg& /*dep*/) const {
    // Interface to force RooRealIntegral to offer given observable for internal integration
    // even if this is deemed unsafe. This default implementation returns always flase
    return kFALSE ;
  }
  virtual void forceNumInt(Bool_t flag=kTRUE) {
    // If flag is true, all advertised analytical integrals will be ignored
    // and all integrals are calculated numerically
    _forceNumInt = flag ;
  }

  // Chi^2 fits to histograms
  virtual RooFitResult* chi2FitTo(RooDataHist& data, const RooCmdArg& arg1=RooCmdArg::none(), const RooCmdArg& arg2=RooCmdArg::none(),
                              const RooCmdArg& arg3=RooCmdArg::none(), const RooCmdArg& arg4=RooCmdArg::none(), const RooCmdArg& arg5=RooCmdArg::none(),
                              const RooCmdArg& arg6=RooCmdArg::none(), const RooCmdArg& arg7=RooCmdArg::none(), const RooCmdArg& arg8=RooCmdArg::none()) ;
  virtual RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList) ;

  virtual RooAbsReal* createChi2(RooDataHist& data, const RooLinkedList& cmdList) ;
  virtual RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1=RooCmdArg::none(), const RooCmdArg& arg2=RooCmdArg::none(),
     const RooCmdArg& arg3=RooCmdArg::none(), const RooCmdArg& arg4=RooCmdArg::none(), const RooCmdArg& arg5=RooCmdArg::none(),
     const RooCmdArg& arg6=RooCmdArg::none(), const RooCmdArg& arg7=RooCmdArg::none(), const RooCmdArg& arg8=RooCmdArg::none()) ;

  // Chi^2 fits to X-Y datasets
  virtual RooFitResult* chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1=RooCmdArg::none(), const RooCmdArg& arg2=RooCmdArg::none(),
                              const RooCmdArg& arg3=RooCmdArg::none(), const RooCmdArg& arg4=RooCmdArg::none(), const RooCmdArg& arg5=RooCmdArg::none(),
                              const RooCmdArg& arg6=RooCmdArg::none(), const RooCmdArg& arg7=RooCmdArg::none(), const RooCmdArg& arg8=RooCmdArg::none()) ;
  virtual RooFitResult* chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList) ;

  virtual RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList) ;
  virtual RooAbsReal* createChi2(RooDataSet& data, const RooCmdArg& arg1=RooCmdArg::none(), const RooCmdArg& arg2=RooCmdArg::none(),
       const RooCmdArg& arg3=RooCmdArg::none(), const RooCmdArg& arg4=RooCmdArg::none(), const RooCmdArg& arg5=RooCmdArg::none(),
       const RooCmdArg& arg6=RooCmdArg::none(), const RooCmdArg& arg7=RooCmdArg::none(), const RooCmdArg& arg8=RooCmdArg::none()) ;


  virtual RooAbsReal* createProfile(const RooArgSet& paramsOfInterest) ;


  RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2=RooCmdArg::none(),
                             const RooCmdArg& arg3=RooCmdArg::none(), const RooCmdArg& arg4=RooCmdArg::none(),
        const RooCmdArg& arg5=RooCmdArg::none(), const RooCmdArg& arg6=RooCmdArg::none(),
        const RooCmdArg& arg7=RooCmdArg::none(), const RooCmdArg& arg8=RooCmdArg::none()) const ;

  RooAbsReal* createIntegral(const RooArgSet& iset, const char* rangeName) const {
    // Create integral over observables in iset in range named rangeName
    return createIntegral(iset,0,0,rangeName) ;
  }
  RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet& nset, const char* rangeName=0) const {
    // Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset
    return createIntegral(iset,&nset,0,rangeName) ;
  }
  RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet& nset, const RooNumIntConfig& cfg, const char* rangeName=0) const {
    // Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset while
    // using specified configuration for any numeric integration
    return createIntegral(iset,&nset,&cfg,rangeName) ;
  }
  RooAbsReal* createIntegral(const RooArgSet& iset, const RooNumIntConfig& cfg, const char* rangeName=0) const {
    // Create integral over observables in iset in range named rangeName using specified configuration for any numeric integration
    return createIntegral(iset,0,&cfg,rangeName) ;
  }
  virtual RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset=0, const RooNumIntConfig* cfg=0, const char* rangeName=0) const ;


  void setParameterizeIntegral(const RooArgSet& paramVars) ;

  // Create running integrals
  RooAbsReal* createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset=RooArgSet()) ;
  RooAbsReal* createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2=RooCmdArg::none(),
   const RooCmdArg& arg3=RooCmdArg::none(), const RooCmdArg& arg4=RooCmdArg::none(),
   const RooCmdArg& arg5=RooCmdArg::none(), const RooCmdArg& arg6=RooCmdArg::none(),
   const RooCmdArg& arg7=RooCmdArg::none(), const RooCmdArg& arg8=RooCmdArg::none()) ;
  RooAbsReal* createIntRI(const RooArgSet& iset, const RooArgSet& nset=RooArgSet()) ;
  RooAbsReal* createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder) ;


  // Optimized accept/reject generator support
  virtual Int_t getMaxVal(const RooArgSet& vars) const ;
  virtual Double_t maxVal(Int_t code) const ;
  virtual Int_t minTrialSamples(const RooArgSet& /*arGenObs*/) const { return 0 ; }


  // Plotting options
  void setPlotLabel(const char *label);
  const char *getPlotLabel() const;

  virtual Double_t defaultErrorLevel() const {
    // Return default level for MINUIT error analysis
    return 1.0 ;
  }

  const RooNumIntConfig* getIntegratorConfig() const ;
  RooNumIntConfig* getIntegratorConfig() ;
  static RooNumIntConfig* defaultIntegratorConfig() ;
  RooNumIntConfig* specialIntegratorConfig() const ;
  RooNumIntConfig* specialIntegratorConfig(Bool_t createOnTheFly) ;
  void setIntegratorConfig() ;
  void setIntegratorConfig(const RooNumIntConfig& config) ;

  virtual void fixAddCoefNormalization(const RooArgSet& addNormSet=RooArgSet(),Bool_t force=kTRUE) ;
  virtual void fixAddCoefRange(const char* rangeName=0,Bool_t force=kTRUE) ;

  virtual void preferredObservableScanOrder(const RooArgSet& obs, RooArgSet& orderedObs) const ;

  // User entry point for plotting
  virtual RooPlot* plotOn(RooPlot* frame,
     const RooCmdArg& arg1=RooCmdArg(), const RooCmdArg& arg2=RooCmdArg(),
     const RooCmdArg& arg3=RooCmdArg(), const RooCmdArg& arg4=RooCmdArg(),
     const RooCmdArg& arg5=RooCmdArg(), const RooCmdArg& arg6=RooCmdArg(),
     const RooCmdArg& arg7=RooCmdArg(), const RooCmdArg& arg8=RooCmdArg(),
     const RooCmdArg& arg9=RooCmdArg(), const RooCmdArg& arg10=RooCmdArg()
              ) const ;


  enum ScaleType { Raw, Relative, NumEvent, RelativeExpected } ;

  // Forwarder function for backward compatibility
  virtual RooPlot *plotSliceOn(RooPlot *frame, const RooArgSet& sliceSet, Option_t* drawOptions="L",
          Double_t scaleFactor=1.0, ScaleType stype=Relative, const RooAbsData* projData=0) const;

  // Fill an existing histogram
  TH1 *fillHistogram(TH1 *hist, const RooArgList &plotVars,
       Double_t scaleFactor= 1, const RooArgSet *projectedVars= 0, Bool_t scaling=kTRUE,
       const RooArgSet* condObs=0, Bool_t setError=kTRUE) const;

  // Create 1,2, and 3D histograms from and fill it
  TH1 *createHistogram(const char* varNameList, Int_t xbins=0, Int_t ybins=0, Int_t zbins=0) const ;
  TH1* createHistogram(const char *name, const RooAbsRealLValue& xvar, RooLinkedList& argList) const ;
  TH1 *createHistogram(const char *name, const RooAbsRealLValue& xvar,
                       const RooCmdArg& arg1=RooCmdArg::none(), const RooCmdArg& arg2=RooCmdArg::none(),
                       const RooCmdArg& arg3=RooCmdArg::none(), const RooCmdArg& arg4=RooCmdArg::none(),
                       const RooCmdArg& arg5=RooCmdArg::none(), const RooCmdArg& arg6=RooCmdArg::none(),
                       const RooCmdArg& arg7=RooCmdArg::none(), const RooCmdArg& arg8=RooCmdArg::none()) const ;

  // Fill a RooDataHist
  RooDataHist* fillDataHist(RooDataHist *hist, const RooArgSet* nset, Double_t scaleFactor,
       Bool_t correctForBinVolume=kFALSE, Bool_t showProgress=kFALSE) const ;

  // I/O streaming interface (machine readable)
  virtual Bool_t readFromStream(std::istream& is, Bool_t compact, Bool_t verbose=kFALSE) ;
  virtual void writeToStream(std::ostream& os, Bool_t compact) const ;

  // Printing interface (human readable)
  virtual void printValue(std::ostream& os) const ;
  virtual void printMultiline(std::ostream& os, Int_t contents, Bool_t verbose=kFALSE, TString indent="") const ;

  static void setCacheCheck(Bool_t flag) ;

  // Evaluation error logging 
  class EvalError {
  public:
    EvalError() { _msg[0] = 0 ; _srvval[0] = 0 ; }
    EvalError(const EvalError& other) { strlcpy(_msg,other._msg,1024) ; strlcpy(_srvval,other._srvval,1024) ; } ;
    void setMessage(const char* tmp) ;
    void setServerValues(const char* tmp) ;
    char _msg[1024] ;
    char _srvval[1024] ;
  } ;

  enum ErrorLoggingMode { PrintErrors, CollectErrors, CountErrors, Ignore } ;
  static ErrorLoggingMode evalErrorLoggingMode() ;
  static void setEvalErrorLoggingMode(ErrorLoggingMode m) ;
  void logEvalError(const char* message, const char* serverValueString=0) const ;
  static void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString=0) ;
  static void printEvalErrors(std::ostream&os=std::cout, Int_t maxPerNode=10000000) ;
  static Int_t numEvalErrors() ;
  static Int_t numEvalErrorItems() ;


  typedef std::map<const RooAbsArg*,std::pair<std::string,std::list<EvalError> > >::const_iterator EvalErrorIter ;
  static EvalErrorIter evalErrorIter() ;

  static void clearEvalErrorLog() ;

  virtual Bool_t isBinnedDistribution(const RooArgSet& /*obs*/) const { return kFALSE ; }
  virtual std::list<Double_t>* binBoundaries(RooAbsRealLValue& /*obs*/, Double_t /*xlo*/, Double_t /*xhi*/) const { return 0 ; }
  virtual std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& /*obs*/, Double_t /*xlo*/, Double_t /*xhi*/) const {
    // Interface for returning an optional hint for initial sampling points when constructing a curve 
    // projected on observable.
    return 0 ;
  }

  RooGenFunction* iGenFunction(RooRealVar& x, const RooArgSet& nset=RooArgSet()) ;
  RooMultiGenFunction* iGenFunction(const RooArgSet& observables, const RooArgSet& nset=RooArgSet()) ;

  RooFunctor* functor(const RooArgList& obs, const RooArgList& pars=RooArgList(), const RooArgSet& nset=RooArgSet()) const ;
  TF1* asTF(const RooArgList& obs, const RooArgList& pars=RooArgList(), const RooArgSet& nset=RooArgSet()) const ;

  RooDerivative* derivative(RooRealVar& obs, Int_t order=1, Double_t eps=0.001) ;
  RooDerivative* derivative(RooRealVar& obs, const RooArgSet& normSet, Int_t order, Double_t eps=0.001) ;

  RooMoment* moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot) ;
  RooMoment* moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs) ;

  RooMoment* mean(RooRealVar& obs) { return moment(obs,1,kFALSE,kFALSE) ; }
  RooMoment* mean(RooRealVar& obs, const RooArgSet& nset) { return moment(obs,nset,1,kFALSE,kFALSE,kTRUE) ; }
  RooMoment* sigma(RooRealVar& obs) { return moment(obs,2,kTRUE,kTRUE) ; }
  RooMoment* sigma(RooRealVar& obs, const RooArgSet& nset) { return moment(obs,nset,2,kTRUE,kTRUE,kTRUE) ; }

  Double_t findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval) ;


  virtual Bool_t setData(RooAbsData& /*data*/, Bool_t /*cloneData*/=kTRUE) { return kTRUE ; }

  virtual void enableOffsetting(Bool_t) {} ;
  virtual Bool_t isOffsetting() const { return kFALSE ; }
  virtual Double_t offset() const { return 0 ; }

  static void setHideOffset(Bool_t flag);
  static Bool_t hideOffset() ;

protected:

  // PlotOn with command list
  virtual RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const ;

  // Hook for objects with normalization-dependent parameters interperetation
  virtual void selectNormalization(const RooArgSet* depSet=0, Bool_t force=kFALSE) ;
  virtual void selectNormalizationRange(const char* rangeName=0, Bool_t force=kFALSE) ;

  // Helper functions for plotting
  Bool_t plotSanityChecks(RooPlot* frame) const ;
  void makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars,
    RooArgSet& projectedVars, Bool_t silent) const ;

  TString integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset=0, const char* rangeName=0, Bool_t omitEmpty=kFALSE) const ;


  Bool_t isSelectedComp() const ;


 public:
  const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const ;
  const RooAbsReal* createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const ;
  const RooAbsReal *createPlotProjection(const RooArgSet &dependentVars, const RooArgSet *projectedVars,
             RooArgSet *&cloneSet, const char* rangeName=0, const RooArgSet* condObs=0) const;
 protected:

  RooFitResult* chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList) ;

  RooPlot* plotOnWithErrorBand(RooPlot* frame,const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const ;

  // Support interface for subclasses to advertise their analytic integration
  // and generator capabilities in their analticalIntegral() and generateEvent()
  // implementations.
  Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps,
     const RooArgProxy& a) const ;
  Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps,
     const RooArgProxy& a, const RooArgProxy& b) const ;
  Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps,
     const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const ;
  Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps,
     const RooArgProxy& a, const RooArgProxy& b,
     const RooArgProxy& c, const RooArgProxy& d) const ;

  Bool_t matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps,
     const RooArgSet& set) const ;


  RooAbsReal* createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const ;
  void findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const ;


  // Internal consistency checking (needed by RooDataSet)
  virtual Bool_t isValid() const ;
  virtual Bool_t isValidReal(Double_t value, Bool_t printError=kFALSE) const ;

  // Function evaluation and error tracing
  Double_t traceEval(const RooArgSet* set) const ;
  virtual Bool_t traceEvalHook(Double_t /*value*/) const {
    // Hook function to add functionality to evaluation tracing in derived classes
    return kFALSE ;
  }
  virtual Double_t evaluate() const = 0 ;

  // Hooks for RooDataSet interface
  friend class RooRealIntegral ;
  friend class RooVectorDataStore ;
  virtual void syncCache(const RooArgSet* set=0) { getVal(set) ; }
  virtual void copyCache(const RooAbsArg* source, Bool_t valueOnly=kFALSE, Bool_t setValDirty=kTRUE) ;
  virtual void attachToTree(TTree& t, Int_t bufSize=32000) ;
  virtual void attachToVStore(RooVectorDataStore& vstore) ;
  virtual void setTreeBranchStatus(TTree& t, Bool_t active) ;
  virtual void fillTreeBranch(TTree& t) ;

  friend class RooRealBinding ;
  Double_t _plotMin ; // Minimum of plot range
  Double_t _plotMax ; // Maximum of plot range
  Int_t _plotBins ; // Number of plot bins
  mutable Double_t _value ; // Cache for current value of object
  TString _unit ; // Unit for objects value
  TString _label ; // Plot label for objects value
  Bool_t _forceNumInt ; // Force numerical integration if flag set

  mutable Float_t _floatValue ; //! Transient cache for floating point values from tree branches 
  mutable Int_t _intValue ; //! Transient cache for integer values from tree branches 
  mutable UChar_t _byteValue ; //! Transient cache for byte values from tree branches 
  mutable Char_t _sbyteValue ; //! Transient cache for signed byte values from tree branches 
  mutable UInt_t _uintValue ; //! Transient cache for unsigned integer values from tree branches 

  friend class RooAbsPdf ;
  friend class RooAbsAnaConvPdf ;
  friend class RooRealProxy ;

  RooNumIntConfig* _specIntegratorConfig ; // Numeric integrator configuration specific for this object

  Bool_t _treeVar ; // !do not persist

  static Bool_t _cacheCheck ; // If true, always validate contents of clean which outcome of evaluate()

  friend class RooDataProjBinding ;
  friend class RooAbsOptGoodnessOfFit ;

  struct PlotOpt {
   PlotOpt() : drawOptions("L"), scaleFactor(1.0), stype(Relative), projData(0), binProjData(kFALSE), projSet(0), precision(1e-3),
               shiftToZero(kFALSE),projDataSet(0),normRangeName(0),rangeLo(0),rangeHi(0),postRangeFracScale(kFALSE),wmode(RooCurve::Extended),
               projectionRangeName(0),curveInvisible(kFALSE), curveName(0),addToCurveName(0),addToWgtSelf(1.),addToWgtOther(1.),
               numCPU(1),interleave(kTRUE),curveNameSuffix(""), numee(10), eeval(0), doeeval(kFALSE), progress(kFALSE) {} ;
   Option_t* drawOptions ;
   Double_t scaleFactor ;
   ScaleType stype ;
   const RooAbsData* projData ;
   Bool_t binProjData ;
   const RooArgSet* projSet ;
   Double_t precision ;
   Bool_t shiftToZero ;
   const RooArgSet* projDataSet ;
   const char* normRangeName ;
   Double_t rangeLo ;
   Double_t rangeHi ;
   Bool_t postRangeFracScale ;
   RooCurve::WingMode wmode ;
   const char* projectionRangeName ;
   Bool_t curveInvisible ;
   const char* curveName ;
   const char* addToCurveName ;
   Double_t addToWgtSelf ;
   Double_t addToWgtOther ;
   Int_t numCPU ;
   Bool_t interleave ;
   const char* curveNameSuffix ;
   Int_t numee ;
   Double_t eeval ;
   Bool_t doeeval ;
   Bool_t progress ;
  } ;

  // Plot implementation functions
  virtual RooPlot *plotOn(RooPlot* frame, PlotOpt o) const;
  virtual RooPlot *plotAsymOn(RooPlot *frame, const RooAbsCategoryLValue& asymCat, PlotOpt o) const;


private:

  static ErrorLoggingMode _evalErrorMode ;
  static std::map<const RooAbsArg*,std::pair<std::string,std::list<EvalError> > > _evalErrorList ;
  static Int_t _evalErrorCount ;

  Bool_t matchArgsByName(const RooArgSet &allArgs, RooArgSet &matchedArgs, const TList &nameList) const;

protected:


  friend class RooRealSumPdf ;
  friend class RooAddPdf ;
  friend class RooAddModel ;
  void selectComp(Bool_t flag) {
    // If flag is true, only selected component will be included in evaluates of RooAddPdf components
    _selectComp = flag ;
  }
  static void globalSelectComp(Bool_t flag) ;
  Bool_t _selectComp ; //! Component selection flag for RooAbsPdf::plotCompOn
  static Bool_t _globalSelectComp ; // Global activation switch for component selection

  mutable RooArgSet* _lastNSet ; //!
  static Bool_t _hideOffset ; // Offset hiding flag

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 2; } static void Dictionary(); virtual TClass *IsA() const { return RooAbsReal::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooAbsReal::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsReal.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 476; } // Abstract real-valued variable
};
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsPdf.h" 2
//#include "RooRealIntegral.h"
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooNameSet.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooNameSet.h,v 1.16 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TString.h" 1
// @(#)root/base:$Id: TString.h 43133 2012-02-27 09:50:10Z rdm $
// Author: Fons Rademakers   04/08/95

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooNameSet.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TObject.h" 1
// @(#)root/base:$Id: TObject.h 38832 2011-04-13 17:54:49Z rdm $
// Author: Rene Brun   26/12/94

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooNameSet.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooPrintable.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooPrintable.h,v 1.12 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 22 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooNameSet.h" 2
class RooArgSet ;

class RooNameSet : public TObject, public RooPrintable {
public:

  // Constructors, assignment etc.
  RooNameSet();
  RooNameSet(const RooArgSet& argSet);
  RooNameSet(const RooNameSet& other) ;
  virtual TObject* Clone(const char*) const { return new RooNameSet(*this) ; }
  virtual ~RooNameSet() ;

  void refill(const RooArgSet& argSet) ;
  RooArgSet* select(const RooArgSet& list) const ;
  Bool_t operator==(const RooNameSet& other) ;
  RooNameSet& operator=(const RooNameSet&) ;
  Bool_t operator<(const RooNameSet& other) const ;

  virtual void printName(std::ostream& os) const ;
  virtual void printTitle(std::ostream& os) const ;
  virtual void printClassName(std::ostream& os) const ;
  virtual void printValue(std::ostream& os) const ;

  inline virtual void Print(Option_t *options= 0) const {
    printStream(defaultPrintStream(),defaultPrintContents(options),defaultPrintStyle(options));
  }

  void setNameList(const char* givenList) ;
  const char* content() const { return _nameList ; }

  Int_t _len ;
  char* _nameList ; //[_len]

protected:

  void extendBuffer(Int_t inc) ;

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return RooNameSet::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooNameSet::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooNameSet.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 59; } // A sterile version of RooArgSet, containing only the names of the contained RooAbsArgs
};
# 22 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsPdf.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooObjCacheManager.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooObjCacheManager.h 42976 2012-02-12 16:20:54Z wouter $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h" 1
/* @(#)root/base:$Id: Rtypes.h 43708 2012-04-12 10:19:00Z axel $ */

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooObjCacheManager.h" 2

# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooNormSetCache.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooNormSetCache.h,v 1.12 2007/08/09 19:55:47 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Riosfwd.h" 1
// @(#)root/base:$Id: Riosfwd.h 20877 2007-11-19 11:17:07Z rdm $
// Author: Fons Rademakers   23/1/02

/*************************************************************************
 * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooNormSetCache.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/assert.h" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
/****************************************************************
* assert.h
*****************************************************************/
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooNormSetCache.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h" 1
/* @(#)root/base:$Id: Rtypes.h 43708 2012-04-12 10:19:00Z axel $ */

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 22 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooNormSetCache.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooNameSet.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooNameSet.h,v 1.16 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 23 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooNormSetCache.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooSetPair.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooSetPair.h,v 1.4 2007/08/09 19:55:47 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TObject.h" 1
// @(#)root/base:$Id: TObject.h 38832 2011-04-13 17:54:49Z rdm $
// Author: Rene Brun   26/12/94

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooSetPair.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooArgSet.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooArgSet.h,v 1.45 2007/08/09 19:55:47 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooSetPair.h" 2

class RooLinkedListElem ;
class TBuffer ;

class RooSetPair : public TObject {
public:

  // Initial element ctor
  RooSetPair(const RooArgSet* set1=0, const RooArgSet* set2=0) :
    _set1(const_cast<RooArgSet*>(set1)), _set2(const_cast<RooArgSet*>(set2)) {
  }

  // Destructor
  virtual ~RooSetPair() {
  }

  RooArgSet* _set1 ;
  RooArgSet* _set2 ;

  virtual ULong_t Hash() const {
    return TString::Hash((void*)&_set1,2*sizeof(void*)) ;
  }

protected:


  // Forbidden
  RooSetPair(const RooSetPair&) ;

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 0; } static void Dictionary(); virtual TClass *IsA() const { return RooSetPair::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooSetPair::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooSetPair.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 50; } // Utility class holding a pair of RooArgSet pointers
} ;
# 24 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooNormSetCache.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooHashTable.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooHashTable.h,v 1.12 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 25 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooNormSetCache.h" 2

class RooArgSet ;
class RooSetPair ;

typedef RooArgSet* pRooArgSet ;

class RooNormSetCache {

public:
  RooNormSetCache(Int_t regSize=32) ;
  RooNormSetCache(const RooNormSetCache& other) ;
  virtual ~RooNormSetCache() ;

  void add(const RooArgSet* set1, const RooArgSet* set2=0) ;

  inline Int_t index(const RooArgSet* set1, const RooArgSet* set2=0, const TNamed* set2RangeName=0) {

    // Match range name first
    if (set2RangeName != _set2RangeName) return -1 ;

    // Match pointer of sets
    Int_t i ;
    for (i=0 ; i<_nreg ; i++) {
      if (_asArr[i]._set1 == set1 &&
   _asArr[i]._set2 == set2
   ) return i ;
    }

    return -1 ;
  }

  inline Bool_t contains(const RooArgSet* set1, const RooArgSet* set2=0, const TNamed* set2RangeName=0) {
    if (set2RangeName!=_set2RangeName) return kFALSE ;
    if (_htable) return (_htable->findSetPair(set1,set2)) ;
    return (index(set1,set2,set2RangeName)>=0) ;
  }

  inline Bool_t containsSet1(const RooArgSet* set1) {
    Int_t i ;
    for (i=0 ; i<_nreg ; i++) {
      if (_asArr[i]._set1 == set1) return kTRUE ;
    }
    return kFALSE ;
  }

  const RooArgSet* lastSet1() const { return _nreg>0?_asArr[_nreg-1]._set1:0 ; }
  const RooArgSet* lastSet2() const { return _nreg>0?_asArr[_nreg-1]._set2:0 ; }
  const RooNameSet& nameSet1() const { return _name1 ; }
  const RooNameSet& nameSet2() const { return _name2 ; }

  Bool_t autoCache(const RooAbsArg* self, const RooArgSet* set1, const RooArgSet* set2=0, const TNamed* set2RangeName=0, Bool_t autoRefill=kTRUE) ;

  void clear() ;
  Int_t entries() const { return _nreg ; }

  void initialize(const RooNormSetCache& other) ;

protected:

  void expand() ;

  RooHashTable* _htable ; //! do not persist
  Int_t _regSize ;
  Int_t _nreg ;
  RooSetPair* _asArr ; //! do not persist

  RooNameSet _name1 ; //!
  RooNameSet _name2 ; //!
  TNamed* _set2RangeName ; //!

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return RooNormSetCache::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooNormSetCache::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooNormSetCache.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 95; } // Management tool for tracking sets of similar integration/normalization sets
} ;
# 22 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooObjCacheManager.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsReal.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooAbsReal.h,v 1.75 2007/07/13 21:50:24 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 23 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooObjCacheManager.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooArgSet.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooArgSet.h,v 1.45 2007/08/09 19:55:47 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 24 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooObjCacheManager.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooArgList.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooArgList.h,v 1.14 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 25 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooObjCacheManager.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsCache.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooAbsCache.h 44982 2012-07-10 08:36:13Z moneta $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 26 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooObjCacheManager.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsCacheElement.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooAbsCacheElement.h 24247 2008-06-12 14:54:32Z wouter $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h" 1
/* @(#)root/base:$Id: Rtypes.h 43708 2012-04-12 10:19:00Z axel $ */

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsCacheElement.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsArg.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooAbsArg.h,v 1.93 2007/07/16 21:04:28 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsCacheElement.h" 2

class RooAbsCollection ;
class RooArgSet ;
class RooArgList ;

class RooAbsCacheElement {

public:
  RooAbsCacheElement() : _owner(0) {
    // Default constructor
  } ;
  virtual Bool_t redirectServersHook(const RooAbsCollection& /*newServerList*/, Bool_t /*mustReplaceAll*/,
         Bool_t /*nameChange*/, Bool_t /*isRecursive*/) ;
  virtual void printCompactTreeHook(std::ostream&, const char *, Int_t curElem, Int_t totElem) ;
  virtual ~RooAbsCacheElement() {
    // Destructor
  } ;

  enum Action { OperModeChange,OptimizeCaching,FindConstantNodes } ;
  virtual RooArgList containedArgs(Action) = 0 ;
  virtual void operModeHook(RooAbsArg::OperMode) ;
  virtual void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes) ;
  virtual void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes) ;

  void setOwner(RooAbsArg* owner) {
    // Store pointer to owner
    _owner = owner ;
  }

protected:

  RooAbsArg* _owner ; //! Pointer to owning RooAbsArg

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return RooAbsCacheElement::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooAbsCacheElement::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsCacheElement.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 54; } // Base class for cache elements

} ;
# 27 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooObjCacheManager.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCacheManager.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooCacheManager.h 44982 2012-07-10 08:36:13Z moneta $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h" 1
/* @(#)root/base:$Id: Rtypes.h 43708 2012-04-12 10:19:00Z axel $ */

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCacheManager.h" 2

# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooMsgService.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooMsgService.h,v 1.2 2007/07/13 21:50:24 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Riosfwd.h" 1
// @(#)root/base:$Id: Riosfwd.h 20877 2007-11-19 11:17:07Z rdm $
// Author: Fons Rademakers   23/1/02

/*************************************************************************
 * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooMsgService.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/assert.h" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
/****************************************************************
* assert.h
*****************************************************************/
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooMsgService.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TObject.h" 1
// @(#)root/base:$Id: TObject.h 38832 2011-04-13 17:54:49Z rdm $
// Author: Rene Brun   26/12/94

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 22 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooMsgService.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/string" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_string" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// string
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/string" 2
}
# 23 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooMsgService.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/vector" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_vector" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <vector.dll>
#pragma include_noerr <vectorbool.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/vector

#pragma ifndef PREC_STL_VECTOR
#pragma define PREC_STL_VECTOR
#pragma link off global PREC_STL_VECTOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from ANSI/ISO C++ 1997/Nov draft 
// Got some ideas from Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <iterator.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/iterator

#pragma ifndef PREC_STL_ITERATOR
#pragma define PREC_STL_ITERATOR
#pragma link off global PREC_STL_ITERATOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from STL HP implementation 1994
// Imported from STL SGI implementation 1997 
// Imported from ANSI/ISO C++ draft Nov 1997
// Modified by Masaharu Goto
// May need improvement for the latest standard


////////////////////////////////////////////////////////////////////////
// iterator_tag
////////////////////////////////////////////////////////////////////////
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag {};
struct bidirectional_iterator_tag {};
struct random_access_iterator_tag {};

////////////////////////////////////////////////////////////////////////
// iterator template
////////////////////////////////////////////////////////////////////////
template <class T, class Distance> struct input_iterator {};
struct output_iterator {};
template <class T, class Distance> struct forward_iterator {};
template <class T, class Distance> struct bidirectional_iterator {};
template <class T, class Distance> struct random_access_iterator {};

#pragma link off class output_iterator;







////////////////////////////////////////////////////////////////////////
// iterator_category overloaded function
////////////////////////////////////////////////////////////////////////
template <class T, class Distance>
inline input_iterator_tag
iterator_category(const input_iterator<T, Distance>&) {
    return input_iterator_tag();
}

inline output_iterator_tag iterator_category(const output_iterator&) {
    return output_iterator_tag();
}

#pragma link off function iterator_category(const output_iterator&);


template <class T, class Distance>
inline forward_iterator_tag
iterator_category(const forward_iterator<T, Distance>&) {
    return forward_iterator_tag();
}

template <class T, class Distance>
inline bidirectional_iterator_tag
iterator_category(const bidirectional_iterator<T, Distance>&) {
    return bidirectional_iterator_tag();
}

template <class T, class Distance>
inline random_access_iterator_tag
iterator_category(const random_access_iterator<T, Distance>&) {
    return random_access_iterator_tag();
}

template <class T>
inline random_access_iterator_tag
iterator_category(const T*) {
    return random_access_iterator_tag();
}


// iterator_traits, iterator and reverse_iterator template may not be
// needed for precompiled library interface 

////////////////////////////////////////////////////////////////////////
// iterator_traits
////////////////////////////////////////////////////////////////////////

template <class Iterator>
struct iterator_traits {
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type value_type;
  typedef typename Iterator::difference_type difference_type;
  typedef typename Iterator::pointer pointer;
  typedef typename Iterator::reference reference;
};

// template partial specialization, implement in cint5.15.14 1587
template <class T>
struct iterator_traits<T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
};

// incomplete implementation in cint5.15.14 1587, need some fix
// iterator_traits<const int*> is changed as iterator_traits<const int* const>
// or something, but cint5.15.14 can not handle this well
template <class T>
struct iterator_traits<const T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef const T* pointer;
  typedef const T& reference;
};

////////////////////////////////////////////////////////////////////////
// iterator
////////////////////////////////////////////////////////////////////////
template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator {
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
  typedef Category iterator_category;
};


////////////////////////////////////////////////////////////////////////
// reverse_iterator
////////////////////////////////////////////////////////////////////////






template <class Iterator>
class reverse_iterator
# 166 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
{




 public:
# 181 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
   typedef Iterator::pointer pointer;
   typedef Iterator::reference reference;
   typedef ptrdiff_t difference_type;


   reverse_iterator();
   //reverse_iterator(Iterator x);



   Iterator base() const; // explicit
   reference operator*() const;
   pointer operator->() const;
   reverse_iterator& operator++();
   reverse_iterator operator++(int);
   reverse_iterator& operator--();
   reverse_iterator operator--(int);
   reverse_iterator operator+ (difference_type n) const;
   reverse_iterator& operator+=(difference_type n);
   reverse_iterator operator- (difference_type n) const;
   reverse_iterator& operator-=(difference_type n);
   reference operator[](difference_type n) const;
};
# 932 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
// for g++ 3.1,3.2
namespace __gnu_cxx
{
  // This iterator adapter is 'normal' in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                    difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparaison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  // _GLIBCPP_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
     const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
} // namespace __gnu_cxx







#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 2
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <memory.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/memory

#pragma ifndef PREC_STL_MEMORY
#pragma define PREC_STL_MEMORY
#pragma link off global PREC_STL_MEMORY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////


template <class _Tp>
class allocator {
  //typedef alloc _Alloc;          // The underlying allocator.
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  typedef typename _Tp* pointer;
  typedef const typename _Tp * const_pointer;




  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() ;
  allocator(const allocator&) ;
  //template <class _Tp1> allocator(const allocator<_Tp1>&) ;
  ~allocator() ;

  pointer address(reference __x) const ;
  const_pointer address(const_reference __x) const ;

  // __n is permitted to be 0.  The C++ standard says nothing about what
  // the return value is when __n == 0.
  _Tp* allocate(size_type __n, const void* = 0) ;

  // __p is not permitted to be a null pointer.
  void deallocate(pointer __p, size_type __n);

  size_type max_size() const ;

  void construct(pointer __p, const _Tp& __val) ;
  void destroy(pointer __p) ;
};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;
  typedef void value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };
};
//////////////////////////////////////////////////////////////////////
# 205 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////

/**********************************************************************
* auto_ptr
**********************************************************************/
template <class X> class auto_ptr {
private:
  X* ptr;
  //template<class Y> struct auto_ptr_ref { };
public:
  typedef X element_type;
  explicit auto_ptr(X* p = 0) : ptr(p) {}
  auto_ptr(auto_ptr& a) {ptr=a.ptr;}

  // this implementation may not be correct
  template <class T> auto_ptr(auto_ptr<T>& a) {ptr=a.release();}
# 229 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  auto_ptr& operator=(auto_ptr& a) {
    if (a.ptr != ptr) {
      delete ptr;
      ptr = a.ptr;
    }
    return(*this);
  }

  // this implementation may not be correct
  template <class T> auto_ptr& operator=(auto_ptr<T>& a) {
    if (a.ptr != ptr) {
       delete ptr;
       ptr = a.release();
    }
    return(*this);
  }

  ~auto_ptr() { delete ptr; }

  X& operator*() const { return *ptr; }
  X* operator->() const { return ptr; }
  X* get() const { return ptr; }
  X* release() { X *old = ptr; ptr = 0; return 0; }
# 262 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  // auto_ptr conversions
  //auto_ptr(auto_ptr_ref<X>& x) { }
  //template<class Y> operator auto_ptr_ref<Y>() { return auto_ptr_ref<Y>(); }
  //template<class Y> operator auto_ptr<Y>() { return auto_ptr<T>(); }
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 2
# 28 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <utility.dll>


#pragma include_noerr <pair.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/utility

#pragma ifndef PREC_STL_UTILITY
#pragma define PREC_STL_UTILITY
#pragma link off global PREC_STL_UTILITY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

template <class T1, class T2>
struct pair {
  T1 first;
  T2 second;
  pair() : first(T1()), second(T2()) {}
  pair(const T1& a, const T2& b) : first(a), second(b) {}
 private:
  pair& operator=(const pair& x){first=x.first;second=x.second;return *this;}
};

#pragma endif
# 17 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 2
# 29 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector" 2
# 37 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
template<class T,class Allocator=std::allocator<T> >
# 49 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
class vector {
 public:
  typedef T value_type;


  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
# 218 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
  class iterator {
   public:
     typedef vector::pointer pointer;
     typedef vector::const_pointer const_pointer;
     typedef vector::reference reference;
     typedef vector::const_reference const_reference;
     typedef vector::size_type size_type;
     typedef vector::difference_type difference_type;

      iterator();
      explicit iterator(const pointer& __i) ;
      // Allow iterator to const_iterator conversion
      template<typename _Iter> inline iterator(const iterator& __i);

      // Forward iterator requirements
      reference operator*() const ;
      pointer operator->() const ;
      iterator& operator++();
      iterator operator++(int) ;

      // Bidirectional iterator requirements
      iterator& operator--() ;
      iterator operator--(int) ;

      // Random access iterator requirements
      reference operator[](const difference_type& __n) const;
      iterator& operator+=(const difference_type& __n);
      iterator operator+(const difference_type& __n) const;
      iterator& operator-=(const difference_type& __n);
      iterator operator-(const difference_type& __n) const;
      const pointer& base() const ;

      iterator operator=(const iterator& x) ;

  };

  friend bool operator==(const vector::iterator& x,const vector::iterator& y)const;
  friend bool operator!=(const vector::iterator& x,const vector::iterator& y)const;
  friend bool operator<(const vector::iterator& x,const vector::iterator& y)const;
  friend bool operator>(const vector::iterator& x,const vector::iterator& y)const;
  friend bool operator<=(const vector::iterator& x,const vector::iterator& y)const;
  friend bool operator>=(const vector::iterator& x,const vector::iterator& y)const;
  friend vector::iterator::difference_type operator-(const vector::iterator& x,const vector::iterator& y)const;
  friend vector::iterator operator+(const vector::iterator::difference_type x,const vector::iterator& y)const;

  typedef const iterator const_iterator;
# 355 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
  typedef reverse_iterator<const_iterator> const_reverse_iterator;
  typedef reverse_iterator<iterator> reverse_iterator;
# 398 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
  friend bool operator==(const vector::reverse_iterator& x
                        ,const vector::reverse_iterator& y) const;
  friend bool operator!=(const vector::reverse_iterator& x
                        ,const vector::reverse_iterator& y) const;






  friend bool operator==(vector::const_iterator& x
                        ,vector::const_iterator& y) const;
  friend bool operator!=(vector::const_iterator& x
                        ,vector::const_iterator& y) const;
# 422 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
  reference at(size_type n);
  const_reference at(size_type n) const;

  iterator begin(void) ;
  iterator end(void) ;
  reverse_iterator rbegin(void) ;
  reverse_iterator rend(void) ;






  size_type size(void) const ;
  size_type max_size(void) const ;
  void resize(size_type sz) ;
  void resize(size_type sz, T c) ;
  size_type capacity(void) const ;
  bool empty(void) const ;
  reference operator[](size_type n) ;
  const_reference operator[](size_type n) const;
  vector(void) ;
  vector(size_type n,const T& value=T()) ;
  vector(const vector& x) ;
  vector(const_iterator first,const_iterator last) ;
  ~vector(void) ;
  vector& operator=(const vector& x);
  void reserve(size_type n) ;
  T& front(void) ;
  T& back(void) ;
  void push_back(const T& x) ;
  void swap(vector& x);
  iterator insert(iterator position,const T& x);
  void insert(iterator position,const_iterator first,const_iterator last);
  void insert(iterator position,size_type n,const T& x);
  void pop_back(void) ;
  void erase(iterator position) ;
  void erase(iterator first,iterator last) ;
  void clear() ;


  friend bool operator==(const vector& x, const vector& y);
  friend bool operator< (const vector& x, const vector& y);
  friend bool operator!=(const vector& x, const vector& y);
  friend bool operator> (const vector& x, const vector& y);
  friend bool operator>=(const vector& x, const vector& y);
  friend bool operator<=(const vector& x, const vector& y);



  // specialized algorithms:






#pragma ifndef G__NOALGORITHM

  // Generic algorithm


  // input iter
  friend vector::iterator
    find(vector::iterator first,vector::iterator last,const T& value);
  // forward iter
  friend vector::iterator
    find_end(vector::iterator first1,vector::iterator last1,
      vector::iterator first2,vector::iterator last2);
  friend vector::iterator
    find_first_of(vector::iterator first1,vector::iterator last1,
           vector::iterator first2,vector::iterator last2);
  friend vector::iterator
    adjacent_find(vector::iterator first,vector::iterator last);
  // input iter

  friend vector::difference_type
    count(vector::iterator first,vector::iterator last,const T& value);






  friend bool
    equal(vector::iterator first1,vector::iterator last1,
          vector::iterator first2);
  // forward iter
  friend vector::iterator
    search(vector::iterator first1,vector::iterator last1,
           vector::iterator first2,vector::iterator last2);
  friend vector::iterator
    search_n(vector::iterator first,vector::iterator last
             ,vector::size_type count,const T& value);
  // input and output iter -> forward iter
  friend vector::iterator
    copy(vector::iterator first,vector::iterator last,
         vector::iterator result);
  // bidirectional iter
  friend vector::iterator
    copy_backward(vector::iterator first,vector::iterator last,
                  vector::iterator result);
  // just value_type
  friend void swap(T& a,T& b);
  // forward iter
  friend vector::iterator
    swap_ranges(vector::iterator first1,vector::iterator last1,
                vector::iterator first2);
  friend void iter_swap(vector::iterator a,vector::iterator b);
  friend void replace(vector::iterator first,vector::iterator last,
                      const T& old_value,const T& new_value);
  // input, output iter -> forward iter
  friend vector::iterator
    replace_copy(vector::iterator first,vector::iterator last,
                 vector::iterator result,
                 const T& old_value,const T& new_value);
  // forward iter
  friend void
    fill(vector::iterator first,vector::iterator last,const T& value);

  friend void
    fill_n(vector::iterator first,vector::size_type n,const T& value);

  friend vector::iterator
    remove(vector::iterator first,vector::iterator last,const T& value);
  // input,output iter -> forward iter
  friend vector::iterator
    remove_copy(vector::iterator first,vector::iterator last,
                vector::iterator result,const T& value);
  friend vector::iterator
    unique(vector::iterator first,vector::iterator last);
  friend vector::iterator
    unique_copy(vector::iterator first,vector::iterator last,
                vector::iterator result);
  friend void reverse(vector::iterator first,vector::iterator last);
  friend vector::iterator
     reverse_copy(vector::iterator first,vector::iterator last,
                  vector::iterator result);
  // forward iter

  friend void rotate(vector::iterator first,vector::iterator mid,
                     vector::iterator last);

  // forward iter
  friend vector::iterator
    rotate_copy(vector::iterator first,vector::iterator mid,
                vector::iterator last,vector::iterator result);
  // randomaccess iter
  friend void random_shuffle(vector::iterator first,vector::iterator last);
  // randomaccess iter
  friend void sort(vector::iterator first,vector::iterator last);
  friend void stable_sort(vector::iterator first,vector::iterator last);
  friend void partial_sort(vector::iterator first,vector::iterator mid,
                           vector::iterator last);
  friend vector::iterator
    partial_sort_copy(vector::iterator first,vector::iterator last,
                      vector::iterator result_first,
                      vector::iterator result_last);
  friend void nth_element(vector::iterator first,vector::iterator nth,
                          vector::iterator last);
  // forward iter
  friend vector::iterator
    lower_bound(vector::iterator first,vector::iterator last,const T& value);
  friend vector::iterator
    upper_bound(vector::iterator first,vector::iterator last,const T& value);




  friend bool binary_search(vector::iterator first,vector::iterator last,
                            const T& value);
  friend vector::iterator merge(vector::iterator first1,vector::iterator last1,
                                vector::iterator first2,vector::iterator last2,
                                vector::iterator result);
  friend void inplace_merge(vector::iterator first,vector::iterator middle,
                            vector::iterator last);
  friend bool includes(vector::iterator first1,vector::iterator last1,
                       vector::iterator first2,vector::iterator last2);
  friend vector::iterator
    set_union(vector::iterator first1,vector::iterator last1,
              vector::iterator first2,vector::iterator last2,
              vector::iterator result);
  friend vector::iterator
    set_intersection(vector::iterator first1,vector::iterator last1,
                     vector::iterator first2,vector::iterator last2,
                     vector::iterator result);
  friend vector::iterator
    set_difference(vector::iterator first1,vector::iterator last1,
                   vector::iterator first2,vector::iterator last2,
                   vector::iterator result);
  friend vector::iterator
    set_symmetric_difference(vector::iterator first1,vector::iterator last1,
                             vector::iterator first2,vector::iterator last2,
                             vector::iterator result);
  // random access
  friend void push_heap(vector::iterator first,vector::iterator last);
  friend void pop_heap(vector::iterator first,vector::iterator last);
  friend void make_heap(vector::iterator first,vector::iterator last);
  friend void sort_heap(vector::iterator first,vector::iterator last);
  // min,max, just value_type
  friend const T& min(const T& a,const T& b);
  friend const T& max(const T& a,const T& b);
  // forward iter
  friend vector::iterator
    min_element(vector::iterator first,vector::iterator last);
  friend vector::iterator
    max_element(vector::iterator first,vector::iterator last);
  // input iter
  friend bool
    lexicographical_compare(vector::iterator first1,vector::iterator last1,
                            vector::iterator first2,vector::iterator last2);
  // bidirectional iter
  friend bool next_permutation(vector::iterator first,vector::iterator last);
  friend bool prev_permutation(vector::iterator first,vector::iterator last);
# 662 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
#pragma endif

  // iterator_category resolution
  //friend random_access_iterator_tag iterator_category(vector::iterator x);

};
# 837 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
#pragma endif
# 15 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_vector" 2
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/vector" 2
}
# 24 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooMsgService.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/stack" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_stack" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <stack.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/stack" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/stack

#pragma ifndef PREC_STL_STACK
#pragma define PREC_STL_STACK
#pragma link off global PREC_STL_STACK;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from ANSI/ISO C++ 1997/Nov draft 
// Got some ideas from Scott Snyder, Fermi-lab
// Modified by Masaharu Goto

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_deque" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <deque.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/deque" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/deque

#pragma ifndef PREC_STL_DEQUE
#pragma define PREC_STL_DEQUE
#pragma link off global PREC_STL_DEQUE;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from ANSI/ISO C++ 1997/Nov draft 
// Got some ideas from Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <iterator.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/iterator

#pragma ifndef PREC_STL_ITERATOR
#pragma define PREC_STL_ITERATOR
#pragma link off global PREC_STL_ITERATOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from STL HP implementation 1994
// Imported from STL SGI implementation 1997 
// Imported from ANSI/ISO C++ draft Nov 1997
// Modified by Masaharu Goto
// May need improvement for the latest standard


////////////////////////////////////////////////////////////////////////
// iterator_tag
////////////////////////////////////////////////////////////////////////
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag {};
struct bidirectional_iterator_tag {};
struct random_access_iterator_tag {};

////////////////////////////////////////////////////////////////////////
// iterator template
////////////////////////////////////////////////////////////////////////
template <class T, class Distance> struct input_iterator {};
struct output_iterator {};
template <class T, class Distance> struct forward_iterator {};
template <class T, class Distance> struct bidirectional_iterator {};
template <class T, class Distance> struct random_access_iterator {};

#pragma link off class output_iterator;







////////////////////////////////////////////////////////////////////////
// iterator_category overloaded function
////////////////////////////////////////////////////////////////////////
template <class T, class Distance>
inline input_iterator_tag
iterator_category(const input_iterator<T, Distance>&) {
    return input_iterator_tag();
}

inline output_iterator_tag iterator_category(const output_iterator&) {
    return output_iterator_tag();
}

#pragma link off function iterator_category(const output_iterator&);


template <class T, class Distance>
inline forward_iterator_tag
iterator_category(const forward_iterator<T, Distance>&) {
    return forward_iterator_tag();
}

template <class T, class Distance>
inline bidirectional_iterator_tag
iterator_category(const bidirectional_iterator<T, Distance>&) {
    return bidirectional_iterator_tag();
}

template <class T, class Distance>
inline random_access_iterator_tag
iterator_category(const random_access_iterator<T, Distance>&) {
    return random_access_iterator_tag();
}

template <class T>
inline random_access_iterator_tag
iterator_category(const T*) {
    return random_access_iterator_tag();
}


// iterator_traits, iterator and reverse_iterator template may not be
// needed for precompiled library interface 

////////////////////////////////////////////////////////////////////////
// iterator_traits
////////////////////////////////////////////////////////////////////////

template <class Iterator>
struct iterator_traits {
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type value_type;
  typedef typename Iterator::difference_type difference_type;
  typedef typename Iterator::pointer pointer;
  typedef typename Iterator::reference reference;
};

// template partial specialization, implement in cint5.15.14 1587
template <class T>
struct iterator_traits<T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
};

// incomplete implementation in cint5.15.14 1587, need some fix
// iterator_traits<const int*> is changed as iterator_traits<const int* const>
// or something, but cint5.15.14 can not handle this well
template <class T>
struct iterator_traits<const T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef const T* pointer;
  typedef const T& reference;
};

////////////////////////////////////////////////////////////////////////
// iterator
////////////////////////////////////////////////////////////////////////
template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator {
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
  typedef Category iterator_category;
};


////////////////////////////////////////////////////////////////////////
// reverse_iterator
////////////////////////////////////////////////////////////////////////






template <class Iterator>
class reverse_iterator
# 166 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
{




 public:
# 181 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
   typedef Iterator::pointer pointer;
   typedef Iterator::reference reference;
   typedef ptrdiff_t difference_type;


   reverse_iterator();
   //reverse_iterator(Iterator x);



   Iterator base() const; // explicit
   reference operator*() const;
   pointer operator->() const;
   reverse_iterator& operator++();
   reverse_iterator operator++(int);
   reverse_iterator& operator--();
   reverse_iterator operator--(int);
   reverse_iterator operator+ (difference_type n) const;
   reverse_iterator& operator+=(difference_type n);
   reverse_iterator operator- (difference_type n) const;
   reverse_iterator& operator-=(difference_type n);
   reference operator[](difference_type n) const;
};
# 932 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
// for g++ 3.1,3.2
namespace __gnu_cxx
{
  // This iterator adapter is 'normal' in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                    difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparaison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  // _GLIBCPP_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
     const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
} // namespace __gnu_cxx







#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 2
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/deque" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <memory.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/memory

#pragma ifndef PREC_STL_MEMORY
#pragma define PREC_STL_MEMORY
#pragma link off global PREC_STL_MEMORY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////


template <class _Tp>
class allocator {
  //typedef alloc _Alloc;          // The underlying allocator.
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  typedef typename _Tp* pointer;
  typedef const typename _Tp * const_pointer;




  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() ;
  allocator(const allocator&) ;
  //template <class _Tp1> allocator(const allocator<_Tp1>&) ;
  ~allocator() ;

  pointer address(reference __x) const ;
  const_pointer address(const_reference __x) const ;

  // __n is permitted to be 0.  The C++ standard says nothing about what
  // the return value is when __n == 0.
  _Tp* allocate(size_type __n, const void* = 0) ;

  // __p is not permitted to be a null pointer.
  void deallocate(pointer __p, size_type __n);

  size_type max_size() const ;

  void construct(pointer __p, const _Tp& __val) ;
  void destroy(pointer __p) ;
};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;
  typedef void value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };
};
//////////////////////////////////////////////////////////////////////
# 205 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////

/**********************************************************************
* auto_ptr
**********************************************************************/
template <class X> class auto_ptr {
private:
  X* ptr;
  //template<class Y> struct auto_ptr_ref { };
public:
  typedef X element_type;
  explicit auto_ptr(X* p = 0) : ptr(p) {}
  auto_ptr(auto_ptr& a) {ptr=a.ptr;}

  // this implementation may not be correct
  template <class T> auto_ptr(auto_ptr<T>& a) {ptr=a.release();}
# 229 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  auto_ptr& operator=(auto_ptr& a) {
    if (a.ptr != ptr) {
      delete ptr;
      ptr = a.ptr;
    }
    return(*this);
  }

  // this implementation may not be correct
  template <class T> auto_ptr& operator=(auto_ptr<T>& a) {
    if (a.ptr != ptr) {
       delete ptr;
       ptr = a.release();
    }
    return(*this);
  }

  ~auto_ptr() { delete ptr; }

  X& operator*() const { return *ptr; }
  X* operator->() const { return ptr; }
  X* get() const { return ptr; }
  X* release() { X *old = ptr; ptr = 0; return 0; }
# 262 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  // auto_ptr conversions
  //auto_ptr(auto_ptr_ref<X>& x) { }
  //template<class Y> operator auto_ptr_ref<Y>() { return auto_ptr_ref<Y>(); }
  //template<class Y> operator auto_ptr<Y>() { return auto_ptr<T>(); }
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 2
# 28 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/deque" 2


template<class T,class Allocator=std::allocator<T> >
# 42 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/deque"
class deque {
 public:
  typedef T value_type;
  typedef Allocator allocator_type;

  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
# 62 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/deque"
  class iterator
# 77 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/deque"
 {
   public:
    iterator() ;
    iterator(const iterator& x) ;


    iterator& operator=(const iterator& x) ;

    T& operator*() const ;

    T* operator->() const;

    iterator& operator++();
    iterator operator++(int a);
    iterator& operator--();
    iterator operator--(int a);
# 102 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/deque"
    iterator operator+(long n);
    iterator operator-(long n);
    iterator& operator+=(long n);
    iterator& operator-=(long n);
    T& operator[](long n) ;
  };




  friend bool operator==(const deque::iterator& x
                        ,const deque::iterator& y) const;
  friend bool operator!=(const deque::iterator& x
                        ,const deque::iterator& y) const;


  class reverse_iterator
# 133 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/deque"
 {
   public:
    reverse_iterator(const reverse_iterator& x);

    reverse_iterator& operator=(const reverse_iterator& x) ;




    T& operator*() const ;


    T* operator->() const;

    reverse_iterator& operator++();
    reverse_iterator operator++(int a);
    reverse_iterator& operator--();
    reverse_iterator operator--(int a);
    reverse_iterator operator+(long n);
    reverse_iterator operator-(long n);
    reverse_iterator& operator+=(long n);
    reverse_iterator& operator-=(long n);
    T& operator[](long n) ;
   private:
  };
  friend bool operator==(const deque::reverse_iterator& x
                        ,const deque::reverse_iterator& y) const;
  friend bool operator!=(const deque::reverse_iterator& x
                        ,const deque::reverse_iterator& y) const;

  typedef const iterator const_iterator;
  typedef const reverse_iterator const_reverse_iterator;

  deque();
  deque(size_type n, const T& value = T());






  deque(const T* first,const T* last) ;

  deque(const_iterator first, const_iterator last);

  deque(const deque& x);
  ~deque();
  deque& operator=(const deque& x);







  //allocator_type get_allocator() const;
  // iterators:
  iterator begin();
  iterator end();
  reverse_iterator rbegin();
  reverse_iterator rend();






  // _lib.deque.capacity_ capacity:
  size_type size() const;
  size_type max_size() const;
  void resize(size_type sz, T c = T());
  bool empty() const;

  // element access:
  T& operator[](size_type n);
  //const_reference operator[](size_type n) const;



  //const_reference at(size_type n) const;
  T& front();
  //const_reference front() const;
  T& back();
  //const_reference back() const;
  // _lib.deque.modifiers_ modifiers:
  void push_front(const T& x);
  void push_back(const T& x);
  iterator insert(iterator position, const T& x);
  void insert(iterator position, size_type n, const T& x);





  void pop_front();
  void pop_back();
  iterator erase(iterator position);
  iterator erase(iterator first, iterator last);
  void swap(deque<T,Allocator>&);
  void clear();

  friend bool operator==(const deque& x, const deque& y);
  friend bool operator< (const deque& x, const deque& y);
  friend bool operator!=(const deque& x, const deque& y);
  friend bool operator> (const deque& x, const deque& y);
  friend bool operator>=(const deque& x, const deque& y);
  friend bool operator<=(const deque& x, const deque& y);
  // specialized algorithms:





#pragma ifndef G__NOALGORITHM
  // Generic algorithm


  // input iter
  friend deque::iterator
    find(deque::iterator first,deque::iterator last,const T& value);
  // forward iter
  friend deque::iterator
    find_end(deque::iterator first1,deque::iterator last1,
      deque::iterator first2,deque::iterator last2);
  friend deque::iterator
    find_first_of(deque::iterator first1,deque::iterator last1,
           deque::iterator first2,deque::iterator last2);
  friend deque::iterator
    adjacent_find(deque::iterator first,deque::iterator last);
  // input iter

  friend deque::difference_type
    count(deque::iterator first,deque::iterator last,const T& value);






  friend bool
    equal(deque::iterator first1,deque::iterator last1,
          deque::iterator first2);
  // forward iter
  friend deque::iterator
    search(deque::iterator first1,deque::iterator last1,
           deque::iterator first2,deque::iterator last2);
  friend deque::iterator
    search_n(deque::iterator first,deque::iterator last
             ,deque::size_type count,const T& value);
  // input and output iter -> forward iter
  friend deque::iterator
    copy(deque::iterator first,deque::iterator last,
         deque::iterator result);
  // bidirectional iter
  friend deque::iterator
    copy_backward(deque::iterator first,deque::iterator last,
                  deque::iterator result);
  // just value_type
  friend void swap(T& a,T& b);
  // forward iter
  friend deque::iterator
    swap_ranges(deque::iterator first1,deque::iterator last1,
                deque::iterator first2);
  friend void iter_swap(deque::iterator a,deque::iterator b);
  friend void replace(deque::iterator first,deque::iterator last,
                      const T& old_value,const T& new_value);
  // input, output iter -> forward iter
  friend deque::iterator
    replace_copy(deque::iterator first,deque::iterator last,
                 deque::iterator result,
                 const T& old_value,const T& new_value);
  // forward iter
  friend void
    fill(deque::iterator first,deque::iterator last,const T& value);

  friend void
    fill_n(deque::iterator first,deque::size_type n,const T& value);

  friend deque::iterator
    remove(deque::iterator first,deque::iterator last,const T& value);
  // input,output iter -> forward iter
  friend deque::iterator
    remove_copy(deque::iterator first,deque::iterator last,
                deque::iterator result,const T& value);
  friend deque::iterator
    unique(deque::iterator first,deque::iterator last);
  friend deque::iterator
    unique_copy(deque::iterator first,deque::iterator last,
                deque::iterator result);
  friend void reverse(deque::iterator first,deque::iterator last);
  friend deque::iterator
     reverse_copy(deque::iterator first,deque::iterator last,
                  deque::iterator result);
  // forward iter
  friend void rotate(deque::iterator first,deque::iterator mid,
                     deque::iterator last);
  // forward iter
  friend deque::iterator
    rotate_copy(deque::iterator first,deque::iterator mid,
                deque::iterator last,deque::iterator result);
  // randomaccess iter
  friend void random_shuffle(deque::iterator first,deque::iterator last);
  // randomaccess iter
  friend void sort(deque::iterator first,deque::iterator last);
  friend void stable_sort(deque::iterator first,deque::iterator last);
  friend void partial_sort(deque::iterator first,deque::iterator mid,
                           deque::iterator last);
  friend deque::iterator
    partial_sort_copy(deque::iterator first,deque::iterator last,
                      deque::iterator result_first,
                      deque::iterator result_last);
  friend void nth_element(deque::iterator first,deque::iterator nth,
                          deque::iterator last);
  // forward iter
  friend deque::iterator
    lower_bound(deque::iterator first,deque::iterator last,const T& value);
  friend deque::iterator
    upper_bound(deque::iterator first,deque::iterator last,const T& value);




  friend bool binary_search(deque::iterator first,deque::iterator last,
                            const T& value);
  friend deque::iterator merge(deque::iterator first1,deque::iterator last1,
                                deque::iterator first2,deque::iterator last2,
                                deque::iterator result);
  friend void inplace_merge(deque::iterator first,deque::iterator middle,
                            deque::iterator last);
  friend bool includes(deque::iterator first1,deque::iterator last1,
                       deque::iterator first2,deque::iterator last2);
  friend deque::iterator
    set_union(deque::iterator first1,deque::iterator last1,
              deque::iterator first2,deque::iterator last2,
              deque::iterator result);
  friend deque::iterator
    set_intersection(deque::iterator first1,deque::iterator last1,
                     deque::iterator first2,deque::iterator last2,
                     deque::iterator result);
  friend deque::iterator
    set_difference(deque::iterator first1,deque::iterator last1,
                   deque::iterator first2,deque::iterator last2,
                   deque::iterator result);
  friend deque::iterator
    set_symmetric_difference(deque::iterator first1,deque::iterator last1,
                             deque::iterator first2,deque::iterator last2,
                             deque::iterator result);
  // random access
  friend void push_heap(deque::iterator first,deque::iterator last);
  friend void pop_heap(deque::iterator first,deque::iterator last);
  friend void make_heap(deque::iterator first,deque::iterator last);
  friend void sort_heap(deque::iterator first,deque::iterator last);
  // min,max, just value_type
  friend const T& min(const T& a,const T& b);
  friend const T& max(const T& a,const T& b);
  // forward iter
  friend deque::iterator
    min_element(deque::iterator first,deque::iterator last);
  friend deque::iterator
    max_element(deque::iterator first,deque::iterator last);
  // input iter
  friend bool
    lexicographical_compare(deque::iterator first1,deque::iterator last1,
                            deque::iterator first2,deque::iterator last2);
  // bidirectional iter
  friend bool next_permutation(deque::iterator first,deque::iterator last);
  friend bool prev_permutation(deque::iterator first,deque::iterator last);
# 425 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/deque"
#pragma endif

  // Generic algorithm
  //friend void reverse(deque::iterator first,deque::iterator last);
  //friend void reverse(deque::reverse_iterator first,deque::reverse_itetator last);

  // iterator_category resolution
  //friend random_access_iterator_tag iterator_category(deque::iterator x);
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_deque" 2
# 26 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/stack" 2

template <class T, class Container = deque<T> >
class stack {
  public:
  typedef typename Container::value_type value_type;
  typedef typename Container::size_type size_type;
  typedef Container container_type;
  protected: Container c; public:

  stack();
  //stack(const Container&);



  bool empty() const;
  size_type size() const;
  value_type& top();
  //const value_type& top() const;

  void push(const T& x);



  void pop();


  friend bool operator==(const stack& x ,const stack& y);
  friend bool operator< (const stack& x ,const stack& y);
  friend bool operator!=(const stack& x ,const stack& y);
  friend bool operator> (const stack& x ,const stack& y);
  friend bool operator>=(const stack& x ,const stack& y);
  friend bool operator<=(const stack& x ,const stack& y);

};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_stack" 2
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/stack" 2
}
# 25 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooMsgService.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/map" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_map" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <pair.dll>
#pragma include_noerr <map.dll>
#pragma include_noerr <map2.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/map

#pragma ifndef PREC_STL_MAP
#pragma define PREC_STL_MAP
#pragma link off global PREC_STL_MAP;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from ANSI/ISO C++ 1997/Nov draft 
// Got some ideas from Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <utility.dll>


#pragma include_noerr <pair.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/utility

#pragma ifndef PREC_STL_UTILITY
#pragma define PREC_STL_UTILITY
#pragma link off global PREC_STL_UTILITY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

template <class T1, class T2>
struct pair {
  T1 first;
  T2 second;
  pair() : first(T1()), second(T2()) {}
  pair(const T1& a, const T2& b) : first(a), second(b) {}
 private:
  pair& operator=(const pair& x){first=x.first;second=x.second;return *this;}
};

#pragma endif
# 17 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 2
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <memory.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/memory

#pragma ifndef PREC_STL_MEMORY
#pragma define PREC_STL_MEMORY
#pragma link off global PREC_STL_MEMORY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////


template <class _Tp>
class allocator {
  //typedef alloc _Alloc;          // The underlying allocator.
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  typedef typename _Tp* pointer;
  typedef const typename _Tp * const_pointer;




  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() ;
  allocator(const allocator&) ;
  //template <class _Tp1> allocator(const allocator<_Tp1>&) ;
  ~allocator() ;

  pointer address(reference __x) const ;
  const_pointer address(const_reference __x) const ;

  // __n is permitted to be 0.  The C++ standard says nothing about what
  // the return value is when __n == 0.
  _Tp* allocate(size_type __n, const void* = 0) ;

  // __p is not permitted to be a null pointer.
  void deallocate(pointer __p, size_type __n);

  size_type max_size() const ;

  void construct(pointer __p, const _Tp& __val) ;
  void destroy(pointer __p) ;
};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;
  typedef void value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };
};
//////////////////////////////////////////////////////////////////////
# 205 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////

/**********************************************************************
* auto_ptr
**********************************************************************/
template <class X> class auto_ptr {
private:
  X* ptr;
  //template<class Y> struct auto_ptr_ref { };
public:
  typedef X element_type;
  explicit auto_ptr(X* p = 0) : ptr(p) {}
  auto_ptr(auto_ptr& a) {ptr=a.ptr;}

  // this implementation may not be correct
  template <class T> auto_ptr(auto_ptr<T>& a) {ptr=a.release();}
# 229 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  auto_ptr& operator=(auto_ptr& a) {
    if (a.ptr != ptr) {
      delete ptr;
      ptr = a.ptr;
    }
    return(*this);
  }

  // this implementation may not be correct
  template <class T> auto_ptr& operator=(auto_ptr<T>& a) {
    if (a.ptr != ptr) {
       delete ptr;
       ptr = a.release();
    }
    return(*this);
  }

  ~auto_ptr() { delete ptr; }

  X& operator*() const { return *ptr; }
  X* operator->() const { return ptr; }
  X* get() const { return ptr; }
  X* release() { X *old = ptr; ptr = 0; return 0; }
# 262 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  // auto_ptr conversions
  //auto_ptr(auto_ptr_ref<X>& x) { }
  //template<class Y> operator auto_ptr_ref<Y>() { return auto_ptr_ref<Y>(); }
  //template<class Y> operator auto_ptr<Y>() { return auto_ptr<T>(); }
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 2
# 28 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <iterator.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/iterator

#pragma ifndef PREC_STL_ITERATOR
#pragma define PREC_STL_ITERATOR
#pragma link off global PREC_STL_ITERATOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from STL HP implementation 1994
// Imported from STL SGI implementation 1997 
// Imported from ANSI/ISO C++ draft Nov 1997
// Modified by Masaharu Goto
// May need improvement for the latest standard


////////////////////////////////////////////////////////////////////////
// iterator_tag
////////////////////////////////////////////////////////////////////////
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag {};
struct bidirectional_iterator_tag {};
struct random_access_iterator_tag {};

////////////////////////////////////////////////////////////////////////
// iterator template
////////////////////////////////////////////////////////////////////////
template <class T, class Distance> struct input_iterator {};
struct output_iterator {};
template <class T, class Distance> struct forward_iterator {};
template <class T, class Distance> struct bidirectional_iterator {};
template <class T, class Distance> struct random_access_iterator {};

#pragma link off class output_iterator;







////////////////////////////////////////////////////////////////////////
// iterator_category overloaded function
////////////////////////////////////////////////////////////////////////
template <class T, class Distance>
inline input_iterator_tag
iterator_category(const input_iterator<T, Distance>&) {
    return input_iterator_tag();
}

inline output_iterator_tag iterator_category(const output_iterator&) {
    return output_iterator_tag();
}

#pragma link off function iterator_category(const output_iterator&);


template <class T, class Distance>
inline forward_iterator_tag
iterator_category(const forward_iterator<T, Distance>&) {
    return forward_iterator_tag();
}

template <class T, class Distance>
inline bidirectional_iterator_tag
iterator_category(const bidirectional_iterator<T, Distance>&) {
    return bidirectional_iterator_tag();
}

template <class T, class Distance>
inline random_access_iterator_tag
iterator_category(const random_access_iterator<T, Distance>&) {
    return random_access_iterator_tag();
}

template <class T>
inline random_access_iterator_tag
iterator_category(const T*) {
    return random_access_iterator_tag();
}


// iterator_traits, iterator and reverse_iterator template may not be
// needed for precompiled library interface 

////////////////////////////////////////////////////////////////////////
// iterator_traits
////////////////////////////////////////////////////////////////////////

template <class Iterator>
struct iterator_traits {
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type value_type;
  typedef typename Iterator::difference_type difference_type;
  typedef typename Iterator::pointer pointer;
  typedef typename Iterator::reference reference;
};

// template partial specialization, implement in cint5.15.14 1587
template <class T>
struct iterator_traits<T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
};

// incomplete implementation in cint5.15.14 1587, need some fix
// iterator_traits<const int*> is changed as iterator_traits<const int* const>
// or something, but cint5.15.14 can not handle this well
template <class T>
struct iterator_traits<const T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef const T* pointer;
  typedef const T& reference;
};

////////////////////////////////////////////////////////////////////////
// iterator
////////////////////////////////////////////////////////////////////////
template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator {
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
  typedef Category iterator_category;
};


////////////////////////////////////////////////////////////////////////
// reverse_iterator
////////////////////////////////////////////////////////////////////////






template <class Iterator>
class reverse_iterator
# 166 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
{




 public:
# 181 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
   typedef Iterator::pointer pointer;
   typedef Iterator::reference reference;
   typedef ptrdiff_t difference_type;


   reverse_iterator();
   //reverse_iterator(Iterator x);



   Iterator base() const; // explicit
   reference operator*() const;
   pointer operator->() const;
   reverse_iterator& operator++();
   reverse_iterator operator++(int);
   reverse_iterator& operator--();
   reverse_iterator operator--(int);
   reverse_iterator operator+ (difference_type n) const;
   reverse_iterator& operator+=(difference_type n);
   reverse_iterator operator- (difference_type n) const;
   reverse_iterator& operator-=(difference_type n);
   reference operator[](difference_type n) const;
};
# 932 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
// for g++ 3.1,3.2
namespace __gnu_cxx
{
  // This iterator adapter is 'normal' in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                    difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparaison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  // _GLIBCPP_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
     const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
} // namespace __gnu_cxx







#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 2
# 29 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_functional" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <functional.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/functional" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/functional

#pragma ifndef PREC_STL_FUNCTIONAL
#pragma define PREC_STL_FUNCTIONAL
#pragma link off global PREC_STL_FUNCTIONAL;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab

// clause _lib.base_, base:
template <class Arg, class Result>
struct unary_function
{
  typedef Arg argument_type;
  typedef Result result_type;
};


template <class Arg1, class Arg2, class Result>
struct binary_function
{
  typedef Arg1 first_argument_type;
  typedef Arg2 second_argument_type;
  typedef Result result_type;
};


// clause _lib.arithmetic.operations_, arithmetic operations:
template <class T> struct plus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct minus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct multiplies : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct divides : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};

template <class T> struct modulus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};

template <class T> struct negate : unary_function<T,T> {
  T operator()(const T& x) const;
};


// clause _lib.comparisons_, comparisons:
template <class T> struct equal_to : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct not_equal_to : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct greater : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct less : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct greater_equal : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct less_equal : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};


// clause _lib.logical.operations_, logical operations:
template <class T> struct logical_and : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct logical_or : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct logical_not : unary_function<T,bool> {
  bool operator()(const T& x) const;
};


// clause _lib.negators_, negators:
template <class Predicate>
class unary_negate
  : public unary_function<Predicate::argument_type, bool>
{
public:
  explicit unary_negate(const Predicate& pred);
  bool operator()(const argument_type& x) const;
};






template <class Predicate>
class binary_negate
  : public binary_function<Predicate::first_argument_type,
                           Predicate::second_argument_type, bool>
{
public:
  explicit binary_negate(const Predicate& pred);
  bool operator()(const first_argument_type& x,
                  const second_argument_type& y) const;
};

// operations omitted (cint can't handle template forward decls...)







// clause _lib.binders_, binders:
template <class Operation>
class binder1st
  : public unary_function<Operation::second_argument_type,
                          Operation::result_type>
{
protected:
  Operation op;
  Operation::first_argument_type value;
public:
  binder1st(const Operation& x, const Operation::first_argument_type& y);
  result_type operator()(const argument_type& x) const;
};


// operations omitted (cint can't handle template forward decls...)





template <class Operation>
class binder2nd
  : public unary_function<Operation::first_argument_type,
                          Operation::result_type>
{
protected:
  Operation op;
  Operation::second_argument_type value;
public:
  binder2nd(const Operation& x, const Operation::second_argument_type& y);
  result_type operator()(const argument_type& x) const;
};


// operations omitted (cint can't handle template forward decls...)






// clause _lib.function.pointer.adaptors_, adaptors:
template <class Arg, class Result>
class pointer_to_unary_function
  : public unary_function<Arg, Result>
{
public:
  explicit pointer_to_unary_function(Result (*f)(Arg));
  Result operator()(Arg x) const;
};

// operations omitted (cint can't handle template forward decls...)





template <class Arg1, class Arg2, class Result>
class pointer_to_binary_function
  : public binary_function<Arg1,Arg2,Result>
{
public:
  explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));
  Result operator()(Arg1 x, Arg2 y) const;
};

// operations omitted (cint can't handle template forward decls...)






// omit these for now.
# 230 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/functional"
#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_functional" 2
# 30 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map" 2

//////////////////////////////////////////////////////////////////////////

template<class Key,class T,class Compare=std::less<Key>
        ,class Allocator=std::allocator<pair<const Key, T> > >
# 63 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map"
class map {
 public:
  typedef Key key_type;
  typedef T mapped_type;



  typedef pair<Key,T> value_type;

  typedef Compare key_compare;
  typedef Allocator allocator_type;

  //typedef Key*                                     pointer;
  //typedef const Key*                               const_pointer;
  //typedef Key&                                     reference;
  //typedef const Key&                               const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
# 90 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map"
  class iterator
# 103 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map"
 {
   public:
    iterator() ;
    iterator(const iterator& x) ;

    iterator& operator=(const iterator& x) ;

    value_type& operator*() ;

    value_type* operator->() ;

    iterator& operator++();
    iterator operator++(int a);
    iterator& operator--();
    iterator operator--(int a);

    bool operator==(const iterator& x) ;
    bool operator!=(const iterator& x) ;




  };
# 134 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map"
  class reverse_iterator
# 147 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/map"
 {
   public:
    reverse_iterator(const reverse_iterator& x);

    reverse_iterator& operator=(const reverse_iterator& x) ;

    value_type& operator*() ;

    value_type* operator->() ;

    reverse_iterator& operator++();
    reverse_iterator operator++(int a);
    reverse_iterator& operator--();
    reverse_iterator operator--(int a);
   private:
  };

  friend bool operator==(const map::reverse_iterator& x
                        ,const map::reverse_iterator& y) const;
  friend bool operator!=(const map::reverse_iterator& x
                        ,const map::reverse_iterator& y) const;


  typedef const iterator const_iterator;
  typedef const reverse_iterator const_reverse_iterator;

  // _lib.map.cons_ construct/copy/destroy:
  map();






  map(iterator first, iterator last);
  map(reverse_iterator first, reverse_iterator last);

  map(const map& x);
  ~map();
  map& operator=(const map& x);
  // iterators:
  iterator begin();
  iterator end();
  reverse_iterator rbegin();
  reverse_iterator rend();






  // capacity:
  bool empty() const;
  size_type size() const;
  size_type max_size() const;
  // _lib.map.access_ element access:
  T& operator[](const Key& x);
  // modifiers:
  pair<map::iterator, bool> insert(const value_type& x);
  iterator insert(iterator position, const value_type& x);





  void insert(iterator first, iterator last);
  void insert(reverse_iterator first, reverse_iterator last);

  void erase(iterator position);
  size_type erase(const Key& x);
  void erase(iterator first, iterator last);
  void swap(map&);
  void clear();
  // observers:
  //key_compare   key_comp() const;
  //value_compare value_comp() const;
  // _lib.map.ops_ map operations:
  iterator find(const Key& x);
  //const_iterator find(const Key& x) const;
  size_type count(const Key& x) const;
  iterator lower_bound(const Key& x);
  //const_iterator lower_bound(const Key& x) const;
  iterator upper_bound(const Key& x);
  //const_iterator upper_bound(const Key& x) const;





  friend bool operator==(const map& x, const map& y);
  friend bool operator< (const map& x, const map& y);
  friend bool operator!=(const map& x, const map& y);
  friend bool operator> (const map& x, const map& y);
  friend bool operator>=(const map& x, const map& y);
  friend bool operator<=(const map& x, const map& y);
  // specialized algorithms:





#pragma ifndef G__NOALGORITHM
  // Generic algorithm
  friend map::iterator
    search(map::iterator first1,map::iterator last1,
           map::iterator first2,map::iterator last2);
#pragma endif

  // iterator_category resolution
  //friend bidirectional_iterator_tag iterator_category(map::iterator x);

};

//////////////////////////////////////////////////////////////////////////

#pragma endif
# 16 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_map" 2
# 26 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_map"
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_multimap" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

//#pragma include_noerr <pair.dll> 
#pragma include_noerr <multimap.dll>
#pragma include_noerr <multimap2.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/multimap

#pragma ifndef PREC_STL_MULTIMAP
#pragma define PREC_STL_MULTIMAP
#pragma link off global PREC_STL_MULTIMAP;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from ANSI/ISO C++ 1997/Nov draft 
// Got some ideas from Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <utility.dll>


#pragma include_noerr <pair.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/utility

#pragma ifndef PREC_STL_UTILITY
#pragma define PREC_STL_UTILITY
#pragma link off global PREC_STL_UTILITY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

template <class T1, class T2>
struct pair {
  T1 first;
  T2 second;
  pair() : first(T1()), second(T2()) {}
  pair(const T1& a, const T2& b) : first(a), second(b) {}
 private:
  pair& operator=(const pair& x){first=x.first;second=x.second;return *this;}
};

#pragma endif
# 17 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 2
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <memory.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/memory

#pragma ifndef PREC_STL_MEMORY
#pragma define PREC_STL_MEMORY
#pragma link off global PREC_STL_MEMORY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////


template <class _Tp>
class allocator {
  //typedef alloc _Alloc;          // The underlying allocator.
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  typedef typename _Tp* pointer;
  typedef const typename _Tp * const_pointer;




  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() ;
  allocator(const allocator&) ;
  //template <class _Tp1> allocator(const allocator<_Tp1>&) ;
  ~allocator() ;

  pointer address(reference __x) const ;
  const_pointer address(const_reference __x) const ;

  // __n is permitted to be 0.  The C++ standard says nothing about what
  // the return value is when __n == 0.
  _Tp* allocate(size_type __n, const void* = 0) ;

  // __p is not permitted to be a null pointer.
  void deallocate(pointer __p, size_type __n);

  size_type max_size() const ;

  void construct(pointer __p, const _Tp& __val) ;
  void destroy(pointer __p) ;
};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;
  typedef void value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };
};
//////////////////////////////////////////////////////////////////////
# 205 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////

/**********************************************************************
* auto_ptr
**********************************************************************/
template <class X> class auto_ptr {
private:
  X* ptr;
  //template<class Y> struct auto_ptr_ref { };
public:
  typedef X element_type;
  explicit auto_ptr(X* p = 0) : ptr(p) {}
  auto_ptr(auto_ptr& a) {ptr=a.ptr;}

  // this implementation may not be correct
  template <class T> auto_ptr(auto_ptr<T>& a) {ptr=a.release();}
# 229 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  auto_ptr& operator=(auto_ptr& a) {
    if (a.ptr != ptr) {
      delete ptr;
      ptr = a.ptr;
    }
    return(*this);
  }

  // this implementation may not be correct
  template <class T> auto_ptr& operator=(auto_ptr<T>& a) {
    if (a.ptr != ptr) {
       delete ptr;
       ptr = a.release();
    }
    return(*this);
  }

  ~auto_ptr() { delete ptr; }

  X& operator*() const { return *ptr; }
  X* operator->() const { return ptr; }
  X* get() const { return ptr; }
  X* release() { X *old = ptr; ptr = 0; return 0; }
# 262 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  // auto_ptr conversions
  //auto_ptr(auto_ptr_ref<X>& x) { }
  //template<class Y> operator auto_ptr_ref<Y>() { return auto_ptr_ref<Y>(); }
  //template<class Y> operator auto_ptr<Y>() { return auto_ptr<T>(); }
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 2
# 28 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <iterator.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/iterator

#pragma ifndef PREC_STL_ITERATOR
#pragma define PREC_STL_ITERATOR
#pragma link off global PREC_STL_ITERATOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from STL HP implementation 1994
// Imported from STL SGI implementation 1997 
// Imported from ANSI/ISO C++ draft Nov 1997
// Modified by Masaharu Goto
// May need improvement for the latest standard


////////////////////////////////////////////////////////////////////////
// iterator_tag
////////////////////////////////////////////////////////////////////////
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag {};
struct bidirectional_iterator_tag {};
struct random_access_iterator_tag {};

////////////////////////////////////////////////////////////////////////
// iterator template
////////////////////////////////////////////////////////////////////////
template <class T, class Distance> struct input_iterator {};
struct output_iterator {};
template <class T, class Distance> struct forward_iterator {};
template <class T, class Distance> struct bidirectional_iterator {};
template <class T, class Distance> struct random_access_iterator {};

#pragma link off class output_iterator;







////////////////////////////////////////////////////////////////////////
// iterator_category overloaded function
////////////////////////////////////////////////////////////////////////
template <class T, class Distance>
inline input_iterator_tag
iterator_category(const input_iterator<T, Distance>&) {
    return input_iterator_tag();
}

inline output_iterator_tag iterator_category(const output_iterator&) {
    return output_iterator_tag();
}

#pragma link off function iterator_category(const output_iterator&);


template <class T, class Distance>
inline forward_iterator_tag
iterator_category(const forward_iterator<T, Distance>&) {
    return forward_iterator_tag();
}

template <class T, class Distance>
inline bidirectional_iterator_tag
iterator_category(const bidirectional_iterator<T, Distance>&) {
    return bidirectional_iterator_tag();
}

template <class T, class Distance>
inline random_access_iterator_tag
iterator_category(const random_access_iterator<T, Distance>&) {
    return random_access_iterator_tag();
}

template <class T>
inline random_access_iterator_tag
iterator_category(const T*) {
    return random_access_iterator_tag();
}


// iterator_traits, iterator and reverse_iterator template may not be
// needed for precompiled library interface 

////////////////////////////////////////////////////////////////////////
// iterator_traits
////////////////////////////////////////////////////////////////////////

template <class Iterator>
struct iterator_traits {
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type value_type;
  typedef typename Iterator::difference_type difference_type;
  typedef typename Iterator::pointer pointer;
  typedef typename Iterator::reference reference;
};

// template partial specialization, implement in cint5.15.14 1587
template <class T>
struct iterator_traits<T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
};

// incomplete implementation in cint5.15.14 1587, need some fix
// iterator_traits<const int*> is changed as iterator_traits<const int* const>
// or something, but cint5.15.14 can not handle this well
template <class T>
struct iterator_traits<const T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef const T* pointer;
  typedef const T& reference;
};

////////////////////////////////////////////////////////////////////////
// iterator
////////////////////////////////////////////////////////////////////////
template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator {
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
  typedef Category iterator_category;
};


////////////////////////////////////////////////////////////////////////
// reverse_iterator
////////////////////////////////////////////////////////////////////////






template <class Iterator>
class reverse_iterator
# 166 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
{




 public:
# 181 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
   typedef Iterator::pointer pointer;
   typedef Iterator::reference reference;
   typedef ptrdiff_t difference_type;


   reverse_iterator();
   //reverse_iterator(Iterator x);



   Iterator base() const; // explicit
   reference operator*() const;
   pointer operator->() const;
   reverse_iterator& operator++();
   reverse_iterator operator++(int);
   reverse_iterator& operator--();
   reverse_iterator operator--(int);
   reverse_iterator operator+ (difference_type n) const;
   reverse_iterator& operator+=(difference_type n);
   reverse_iterator operator- (difference_type n) const;
   reverse_iterator& operator-=(difference_type n);
   reference operator[](difference_type n) const;
};
# 932 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
// for g++ 3.1,3.2
namespace __gnu_cxx
{
  // This iterator adapter is 'normal' in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                    difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparaison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  // _GLIBCPP_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
     const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
} // namespace __gnu_cxx







#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 2
# 29 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_functional" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <functional.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/functional" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/functional

#pragma ifndef PREC_STL_FUNCTIONAL
#pragma define PREC_STL_FUNCTIONAL
#pragma link off global PREC_STL_FUNCTIONAL;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab

// clause _lib.base_, base:
template <class Arg, class Result>
struct unary_function
{
  typedef Arg argument_type;
  typedef Result result_type;
};


template <class Arg1, class Arg2, class Result>
struct binary_function
{
  typedef Arg1 first_argument_type;
  typedef Arg2 second_argument_type;
  typedef Result result_type;
};


// clause _lib.arithmetic.operations_, arithmetic operations:
template <class T> struct plus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct minus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct multiplies : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};


template <class T> struct divides : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};

template <class T> struct modulus : binary_function<T,T,T> {
  T operator()(const T& x, const T& y) const;
};

template <class T> struct negate : unary_function<T,T> {
  T operator()(const T& x) const;
};


// clause _lib.comparisons_, comparisons:
template <class T> struct equal_to : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct not_equal_to : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct greater : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct less : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct greater_equal : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct less_equal : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};


// clause _lib.logical.operations_, logical operations:
template <class T> struct logical_and : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct logical_or : binary_function<T,T,bool> {
  bool operator()(const T& x, const T& y) const;
};

template <class T> struct logical_not : unary_function<T,bool> {
  bool operator()(const T& x) const;
};


// clause _lib.negators_, negators:
template <class Predicate>
class unary_negate
  : public unary_function<Predicate::argument_type, bool>
{
public:
  explicit unary_negate(const Predicate& pred);
  bool operator()(const argument_type& x) const;
};






template <class Predicate>
class binary_negate
  : public binary_function<Predicate::first_argument_type,
                           Predicate::second_argument_type, bool>
{
public:
  explicit binary_negate(const Predicate& pred);
  bool operator()(const first_argument_type& x,
                  const second_argument_type& y) const;
};

// operations omitted (cint can't handle template forward decls...)







// clause _lib.binders_, binders:
template <class Operation>
class binder1st
  : public unary_function<Operation::second_argument_type,
                          Operation::result_type>
{
protected:
  Operation op;
  Operation::first_argument_type value;
public:
  binder1st(const Operation& x, const Operation::first_argument_type& y);
  result_type operator()(const argument_type& x) const;
};


// operations omitted (cint can't handle template forward decls...)





template <class Operation>
class binder2nd
  : public unary_function<Operation::first_argument_type,
                          Operation::result_type>
{
protected:
  Operation op;
  Operation::second_argument_type value;
public:
  binder2nd(const Operation& x, const Operation::second_argument_type& y);
  result_type operator()(const argument_type& x) const;
};


// operations omitted (cint can't handle template forward decls...)






// clause _lib.function.pointer.adaptors_, adaptors:
template <class Arg, class Result>
class pointer_to_unary_function
  : public unary_function<Arg, Result>
{
public:
  explicit pointer_to_unary_function(Result (*f)(Arg));
  Result operator()(Arg x) const;
};

// operations omitted (cint can't handle template forward decls...)





template <class Arg1, class Arg2, class Result>
class pointer_to_binary_function
  : public binary_function<Arg1,Arg2,Result>
{
public:
  explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));
  Result operator()(Arg1 x, Arg2 y) const;
};

// operations omitted (cint can't handle template forward decls...)






// omit these for now.
# 230 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/functional"
#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_functional" 2
# 30 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap" 2

//////////////////////////////////////////////////////////////////////////

// This does not work yet. Don't know why.
template<class Key,class T,class Compare=std::less<Key>
        ,class Allocator=std::allocator<pair<const Key,T> > >
# 63 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap"
class multimap {
 public:
  typedef Key key_type;
  typedef T mapped_type;
  typedef pair<Key,T> value_type;
  //typedef pair<const Key,T>                         value_type;
  typedef Compare key_compare;
  typedef Allocator allocator_type;

  //typedef Key*                                     pointer;
  //typedef const Key*                               const_pointer;
  //typedef Key&                                     reference;
  //typedef const Key&                               const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
# 87 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap"
  class iterator
# 100 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap"
 {
   public:
    iterator() ;
    iterator(const iterator& x) ;

    iterator& operator=(const iterator& x) ;

    value_type& operator*() ;

    value_type* operator->() ;

    iterator& operator++();
    iterator operator++(int a);
    iterator& operator--();
    iterator operator--(int a);

    bool operator==(const iterator& x) ;
    bool operator!=(const iterator& x) ;




  };
# 131 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap"
  class reverse_iterator
# 144 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/multimap"
 {
   public:
    reverse_iterator(const reverse_iterator& x);

    reverse_iterator& operator=(const reverse_iterator& x) ;

    value_type& operator*() ;

    value_type* operator->() ;

    reverse_iterator& operator++();
    reverse_iterator operator++(int a);
    reverse_iterator& operator--();
    reverse_iterator operator--(int a);
   private:
  };

  friend bool operator==(const multimap::reverse_iterator& x
                        ,const multimap::reverse_iterator& y) const;
  friend bool operator!=(const multimap::reverse_iterator& x
                        ,const multimap::reverse_iterator& y) const;


  typedef const iterator const_iterator;
  typedef const reverse_iterator const_reverse_iterator;

  // _lib.multimap.cons_ construct/copy/destroy:
  multimap();






  multimap(iterator first, iterator last);
  multimap(reverse_iterator first, reverse_iterator last);

  multimap(const multimap& x);
  ~multimap();
  multimap& operator=(const multimap& x);
  // iterators:
  iterator begin();
  iterator end();
  reverse_iterator rbegin();
  reverse_iterator rend();






  // capacity:
  bool empty() const;
  size_type size() const;
  size_type max_size() const;
  // _lib.multimap.access_ element access:
  //T& operator[](const Key& x);
  // modifiers:
  iterator insert(const value_type& x);
  iterator insert(iterator position, const value_type& x);





  void insert(iterator first, iterator last);
  void insert(reverse_iterator first, reverse_iterator last);

  void erase(iterator position);
  size_type erase(const Key& x);
  void erase(iterator first, iterator last);
  void swap(multimap&);
  void clear();
  // observers:
  //key_compare   key_comp() const;
  //value_compare value_comp() const;
  // _lib.multimap.ops_ multimap operations:
  iterator find(const Key& x);
  //const_iterator find(const Key& x) const;
  size_type count(const Key& x) const;
  iterator lower_bound(const Key& x);
  //const_iterator lower_bound(const Key& x) const;
  iterator upper_bound(const Key& x);
  //const_iterator upper_bound(const Key& x) const;





  friend bool operator==(const multimap& x, const multimap& y);
  friend bool operator< (const multimap& x, const multimap& y);
  friend bool operator!=(const multimap& x, const multimap& y);
  friend bool operator> (const multimap& x, const multimap& y);
  friend bool operator>=(const multimap& x, const multimap& y);
  friend bool operator<=(const multimap& x, const multimap& y);
  // specialized algorithms:





#pragma ifndef G__NOALGORITHM
  // Generic algorithm
  friend multimap::iterator
    search(multimap::iterator first1,multimap::iterator last1,
           multimap::iterator first2,multimap::iterator last2);
#pragma endif


  // Generic algorithm
  //friend void reverse(multimap::iterator first,multimap::iterator last);
  //friend void reverse(multimap::reverse_iterator first,multimap::reverse_itetator last);

  // iterator_category resolution
  //friend bidirectional_iterator_tag iterator_category(multimap::iterator x);

};

//////////////////////////////////////////////////////////////////////////

#pragma endif
# 16 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_multimap" 2
# 26 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_map" 2
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/map" 2
}
# 26 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooMsgService.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCmdArg.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooCmdArg.h,v 1.10 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 27 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooMsgService.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooGlobalFunc.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooGlobalFunc.h,v 1.14 2007/07/16 21:04:28 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 28 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooMsgService.h" 2
class RooAbsArg ;
class RooWorkspace ;

// Shortcut definitions 
# 78 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooMsgService.h"
// Shortcuts definitions with conditional execution of print expression -- USE WITH CAUTION 
# 105 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooMsgService.h"
class RooMsgService : public TObject {
public:

  virtual ~RooMsgService() ;

  struct StreamConfig {
    public:

    void addTopic(RooFit::MsgTopic newTopic) {
      topic |= newTopic ;
    }

    void removeTopic(RooFit::MsgTopic oldTopic) {
      topic &= ~oldTopic ;
    }


    friend class RooMsgService ;

    Bool_t match(RooFit::MsgLevel level, RooFit::MsgTopic facility, const RooAbsArg* obj) ;
    Bool_t match(RooFit::MsgLevel level, RooFit::MsgTopic facility, const TObject* obj) ;

    Bool_t active ;
    Bool_t universal ;

    RooFit::MsgLevel minLevel ;
    Int_t topic ;
    std::string objectName ;
    std::string className ;
    std::string baseClassName ;
    std::string tagName ;
    Color_t color ;
    Bool_t prefix ;

    std::ostream* os ;

  } ;

  // Access to instance
  static RooMsgService& instance() ;
  static Bool_t anyDebug() ;

  // User interface -- Add or delete reporting streams ;
  Int_t addStream(RooFit::MsgLevel level, const RooCmdArg& arg1=RooCmdArg(), const RooCmdArg& arg2=RooCmdArg(), const RooCmdArg& arg3=RooCmdArg(),
                        const RooCmdArg& arg4=RooCmdArg(), const RooCmdArg& arg5=RooCmdArg(), const RooCmdArg& arg6=RooCmdArg());
  void deleteStream(Int_t id) ;
  StreamConfig& getStream(Int_t id) { return _streams[id] ; }

  Int_t numStreams() const { return _streams.size() ; }
  void setStreamStatus(Int_t id, Bool_t active) ;
  Bool_t getStreamStatus(Int_t id) const ;

  void reset() { cleanup() ; }

  void setGlobalKillBelow(RooFit::MsgLevel level) { _globMinLevel = level ; }
  RooFit::MsgLevel globalKillBelow() const { return _globMinLevel ; }

  void Print(Option_t *options= 0) const ;
  void showPid(Bool_t flag) { _showPid = flag ; }

  // Back end -- Send message or check if particular logging configuration is active
  std::ostream& log(const RooAbsArg* self, RooFit::MsgLevel level, RooFit::MsgTopic facility, Bool_t forceSkipPrefix=kFALSE) ;
  std::ostream& log(const TObject* self, RooFit::MsgLevel level, RooFit::MsgTopic facility, Bool_t forceSkipPrefix=kFALSE) ;
  Bool_t isActive(const RooAbsArg* self, RooFit::MsgTopic facility, RooFit::MsgLevel level) ;
  Bool_t isActive(const TObject* self, RooFit::MsgTopic facility, RooFit::MsgLevel level) ;

  static Int_t _debugCount ;
  std::map<int,std::string> _levelNames ;
  std::map<int,std::string> _topicNames ;

  static void cleanup() ;

  // Print level support for RooFit-related messages that are not routed through RooMsgService (such as Minuit printouts)
  Bool_t silentMode() const { return _silentMode ; }
  void setSilentMode(Bool_t flag) { _silentMode = flag ; }

  Int_t errorCount() const { return _errorCount ; }
  void clearErrorCount() { _errorCount = 0 ; }

  void saveState() ;
  void restoreState() ;

  RooWorkspace* debugWorkspace() ;

  Int_t& debugCode() { return _debugCode ; }

protected:

  Int_t activeStream(const RooAbsArg* self, RooFit::MsgTopic facility, RooFit::MsgLevel level) ;
  Int_t activeStream(const TObject* self, RooFit::MsgTopic facility, RooFit::MsgLevel level) ;

  std::vector<StreamConfig> _streams ;
  std::stack<std::vector<StreamConfig> > _streamsSaved ;
  std::ostream* _devnull ;

  std::map<std::string,std::ostream*> _files ;
  RooFit::MsgLevel _globMinLevel ;
  RooFit::MsgLevel _lastMsgLevel ;

  Bool_t _silentMode ;
  Bool_t _showPid ;

  Int_t _errorCount ;

  // Private ctor -- singleton class
  RooMsgService() ;
  RooMsgService(const RooMsgService&) ;

  static RooMsgService* _instance ;

  RooWorkspace* _debugWorkspace ;

  Int_t _debugCode ;

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 0; } static void Dictionary(); virtual TClass *IsA() const { return RooMsgService::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooMsgService::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooMsgService.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 219; } // RooFit Message Service Singleton class
};





extern RooMsgService* gMsgService ;
# 22 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCacheManager.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooNormSetCache.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooNormSetCache.h,v 1.12 2007/08/09 19:55:47 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 23 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCacheManager.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsReal.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooAbsReal.h,v 1.75 2007/07/13 21:50:24 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 24 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCacheManager.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooArgSet.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooArgSet.h,v 1.45 2007/08/09 19:55:47 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 25 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCacheManager.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooArgList.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooArgList.h,v 1.14 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 26 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCacheManager.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsCache.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooAbsCache.h 44982 2012-07-10 08:36:13Z moneta $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 27 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCacheManager.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsCacheElement.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooAbsCacheElement.h 24247 2008-06-12 14:54:32Z wouter $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 28 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCacheManager.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooNameReg.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooNameReg.h,v 1.3 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 29 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCacheManager.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/vector" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_vector" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <vector.dll>
#pragma include_noerr <vectorbool.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/vector

#pragma ifndef PREC_STL_VECTOR
#pragma define PREC_STL_VECTOR
#pragma link off global PREC_STL_VECTOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from ANSI/ISO C++ 1997/Nov draft 
// Got some ideas from Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <iterator.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/iterator

#pragma ifndef PREC_STL_ITERATOR
#pragma define PREC_STL_ITERATOR
#pragma link off global PREC_STL_ITERATOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from STL HP implementation 1994
// Imported from STL SGI implementation 1997 
// Imported from ANSI/ISO C++ draft Nov 1997
// Modified by Masaharu Goto
// May need improvement for the latest standard


////////////////////////////////////////////////////////////////////////
// iterator_tag
////////////////////////////////////////////////////////////////////////
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag {};
struct bidirectional_iterator_tag {};
struct random_access_iterator_tag {};

////////////////////////////////////////////////////////////////////////
// iterator template
////////////////////////////////////////////////////////////////////////
template <class T, class Distance> struct input_iterator {};
struct output_iterator {};
template <class T, class Distance> struct forward_iterator {};
template <class T, class Distance> struct bidirectional_iterator {};
template <class T, class Distance> struct random_access_iterator {};

#pragma link off class output_iterator;







////////////////////////////////////////////////////////////////////////
// iterator_category overloaded function
////////////////////////////////////////////////////////////////////////
template <class T, class Distance>
inline input_iterator_tag
iterator_category(const input_iterator<T, Distance>&) {
    return input_iterator_tag();
}

inline output_iterator_tag iterator_category(const output_iterator&) {
    return output_iterator_tag();
}

#pragma link off function iterator_category(const output_iterator&);


template <class T, class Distance>
inline forward_iterator_tag
iterator_category(const forward_iterator<T, Distance>&) {
    return forward_iterator_tag();
}

template <class T, class Distance>
inline bidirectional_iterator_tag
iterator_category(const bidirectional_iterator<T, Distance>&) {
    return bidirectional_iterator_tag();
}

template <class T, class Distance>
inline random_access_iterator_tag
iterator_category(const random_access_iterator<T, Distance>&) {
    return random_access_iterator_tag();
}

template <class T>
inline random_access_iterator_tag
iterator_category(const T*) {
    return random_access_iterator_tag();
}


// iterator_traits, iterator and reverse_iterator template may not be
// needed for precompiled library interface 

////////////////////////////////////////////////////////////////////////
// iterator_traits
////////////////////////////////////////////////////////////////////////

template <class Iterator>
struct iterator_traits {
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type value_type;
  typedef typename Iterator::difference_type difference_type;
  typedef typename Iterator::pointer pointer;
  typedef typename Iterator::reference reference;
};

// template partial specialization, implement in cint5.15.14 1587
template <class T>
struct iterator_traits<T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
};

// incomplete implementation in cint5.15.14 1587, need some fix
// iterator_traits<const int*> is changed as iterator_traits<const int* const>
// or something, but cint5.15.14 can not handle this well
template <class T>
struct iterator_traits<const T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef const T* pointer;
  typedef const T& reference;
};

////////////////////////////////////////////////////////////////////////
// iterator
////////////////////////////////////////////////////////////////////////
template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator {
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
  typedef Category iterator_category;
};


////////////////////////////////////////////////////////////////////////
// reverse_iterator
////////////////////////////////////////////////////////////////////////






template <class Iterator>
class reverse_iterator
# 166 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
{




 public:
# 181 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
   typedef Iterator::pointer pointer;
   typedef Iterator::reference reference;
   typedef ptrdiff_t difference_type;


   reverse_iterator();
   //reverse_iterator(Iterator x);



   Iterator base() const; // explicit
   reference operator*() const;
   pointer operator->() const;
   reverse_iterator& operator++();
   reverse_iterator operator++(int);
   reverse_iterator& operator--();
   reverse_iterator operator--(int);
   reverse_iterator operator+ (difference_type n) const;
   reverse_iterator& operator+=(difference_type n);
   reverse_iterator operator- (difference_type n) const;
   reverse_iterator& operator-=(difference_type n);
   reference operator[](difference_type n) const;
};
# 932 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
// for g++ 3.1,3.2
namespace __gnu_cxx
{
  // This iterator adapter is 'normal' in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                    difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparaison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  // _GLIBCPP_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
     const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
} // namespace __gnu_cxx







#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 2
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <memory.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/memory

#pragma ifndef PREC_STL_MEMORY
#pragma define PREC_STL_MEMORY
#pragma link off global PREC_STL_MEMORY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////


template <class _Tp>
class allocator {
  //typedef alloc _Alloc;          // The underlying allocator.
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  typedef typename _Tp* pointer;
  typedef const typename _Tp * const_pointer;




  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() ;
  allocator(const allocator&) ;
  //template <class _Tp1> allocator(const allocator<_Tp1>&) ;
  ~allocator() ;

  pointer address(reference __x) const ;
  const_pointer address(const_reference __x) const ;

  // __n is permitted to be 0.  The C++ standard says nothing about what
  // the return value is when __n == 0.
  _Tp* allocate(size_type __n, const void* = 0) ;

  // __p is not permitted to be a null pointer.
  void deallocate(pointer __p, size_type __n);

  size_type max_size() const ;

  void construct(pointer __p, const _Tp& __val) ;
  void destroy(pointer __p) ;
};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;
  typedef void value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };
};
//////////////////////////////////////////////////////////////////////
# 205 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////

/**********************************************************************
* auto_ptr
**********************************************************************/
template <class X> class auto_ptr {
private:
  X* ptr;
  //template<class Y> struct auto_ptr_ref { };
public:
  typedef X element_type;
  explicit auto_ptr(X* p = 0) : ptr(p) {}
  auto_ptr(auto_ptr& a) {ptr=a.ptr;}

  // this implementation may not be correct
  template <class T> auto_ptr(auto_ptr<T>& a) {ptr=a.release();}
# 229 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  auto_ptr& operator=(auto_ptr& a) {
    if (a.ptr != ptr) {
      delete ptr;
      ptr = a.ptr;
    }
    return(*this);
  }

  // this implementation may not be correct
  template <class T> auto_ptr& operator=(auto_ptr<T>& a) {
    if (a.ptr != ptr) {
       delete ptr;
       ptr = a.release();
    }
    return(*this);
  }

  ~auto_ptr() { delete ptr; }

  X& operator*() const { return *ptr; }
  X* operator->() const { return ptr; }
  X* get() const { return ptr; }
  X* release() { X *old = ptr; ptr = 0; return 0; }
# 262 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  // auto_ptr conversions
  //auto_ptr(auto_ptr_ref<X>& x) { }
  //template<class Y> operator auto_ptr_ref<Y>() { return auto_ptr_ref<Y>(); }
  //template<class Y> operator auto_ptr<Y>() { return auto_ptr<T>(); }
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 2
# 28 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <utility.dll>


#pragma include_noerr <pair.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/utility" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/utility

#pragma ifndef PREC_STL_UTILITY
#pragma define PREC_STL_UTILITY
#pragma link off global PREC_STL_UTILITY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

template <class T1, class T2>
struct pair {
  T1 first;
  T2 second;
  pair() : first(T1()), second(T2()) {}
  pair(const T1& a, const T2& b) : first(a), second(b) {}
 private:
  pair& operator=(const pair& x){first=x.first;second=x.second;return *this;}
};

#pragma endif
# 17 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_utility" 2
# 29 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector" 2
# 37 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
template<class T,class Allocator=std::allocator<T> >
# 49 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
class vector {
 public:
  typedef T value_type;


  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
# 218 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
  class iterator {
   public:
     typedef vector::pointer pointer;
     typedef vector::const_pointer const_pointer;
     typedef vector::reference reference;
     typedef vector::const_reference const_reference;
     typedef vector::size_type size_type;
     typedef vector::difference_type difference_type;

      iterator();
      explicit iterator(const pointer& __i) ;
      // Allow iterator to const_iterator conversion
      template<typename _Iter> inline iterator(const iterator& __i);

      // Forward iterator requirements
      reference operator*() const ;
      pointer operator->() const ;
      iterator& operator++();
      iterator operator++(int) ;

      // Bidirectional iterator requirements
      iterator& operator--() ;
      iterator operator--(int) ;

      // Random access iterator requirements
      reference operator[](const difference_type& __n) const;
      iterator& operator+=(const difference_type& __n);
      iterator operator+(const difference_type& __n) const;
      iterator& operator-=(const difference_type& __n);
      iterator operator-(const difference_type& __n) const;
      const pointer& base() const ;

      iterator operator=(const iterator& x) ;

  };

  friend bool operator==(const vector::iterator& x,const vector::iterator& y)const;
  friend bool operator!=(const vector::iterator& x,const vector::iterator& y)const;
  friend bool operator<(const vector::iterator& x,const vector::iterator& y)const;
  friend bool operator>(const vector::iterator& x,const vector::iterator& y)const;
  friend bool operator<=(const vector::iterator& x,const vector::iterator& y)const;
  friend bool operator>=(const vector::iterator& x,const vector::iterator& y)const;
  friend vector::iterator::difference_type operator-(const vector::iterator& x,const vector::iterator& y)const;
  friend vector::iterator operator+(const vector::iterator::difference_type x,const vector::iterator& y)const;

  typedef const iterator const_iterator;
# 355 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
  typedef reverse_iterator<const_iterator> const_reverse_iterator;
  typedef reverse_iterator<iterator> reverse_iterator;
# 398 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
  friend bool operator==(const vector::reverse_iterator& x
                        ,const vector::reverse_iterator& y) const;
  friend bool operator!=(const vector::reverse_iterator& x
                        ,const vector::reverse_iterator& y) const;






  friend bool operator==(vector::const_iterator& x
                        ,vector::const_iterator& y) const;
  friend bool operator!=(vector::const_iterator& x
                        ,vector::const_iterator& y) const;
# 422 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
  reference at(size_type n);
  const_reference at(size_type n) const;

  iterator begin(void) ;
  iterator end(void) ;
  reverse_iterator rbegin(void) ;
  reverse_iterator rend(void) ;






  size_type size(void) const ;
  size_type max_size(void) const ;
  void resize(size_type sz) ;
  void resize(size_type sz, T c) ;
  size_type capacity(void) const ;
  bool empty(void) const ;
  reference operator[](size_type n) ;
  const_reference operator[](size_type n) const;
  vector(void) ;
  vector(size_type n,const T& value=T()) ;
  vector(const vector& x) ;
  vector(const_iterator first,const_iterator last) ;
  ~vector(void) ;
  vector& operator=(const vector& x);
  void reserve(size_type n) ;
  T& front(void) ;
  T& back(void) ;
  void push_back(const T& x) ;
  void swap(vector& x);
  iterator insert(iterator position,const T& x);
  void insert(iterator position,const_iterator first,const_iterator last);
  void insert(iterator position,size_type n,const T& x);
  void pop_back(void) ;
  void erase(iterator position) ;
  void erase(iterator first,iterator last) ;
  void clear() ;


  friend bool operator==(const vector& x, const vector& y);
  friend bool operator< (const vector& x, const vector& y);
  friend bool operator!=(const vector& x, const vector& y);
  friend bool operator> (const vector& x, const vector& y);
  friend bool operator>=(const vector& x, const vector& y);
  friend bool operator<=(const vector& x, const vector& y);



  // specialized algorithms:






#pragma ifndef G__NOALGORITHM

  // Generic algorithm


  // input iter
  friend vector::iterator
    find(vector::iterator first,vector::iterator last,const T& value);
  // forward iter
  friend vector::iterator
    find_end(vector::iterator first1,vector::iterator last1,
      vector::iterator first2,vector::iterator last2);
  friend vector::iterator
    find_first_of(vector::iterator first1,vector::iterator last1,
           vector::iterator first2,vector::iterator last2);
  friend vector::iterator
    adjacent_find(vector::iterator first,vector::iterator last);
  // input iter

  friend vector::difference_type
    count(vector::iterator first,vector::iterator last,const T& value);






  friend bool
    equal(vector::iterator first1,vector::iterator last1,
          vector::iterator first2);
  // forward iter
  friend vector::iterator
    search(vector::iterator first1,vector::iterator last1,
           vector::iterator first2,vector::iterator last2);
  friend vector::iterator
    search_n(vector::iterator first,vector::iterator last
             ,vector::size_type count,const T& value);
  // input and output iter -> forward iter
  friend vector::iterator
    copy(vector::iterator first,vector::iterator last,
         vector::iterator result);
  // bidirectional iter
  friend vector::iterator
    copy_backward(vector::iterator first,vector::iterator last,
                  vector::iterator result);
  // just value_type
  friend void swap(T& a,T& b);
  // forward iter
  friend vector::iterator
    swap_ranges(vector::iterator first1,vector::iterator last1,
                vector::iterator first2);
  friend void iter_swap(vector::iterator a,vector::iterator b);
  friend void replace(vector::iterator first,vector::iterator last,
                      const T& old_value,const T& new_value);
  // input, output iter -> forward iter
  friend vector::iterator
    replace_copy(vector::iterator first,vector::iterator last,
                 vector::iterator result,
                 const T& old_value,const T& new_value);
  // forward iter
  friend void
    fill(vector::iterator first,vector::iterator last,const T& value);

  friend void
    fill_n(vector::iterator first,vector::size_type n,const T& value);

  friend vector::iterator
    remove(vector::iterator first,vector::iterator last,const T& value);
  // input,output iter -> forward iter
  friend vector::iterator
    remove_copy(vector::iterator first,vector::iterator last,
                vector::iterator result,const T& value);
  friend vector::iterator
    unique(vector::iterator first,vector::iterator last);
  friend vector::iterator
    unique_copy(vector::iterator first,vector::iterator last,
                vector::iterator result);
  friend void reverse(vector::iterator first,vector::iterator last);
  friend vector::iterator
     reverse_copy(vector::iterator first,vector::iterator last,
                  vector::iterator result);
  // forward iter

  friend void rotate(vector::iterator first,vector::iterator mid,
                     vector::iterator last);

  // forward iter
  friend vector::iterator
    rotate_copy(vector::iterator first,vector::iterator mid,
                vector::iterator last,vector::iterator result);
  // randomaccess iter
  friend void random_shuffle(vector::iterator first,vector::iterator last);
  // randomaccess iter
  friend void sort(vector::iterator first,vector::iterator last);
  friend void stable_sort(vector::iterator first,vector::iterator last);
  friend void partial_sort(vector::iterator first,vector::iterator mid,
                           vector::iterator last);
  friend vector::iterator
    partial_sort_copy(vector::iterator first,vector::iterator last,
                      vector::iterator result_first,
                      vector::iterator result_last);
  friend void nth_element(vector::iterator first,vector::iterator nth,
                          vector::iterator last);
  // forward iter
  friend vector::iterator
    lower_bound(vector::iterator first,vector::iterator last,const T& value);
  friend vector::iterator
    upper_bound(vector::iterator first,vector::iterator last,const T& value);




  friend bool binary_search(vector::iterator first,vector::iterator last,
                            const T& value);
  friend vector::iterator merge(vector::iterator first1,vector::iterator last1,
                                vector::iterator first2,vector::iterator last2,
                                vector::iterator result);
  friend void inplace_merge(vector::iterator first,vector::iterator middle,
                            vector::iterator last);
  friend bool includes(vector::iterator first1,vector::iterator last1,
                       vector::iterator first2,vector::iterator last2);
  friend vector::iterator
    set_union(vector::iterator first1,vector::iterator last1,
              vector::iterator first2,vector::iterator last2,
              vector::iterator result);
  friend vector::iterator
    set_intersection(vector::iterator first1,vector::iterator last1,
                     vector::iterator first2,vector::iterator last2,
                     vector::iterator result);
  friend vector::iterator
    set_difference(vector::iterator first1,vector::iterator last1,
                   vector::iterator first2,vector::iterator last2,
                   vector::iterator result);
  friend vector::iterator
    set_symmetric_difference(vector::iterator first1,vector::iterator last1,
                             vector::iterator first2,vector::iterator last2,
                             vector::iterator result);
  // random access
  friend void push_heap(vector::iterator first,vector::iterator last);
  friend void pop_heap(vector::iterator first,vector::iterator last);
  friend void make_heap(vector::iterator first,vector::iterator last);
  friend void sort_heap(vector::iterator first,vector::iterator last);
  // min,max, just value_type
  friend const T& min(const T& a,const T& b);
  friend const T& max(const T& a,const T& b);
  // forward iter
  friend vector::iterator
    min_element(vector::iterator first,vector::iterator last);
  friend vector::iterator
    max_element(vector::iterator first,vector::iterator last);
  // input iter
  friend bool
    lexicographical_compare(vector::iterator first1,vector::iterator last1,
                            vector::iterator first2,vector::iterator last2);
  // bidirectional iter
  friend bool next_permutation(vector::iterator first,vector::iterator last);
  friend bool prev_permutation(vector::iterator first,vector::iterator last);
# 662 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
#pragma endif

  // iterator_category resolution
  //friend random_access_iterator_tag iterator_category(vector::iterator x);

};
# 837 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/vector"
#pragma endif
# 15 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_vector" 2
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/vector" 2
}
# 30 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCacheManager.h" 2

class RooNameSet ;


template<class T>
class RooCacheManager : public RooAbsCache {

public:

  RooCacheManager(Int_t maxSize=10) ;
  RooCacheManager(RooAbsArg* owner, Int_t maxSize=10) ;
  RooCacheManager(const RooCacheManager& other, RooAbsArg* owner=0) ;
  virtual ~RooCacheManager() ;

  T* getObj(const RooArgSet* nset, Int_t* sterileIndex=0, const TNamed* isetRangeName=0) {
    // Getter function without integration set 
    return getObj(nset,0,sterileIndex,isetRangeName) ;
  }

  Int_t setObj(const RooArgSet* nset, T* obj, const TNamed* isetRangeName=0) {
    // Setter function without integration set 
    return setObj(nset,0,obj,isetRangeName) ;
  }

  inline T* getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx, const char* isetRangeName) {
    if (_wired) return _object[0] ;
    return getObj(nset,iset,sterileIdx,RooNameReg::ptr(isetRangeName)) ;
  }

  T* getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIndex=0, const TNamed* isetRangeName=0) ;
  Int_t setObj(const RooArgSet* nset, const RooArgSet* iset, T* obj, const TNamed* isetRangeName=0) ;

  void reset() ;
  virtual void sterilize() ;

  Int_t lastIndex() const {
    // Return index of slot used in last get or set operation
    return _lastIndex ;
  }
  Int_t cacheSize() const {
    // Return size of cache
    return _size ;
  }

  virtual Bool_t redirectServersHook(const RooAbsCollection& /*newServerList*/, Bool_t /*mustReplaceAll*/,
         Bool_t /*nameChange*/, Bool_t /*isRecursive*/) {
    // Interface function to intercept server redirects
    return kFALSE ;
  }
  virtual void operModeHook() {
    // Interface function to intercept cache operation mode changes
  }
  virtual void printCompactTreeHook(std::ostream&, const char *) {
    // Interface function to cache add contents to output in tree printing mode
  }

  T* getObjByIndex(Int_t index) const ;
  const RooNameSet* nameSet1ByIndex(Int_t index) const ;
  const RooNameSet* nameSet2ByIndex(Int_t index) const ;

  virtual void insertObjectHook(T&) {
    // Interface function to perform post-insert operations on cached object
  }

  void wireCache() {
    if (_size==0) {
      RooMsgService::instance().log(_owner,RooFit::INFO,RooFit::Optimization) << "RooCacheManager::wireCache(" << _owner->GetName() << ") no cached elements!" << std::endl ;
    } else if (_size==1) {
      RooMsgService::instance().log(_owner,RooFit::INFO,RooFit::Optimization) << "RooCacheManager::wireCache(" << _owner->GetName() << ") now wiring cache" << std::endl ;
      _wired=kTRUE ;
    } else if (_size>1) {
      RooMsgService::instance().log(_owner,RooFit::INFO,RooFit::Optimization) << "RooCacheManager::wireCache(" << _owner->GetName() << ") cache cannot be wired because it contains more than one element" << std::endl ;
    }
  }

protected:

  Int_t _maxSize ; // Maximum size
  Int_t _size ; // Actual use
  Int_t _lastIndex ; // Last slot accessed

  std::vector<RooNormSetCache> _nsetCache ; //! Normalization/Integration set manager
  std::vector<T*> _object ; //! Payload
  Bool_t _wired ; //! In wired mode, there is a single payload which is returned always

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return RooCacheManager::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooCacheManager::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCacheManager.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 115; } // Cache Manager class generic objects
} ;


template<class T>
RooCacheManager<T>::RooCacheManager(Int_t maxSize) : RooAbsCache(0)
{
  // Constructor for simple caches without RooAbsArg payload. A cache
  // made with this constructor is not registered with its owner
  // and will not receive information on server redirects and
  // cache operation mode changes

  _maxSize = maxSize ;
  _nsetCache.resize(_maxSize) ; // = new RooNormSetCache[maxSize] ;
  _object.resize(_maxSize,0) ; // = new T*[maxSize] ;
  _wired = kFALSE ;
}

template<class T>
RooCacheManager<T>::RooCacheManager(RooAbsArg* owner, Int_t maxSize) : RooAbsCache(owner)
{
  // Constructor for simple caches with RooAbsArg derived payload. A cache
  // made with this constructor is registered with its owner
  // and will receive information on server redirects and
  // cache operation mode changes

  _maxSize = maxSize ;
  _size = 0 ;

  _nsetCache.resize(_maxSize) ; // = new RooNormSetCache[maxSize] ;
  _object.resize(_maxSize,0) ; // = new T*[maxSize] ;
  _wired = kFALSE ;
  _lastIndex = -1 ;

  Int_t i ;
  for (i=0 ; i<_maxSize ; i++) {
    _object[i]=0 ;
  }

}


template<class T>
RooCacheManager<T>::RooCacheManager(const RooCacheManager& other, RooAbsArg* owner) : RooAbsCache(other,owner)
{
  // Copy constructor

  _maxSize = other._maxSize ;
  _size = other._size ;

  _nsetCache.resize(_maxSize) ; // = new RooNormSetCache[_maxSize] ;
  _object.resize(_maxSize,0) ; // = new T*[_maxSize] ;
  _wired = kFALSE ;
  _lastIndex = -1 ;

//   std::cout << "RooCacheManager:cctor(" << this << ")" << std::endl ;

  Int_t i ;
  for (i=0 ; i<other._size ; i++) {
    _nsetCache[i].initialize(other._nsetCache[i]) ;
    _object[i] = 0 ;
  }

  for (i=other._size ; i<_maxSize ; i++) {
    _object[i] = 0 ;
  }
}


template<class T>
RooCacheManager<T>::~RooCacheManager()
{
  // Destructor

  //delete[] _nsetCache ;  
  Int_t i ;
  for (i=0 ; i<_size ; i++) {
    delete _object[i] ;
  }
  //delete[] _object ;
}


template<class T>
void RooCacheManager<T>::reset()
{
  // Clear the cache

  Int_t i ;
  for (i=0 ; i<_maxSize ; i++) {
    delete _object[i] ;
    _object[i]=0 ;
    _nsetCache[i].clear() ;
  }
  _lastIndex = -1 ;
  _size = 0 ;
}



template<class T>
void RooCacheManager<T>::sterilize()
{
  // Clear the cache payload but retain slot mapping w.r.t to
  // normalization and integration sets.

  Int_t i ;
  for (i=0 ; i<_maxSize ; i++) {
    delete _object[i] ;
    _object[i]=0 ;
  }
}



template<class T>
Int_t RooCacheManager<T>::setObj(const RooArgSet* nset, const RooArgSet* iset, T* obj, const TNamed* isetRangeName)
{
  // Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName

  // Check if object is already registered
  Int_t sterileIdx(-1) ;
  if (getObj(nset,iset,&sterileIdx,isetRangeName)) {
    return lastIndex() ;
  }


  if (sterileIdx>=0) {
    // Found sterile slot that can should be recycled [ sterileIndex only set if isetRangeName matches ]
    _object[sterileIdx] = obj ;

    // Allow optional post-processing of object inserted in cache
    insertObjectHook(*obj) ;

    return lastIndex() ;
  }

  if (_size==_maxSize) {
    _maxSize *=2 ;
    _object.resize(_maxSize,0) ;
    _nsetCache.resize(_maxSize) ;
  }

  _nsetCache[_size].autoCache(_owner,nset,iset,isetRangeName,kTRUE) ;
  if (_object[_size]) {
    delete _object[_size] ;
  }

  _object[_size] = obj ;
  _size++ ;

  // Allow optional post-processing of object inserted in cache
  insertObjectHook(*obj) ;

  // Unwire cache in case it was wired
  _wired = kFALSE ;

  return _size-1 ;
}



template<class T>
T* RooCacheManager<T>::getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx, const TNamed* isetRangeName)
{
  // Retrieve payload object indexed on nset,uset amd isetRangeName
  // If sterileIdx is not null, it is set to the index of the sterile
  // slot in cacse such a slot is recycled

  // Fast-track for wired mode
  if (_wired) {
    if(_object[0]==0 && sterileIdx) *sterileIdx=0 ;
    return _object[0] ;
  }

  Int_t i ;
  for (i=0 ; i<_size ; i++) {
    if (_nsetCache[i].contains(nset,iset,isetRangeName)==kTRUE) {
      _lastIndex = i ;
      if(_object[i]==0 && sterileIdx) *sterileIdx=i ;
      return _object[i] ;
    }
  }

  for (i=0 ; i<_size ; i++) {
    if (_nsetCache[i].autoCache(_owner,nset,iset,isetRangeName,kFALSE)==kFALSE) {
      _lastIndex = i ;
      if(_object[i]==0 && sterileIdx) *sterileIdx=i ;
      return _object[i] ;
    }
  }

  return 0 ;
}



template<class T>
T* RooCacheManager<T>::getObjByIndex(Int_t index) const
{
  // Retrieve payload object by slot index

  if (index<0||index>=_size) {
    RooMsgService::instance().log(_owner,RooFit::ERROR,RooFit::ObjectHandling) << "RooCacheManager::getNormListByIndex: ERROR index ("
       << index << ") out of range [0," << _size-1 << "]" << std::endl ;
    return 0 ;
  }
  return _object[index] ;
}

template<class T>
const RooNameSet* RooCacheManager<T>::nameSet1ByIndex(Int_t index) const
{
  // Retrieve RooNameSet associated with slot at given index

  if (index<0||index>=_size) {
    RooMsgService::instance().log(_owner,RooFit::ERROR,RooFit::ObjectHandling) << "RooCacheManager::getNormListByIndex: ERROR index ("
       << index << ") out of range [0," << _size-1 << "]" << std::endl ;
    return 0 ;
  }
  return &_nsetCache[index].nameSet1() ;
}

template<class T>
const RooNameSet* RooCacheManager<T>::nameSet2ByIndex(Int_t index) const
{
  // Retrieve RooNameSet associated with slot at given index

  if (index<0||index>=_size) {
    RooMsgService::instance().log(_owner,RooFit::ERROR,RooFit::ObjectHandling) << "RooCacheManager::getNormListByIndex: ERROR index ("
       << index << ") out of range [0," << _size-1 << "]" << std::endl ;
    return 0 ;
  }
  return &_nsetCache[index].nameSet2() ;
}
# 28 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooObjCacheManager.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/list" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_list" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <list.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/list

#pragma ifndef PREC_STL_LIST
#pragma define PREC_STL_LIST
#pragma link off global PREC_STL_LIST;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from ANSI/ISO C++ 1997/Nov draft 
// Got some ideas from Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <iterator.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/iterator

#pragma ifndef PREC_STL_ITERATOR
#pragma define PREC_STL_ITERATOR
#pragma link off global PREC_STL_ITERATOR;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;



#pragma mask_newdelete 0x10;


// Imported from STL HP implementation 1994
// Imported from STL SGI implementation 1997 
// Imported from ANSI/ISO C++ draft Nov 1997
// Modified by Masaharu Goto
// May need improvement for the latest standard


////////////////////////////////////////////////////////////////////////
// iterator_tag
////////////////////////////////////////////////////////////////////////
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag {};
struct bidirectional_iterator_tag {};
struct random_access_iterator_tag {};

////////////////////////////////////////////////////////////////////////
// iterator template
////////////////////////////////////////////////////////////////////////
template <class T, class Distance> struct input_iterator {};
struct output_iterator {};
template <class T, class Distance> struct forward_iterator {};
template <class T, class Distance> struct bidirectional_iterator {};
template <class T, class Distance> struct random_access_iterator {};

#pragma link off class output_iterator;







////////////////////////////////////////////////////////////////////////
// iterator_category overloaded function
////////////////////////////////////////////////////////////////////////
template <class T, class Distance>
inline input_iterator_tag
iterator_category(const input_iterator<T, Distance>&) {
    return input_iterator_tag();
}

inline output_iterator_tag iterator_category(const output_iterator&) {
    return output_iterator_tag();
}

#pragma link off function iterator_category(const output_iterator&);


template <class T, class Distance>
inline forward_iterator_tag
iterator_category(const forward_iterator<T, Distance>&) {
    return forward_iterator_tag();
}

template <class T, class Distance>
inline bidirectional_iterator_tag
iterator_category(const bidirectional_iterator<T, Distance>&) {
    return bidirectional_iterator_tag();
}

template <class T, class Distance>
inline random_access_iterator_tag
iterator_category(const random_access_iterator<T, Distance>&) {
    return random_access_iterator_tag();
}

template <class T>
inline random_access_iterator_tag
iterator_category(const T*) {
    return random_access_iterator_tag();
}


// iterator_traits, iterator and reverse_iterator template may not be
// needed for precompiled library interface 

////////////////////////////////////////////////////////////////////////
// iterator_traits
////////////////////////////////////////////////////////////////////////

template <class Iterator>
struct iterator_traits {
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::value_type value_type;
  typedef typename Iterator::difference_type difference_type;
  typedef typename Iterator::pointer pointer;
  typedef typename Iterator::reference reference;
};

// template partial specialization, implement in cint5.15.14 1587
template <class T>
struct iterator_traits<T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T& reference;
};

// incomplete implementation in cint5.15.14 1587, need some fix
// iterator_traits<const int*> is changed as iterator_traits<const int* const>
// or something, but cint5.15.14 can not handle this well
template <class T>
struct iterator_traits<const T*> {
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  typedef ptrdiff_t difference_type;
  typedef const T* pointer;
  typedef const T& reference;
};

////////////////////////////////////////////////////////////////////////
// iterator
////////////////////////////////////////////////////////////////////////
template<class Category, class T, class Distance = ptrdiff_t,
         class Pointer = T*, class Reference = T&>
struct iterator {
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
  typedef Category iterator_category;
};


////////////////////////////////////////////////////////////////////////
// reverse_iterator
////////////////////////////////////////////////////////////////////////






template <class Iterator>
class reverse_iterator
# 166 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
{




 public:
# 181 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
   typedef Iterator::pointer pointer;
   typedef Iterator::reference reference;
   typedef ptrdiff_t difference_type;


   reverse_iterator();
   //reverse_iterator(Iterator x);



   Iterator base() const; // explicit
   reference operator*() const;
   pointer operator->() const;
   reverse_iterator& operator++();
   reverse_iterator operator++(int);
   reverse_iterator& operator--();
   reverse_iterator operator--(int);
   reverse_iterator operator+ (difference_type n) const;
   reverse_iterator& operator+=(difference_type n);
   reverse_iterator operator- (difference_type n) const;
   reverse_iterator& operator-=(difference_type n);
   reference operator[](difference_type n) const;
};
# 932 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/iterator"
// for g++ 3.1,3.2
namespace __gnu_cxx
{
  // This iterator adapter is 'normal' in the sense that it does not
  // change the semantics of any of the operators of its iterator
  // parameter.  Its primary purpose is to convert an iterator that is
  // not a class, e.g. a pointer, into an iterator that is a class.
  // The _Container parameter exists solely so that different containers
  // using this template can instantiate different types, even if the
  // _Iterator parameter is the same.
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
      : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                        typename iterator_traits<_Iterator>::value_type,
                        typename iterator_traits<_Iterator>::difference_type,
                        typename iterator_traits<_Iterator>::pointer,
                        typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator _M_current;

    public:
      typedef typename iterator_traits<_Iterator>::difference_type
                    difference_type;
      typedef typename iterator_traits<_Iterator>::reference reference;
      typedef typename iterator_traits<_Iterator>::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
      inline __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const { return *_M_current; }

      pointer
      operator->() const { return _M_current; }

      __normal_iterator&
      operator++() { ++_M_current; return *this; }

      __normal_iterator
      operator++(int) { return __normal_iterator(_M_current++); }

      // Bidirectional iterator requirements
      __normal_iterator&
      operator--() { --_M_current; return *this; }

      __normal_iterator
      operator--(int) { return __normal_iterator(_M_current--); }

      // Random access iterator requirements
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const { return _M_current; }
    };

  // Note: In what follows, the left- and right-hand-side iterators are
  // allowed to vary in types (conceptually in cv-qualification) so that
  // comparaison between cv-qualified and non-cv-qualified iterators be
  // valid.  However, the greedy and unfriendly operators in std::rel_ops
  // will make overload resolution ambiguous (when in scope) if we don't
  // provide overloads whose operands are of the same type.  Can someone
  // remind me what generic programming is about? -- Gaby

  // Forward iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() != __rhs.base(); }

  // Random access iterator requirements
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
             const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
     const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
     const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline bool
  operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
      const __normal_iterator<_Iterator, _Container>& __rhs)
  { return __lhs.base() >= __rhs.base(); }

  // _GLIBCPP_RESOLVE_LIB_DEFECTS
  // According to the resolution of DR179 not only the various comparison
  // operators but also operator- must accept mixed iterator/const_iterator
  // parameters.
  template<typename _IteratorL, typename _IteratorR, typename _Container>
  inline typename __normal_iterator<_IteratorL, _Container>::difference_type
  operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
      const __normal_iterator<_IteratorR, _Container>& __rhs)
  { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
  inline __normal_iterator<_Iterator, _Container>
  operator+(typename __normal_iterator<_Iterator, _Container>::difference_type __n,
     const __normal_iterator<_Iterator, _Container>& __i)
  { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
} // namespace __gnu_cxx







#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_iterator" 2
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <memory.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/memory

#pragma ifndef PREC_STL_MEMORY
#pragma define PREC_STL_MEMORY
#pragma link off global PREC_STL_MEMORY;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// Implemented by Scott Snyder, Fermi-lab
// Modified by Masaharu Goto
// SGI KCC porting by Philippe Canal, Fermi-lab
# 27 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////


template <class _Tp>
class allocator {
  //typedef alloc _Alloc;          // The underlying allocator.
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

  typedef typename _Tp* pointer;
  typedef const typename _Tp * const_pointer;




  typedef _Tp& reference;
  typedef const _Tp& const_reference;
  typedef _Tp value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };

  allocator() ;
  allocator(const allocator&) ;
  //template <class _Tp1> allocator(const allocator<_Tp1>&) ;
  ~allocator() ;

  pointer address(reference __x) const ;
  const_pointer address(const_reference __x) const ;

  // __n is permitted to be 0.  The C++ standard says nothing about what
  // the return value is when __n == 0.
  _Tp* allocate(size_type __n, const void* = 0) ;

  // __p is not permitted to be a null pointer.
  void deallocate(pointer __p, size_type __n);

  size_type max_size() const ;

  void construct(pointer __p, const _Tp& __val) ;
  void destroy(pointer __p) ;
};

template<>
class allocator<void> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef void* pointer;
  typedef const void* const_pointer;
  typedef void value_type;

  template <class _Tp1> struct rebind {
    typedef allocator<_Tp1> other;
  };
};
//////////////////////////////////////////////////////////////////////
# 205 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
//////////////////////////////////////////////////////////////////////

/**********************************************************************
* auto_ptr
**********************************************************************/
template <class X> class auto_ptr {
private:
  X* ptr;
  //template<class Y> struct auto_ptr_ref { };
public:
  typedef X element_type;
  explicit auto_ptr(X* p = 0) : ptr(p) {}
  auto_ptr(auto_ptr& a) {ptr=a.ptr;}

  // this implementation may not be correct
  template <class T> auto_ptr(auto_ptr<T>& a) {ptr=a.release();}
# 229 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  auto_ptr& operator=(auto_ptr& a) {
    if (a.ptr != ptr) {
      delete ptr;
      ptr = a.ptr;
    }
    return(*this);
  }

  // this implementation may not be correct
  template <class T> auto_ptr& operator=(auto_ptr<T>& a) {
    if (a.ptr != ptr) {
       delete ptr;
       ptr = a.release();
    }
    return(*this);
  }

  ~auto_ptr() { delete ptr; }

  X& operator*() const { return *ptr; }
  X* operator->() const { return ptr; }
  X* get() const { return ptr; }
  X* release() { X *old = ptr; ptr = 0; return 0; }
# 262 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/memory"
  // auto_ptr conversions
  //auto_ptr(auto_ptr_ref<X>& x) { }
  //template<class Y> operator auto_ptr_ref<Y>() { return auto_ptr_ref<Y>(); }
  //template<class Y> operator auto_ptr<Y>() { return auto_ptr<T>(); }
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_memory" 2
# 28 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list" 2


template<class T,class Allocator=std::allocator<T> >
# 44 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
class list {
 public:
  typedef T value_type;
  typedef Allocator allocator_type;

  typedef void* void_pointer;
  //typedef __list_node<T> list_node;
  //typedef simple_alloc<list_node, Alloc> list_node_allocator;
  //typedef list_node* link_type;
  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
# 68 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
  class iterator
# 84 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
 {
   public:
    iterator() ;
    iterator(const iterator& x) ;

    iterator& operator=(const iterator& x) ;

    T& operator*() const ;

    T* operator->() const ;

    iterator& operator++();
    iterator operator++(int a);
    iterator& operator--();
    iterator operator--(int a);
    bool operator==(const iterator& x) ;

    bool operator!=(const iterator& x) ;





  };







  class reverse_iterator
# 131 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
 {
   public:
    reverse_iterator(const reverse_iterator& x) ;

    reverse_iterator& operator=(const reverse_iterator& x) ;

    T& operator*() const ;

    T* operator->() const ;

    reverse_iterator& operator++();
    reverse_iterator operator++(int a);
    reverse_iterator& operator--();
    reverse_iterator operator--(int a);




  };

  friend bool operator==(const list::reverse_iterator& x
                        ,const list::reverse_iterator& y) const;
  friend bool operator!=(const list::reverse_iterator& x
                        ,const list::reverse_iterator& y) const;

  typedef const iterator const_iterator;
  typedef const reverse_iterator const_reverse_iterator;
# 168 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
  list() ;
  iterator begin() ;
  iterator end() ;
  reverse_iterator rbegin() ;
  reverse_iterator rend() ;






  bool empty() const ;
  size_type size() const ;
  size_type max_size() const ;
  T& front() const ;
  T& back() const ;
  void swap(list& x) ;
  iterator insert(iterator position,const T& x);
  void insert(iterator position,T* first,T* last);
  void insert(iterator position,iterator first,iterator last);
  void insert(iterator position,size_type n,const T& x);
  void push_front(const T& x);
  void push_back(const T& x);
  void resize(size_type n);
  void resize(size_type n, T v);
  void erase(iterator position);
  void erase(iterator first,iterator last);
  void clear() ;
  void pop_front();
  void pop_back();
  list(size_type n,const T& value=T()) ;






  list(const T* first,const T* last) ;

  list(const_iterator first, const_iterator last) ;

  list(const list& x) ;
  ~list() ;
  list& operator=(const list& x) ;
  void splice(iterator position,list& x);
  void splice(iterator position,list& x,iterator i);
  void splice(iterator position,list& x,iterator first,iterator last);
  void remove(const T& value);
  void unique();
  void merge(list& x);
  void reverse();
  void sort();

  friend bool operator==(const list& x, const list& y);
  friend bool operator< (const list& x, const list& y);
  friend bool operator!=(const list& x, const list& y);
  friend bool operator> (const list& x, const list& y);
  friend bool operator>=(const list& x, const list& y);
  friend bool operator<=(const list& x, const list& y);

  // specialized algorithms:





#pragma ifndef G__NOALGORITHM
  // Generic algorithm


  // input iter
  friend list::iterator
    find(list::iterator first,list::iterator last,const T& value);
  // forward iter
  friend list::iterator
    find_end(list::iterator first1,list::iterator last1,
      list::iterator first2,list::iterator last2);
  friend list::iterator
    find_first_of(list::iterator first1,list::iterator last1,
           list::iterator first2,list::iterator last2);
  friend list::iterator
    adjacent_find(list::iterator first,list::iterator last);
  // input iter

  friend list::difference_type
    count(list::iterator first,list::iterator last,const T& value);






  friend bool
    equal(list::iterator first1,list::iterator last1,
          list::iterator first2);
  // forward iter
  friend list::iterator
    search(list::iterator first1,list::iterator last1,
           list::iterator first2,list::iterator last2);
  friend list::iterator
    search_n(list::iterator first,list::iterator last
             ,list::size_type count,const T& value);
  // input and output iter -> forward iter
  friend list::iterator
    copy(list::iterator first,list::iterator last,
         list::iterator result);
  // bidirectional iter
  friend list::iterator
    copy_backward(list::iterator first,list::iterator last,
                  list::iterator result);
  // just value_type
  friend void swap(T& a,T& b);
  // forward iter
  friend list::iterator
    swap_ranges(list::iterator first1,list::iterator last1,
                list::iterator first2);
  friend void iter_swap(list::iterator a,list::iterator b);
  friend void replace(list::iterator first,list::iterator last,
                      const T& old_value,const T& new_value);
  // input, output iter -> forward iter
  friend list::iterator
    replace_copy(list::iterator first,list::iterator last,
                 list::iterator result,
                 const T& old_value,const T& new_value);
  // forward iter
  friend void
    fill(list::iterator first,list::iterator last,const T& value);

  friend void
    fill_n(list::iterator first,list::size_type n,const T& value);

  friend list::iterator
    remove(list::iterator first,list::iterator last,const T& value);
  // input,output iter -> forward iter
  friend list::iterator
    remove_copy(list::iterator first,list::iterator last,
                list::iterator result,const T& value);
  friend list::iterator
    unique(list::iterator first,list::iterator last);
  friend list::iterator
    unique_copy(list::iterator first,list::iterator last,
                list::iterator result);
  friend void reverse(list::iterator first,list::iterator last);
  friend list::iterator
     reverse_copy(list::iterator first,list::iterator last,
                  list::iterator result);
  // forward iter
  friend void rotate(list::iterator first,list::iterator mid,
                     list::iterator last);
  // forward iter
  friend list::iterator
    rotate_copy(list::iterator first,list::iterator mid,
                list::iterator last,list::iterator result);
# 336 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
  // forward iter
  friend list::iterator
    lower_bound(list::iterator first,list::iterator last,const T& value);
  friend list::iterator
    upper_bound(list::iterator first,list::iterator last,const T& value);




  friend bool binary_search(list::iterator first,list::iterator last,
                            const T& value);
  friend list::iterator merge(list::iterator first1,list::iterator last1,
                                list::iterator first2,list::iterator last2,
                                list::iterator result);
  friend void inplace_merge(list::iterator first,list::iterator middle,
                            list::iterator last);
  friend bool includes(list::iterator first1,list::iterator last1,
                       list::iterator first2,list::iterator last2);
  friend list::iterator
    set_union(list::iterator first1,list::iterator last1,
              list::iterator first2,list::iterator last2,
              list::iterator result);
  friend list::iterator
    set_intersection(list::iterator first1,list::iterator last1,
                     list::iterator first2,list::iterator last2,
                     list::iterator result);
  friend list::iterator
    set_difference(list::iterator first1,list::iterator last1,
                   list::iterator first2,list::iterator last2,
                   list::iterator result);
  friend list::iterator
    set_symmetric_difference(list::iterator first1,list::iterator last1,
                             list::iterator first2,list::iterator last2,
                             list::iterator result);







  // min,max, just value_type
  friend const T& min(const T& a,const T& b);
  friend const T& max(const T& a,const T& b);
  // forward iter
  friend list::iterator
    min_element(list::iterator first,list::iterator last);
  friend list::iterator
    max_element(list::iterator first,list::iterator last);
  // input iter
  friend bool
    lexicographical_compare(list::iterator first1,list::iterator last1,
                            list::iterator first2,list::iterator last2);
  // bidirectional iter
  friend bool next_permutation(list::iterator first,list::iterator last);
  friend bool prev_permutation(list::iterator first,list::iterator last);
# 417 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/list"
#pragma endif

  // Generic algorithm
  //friend void reverse(list::iterator first,list::iterator last);
  //friend void reverse(list::reverse_iterator first,list::reverse_itetator last);


  // iterator_category resolution
  //friend bidirectional_iterator_tag iterator_category(list::iterator x);
};

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_list" 2
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/list" 2
}
# 29 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooObjCacheManager.h" 2

class RooNameSet ;


class RooObjCacheManager : public RooCacheManager<RooAbsCacheElement> {

public:

  RooObjCacheManager(RooAbsArg* owner=0, Int_t maxSize=10, Bool_t clearCacheOnServerRedirect=kTRUE) ;
  RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner=0) ;
  virtual ~RooObjCacheManager() ;

  virtual Bool_t redirectServersHook(const RooAbsCollection& /*newServerList*/, Bool_t /*mustReplaceAll*/, Bool_t /*nameChange*/, Bool_t /*isRecursive*/) ;
  virtual void operModeHook() ;
  virtual void optimizeCacheMode(const RooArgSet& /*obs*/, RooArgSet& /*optSet*/, RooLinkedList& /*processedNodes*/) ;
  virtual void printCompactTreeHook(std::ostream&, const char *) ;
  virtual void findConstantNodes(const RooArgSet& /*obs*/, RooArgSet& /*cacheList*/, RooLinkedList& /*processedNodes*/) ;

  virtual void insertObjectHook(RooAbsCacheElement&) ;

  void sterilize() ;

  static void doClearObsList(Bool_t flag) { _clearObsList = flag ; }
  static Bool_t clearObsList() { return _clearObsList ; }

protected:

  Bool_t _clearOnRedirect ;
  Bool_t _optCacheModeSeen ; //! 

  RooArgSet* _optCacheObservables ; //! current optCacheObservables 

  static Bool_t _clearObsList ; // Clear obslist on sterilize?

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 2; } static void Dictionary(); virtual TClass *IsA() const { return RooObjCacheManager::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooObjCacheManager::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooObjCacheManager.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 63; } // Cache manager for generic caches that contain RooAbsArg objects
} ;
# 23 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsPdf.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooCmdArg.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooCmdArg.h,v 1.10 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 24 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsPdf.h" 2

class RooDataSet;
class RooDataHist ;
class RooArgSet ;
class RooRealProxy ;
class RooAbsGenContext ;
class RooFitResult ;
class RooExtendPdf ;
class RooCategory ;
class TPaveText;
class TH1F;
class TH2F;
class TList ;
class RooLinkedList ;
class RooNumGenConfig ;
class RooRealIntegral ;

class RooAbsPdf : public RooAbsReal {
public:

  // Constructors, assignment etc
  RooAbsPdf() ;
  RooAbsPdf(const char *name, const char *title=0) ;
  RooAbsPdf(const char *name, const char *title, Double_t minVal, Double_t maxVal) ;
  // RooAbsPdf(const RooAbsPdf& other, const char* name=0);
  virtual ~RooAbsPdf();

  // Toy MC generation
  RooDataSet *generate(const RooArgSet &whatVars, Int_t nEvents, const RooCmdArg& arg1,
                       const RooCmdArg& arg2=RooCmdArg::none(), const RooCmdArg& arg3=RooCmdArg::none(),
                       const RooCmdArg& arg4=RooCmdArg::none(), const RooCmdArg& arg5=RooCmdArg::none()) ;
  RooDataSet *generate(const RooArgSet &whatVars,
                       const RooCmdArg& arg1=RooCmdArg::none(),const RooCmdArg& arg2=RooCmdArg::none(),
                       const RooCmdArg& arg3=RooCmdArg::none(),const RooCmdArg& arg4=RooCmdArg::none(),
                       const RooCmdArg& arg5=RooCmdArg::none(),const RooCmdArg& arg6=RooCmdArg::none()) ;
  RooDataSet *generate(const RooArgSet &whatVars, Double_t nEvents = 0, Bool_t verbose=kFALSE, Bool_t autoBinned=kTRUE,
         const char* binnedTag="", Bool_t expectedData=kFALSE, Bool_t extended = kFALSE) const;
  RooDataSet *generate(const RooArgSet &whatVars, const RooDataSet &prototype, Int_t nEvents= 0,
         Bool_t verbose=kFALSE, Bool_t randProtoOrder=kFALSE, Bool_t resampleProto=kFALSE) const;


  class GenSpec {
  public:
    virtual ~GenSpec() ;
    GenSpec() { _genContext = 0 ; _protoData = 0 ; _init = kFALSE ; _extended=kFALSE, _nGen=0 ; _randProto = kFALSE ; _resampleProto=kFALSE ; }
  private:
    GenSpec(RooAbsGenContext* context, const RooArgSet& whatVars, RooDataSet* protoData, Int_t nGen, Bool_t extended,
     Bool_t randProto, Bool_t resampleProto, TString dsetName, Bool_t init=kFALSE) ;
    GenSpec(const GenSpec& other) ;

    friend class RooAbsPdf ;
    RooAbsGenContext* _genContext ;
    RooArgSet _whatVars ;
    RooDataSet* _protoData ;
    Int_t _nGen ;
    Bool_t _extended ;
    Bool_t _randProto ;
    Bool_t _resampleProto ;
    TString _dsetName ;
    Bool_t _init ;
    private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 0; } static void Dictionary(); virtual TClass *IsA() const { return GenSpec::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { GenSpec::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsPdf.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 84; } // Generation specification
  } ;

  GenSpec* prepareMultiGen(const RooArgSet &whatVars,
      const RooCmdArg& arg1=RooCmdArg::none(),const RooCmdArg& arg2=RooCmdArg::none(),
      const RooCmdArg& arg3=RooCmdArg::none(),const RooCmdArg& arg4=RooCmdArg::none(),
      const RooCmdArg& arg5=RooCmdArg::none(),const RooCmdArg& arg6=RooCmdArg::none()) ;
  RooDataSet* generate(GenSpec&) const ;


  virtual RooDataHist *generateBinned(const RooArgSet &whatVars, Double_t nEvents, const RooCmdArg& arg1,
         const RooCmdArg& arg2=RooCmdArg::none(), const RooCmdArg& arg3=RooCmdArg::none(),
         const RooCmdArg& arg4=RooCmdArg::none(), const RooCmdArg& arg5=RooCmdArg::none()) ;
  virtual RooDataHist *generateBinned(const RooArgSet &whatVars,
         const RooCmdArg& arg1=RooCmdArg::none(),const RooCmdArg& arg2=RooCmdArg::none(),
         const RooCmdArg& arg3=RooCmdArg::none(),const RooCmdArg& arg4=RooCmdArg::none(),
         const RooCmdArg& arg5=RooCmdArg::none(),const RooCmdArg& arg6=RooCmdArg::none()) ;
  virtual RooDataHist *generateBinned(const RooArgSet &whatVars, Double_t nEvents, Bool_t expectedData=kFALSE, Bool_t extended=kFALSE) const;

  virtual RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents) ;

  virtual RooPlot* plotOn(RooPlot* frame,
     const RooCmdArg& arg1=RooCmdArg::none(), const RooCmdArg& arg2=RooCmdArg::none(),
     const RooCmdArg& arg3=RooCmdArg::none(), const RooCmdArg& arg4=RooCmdArg::none(),
     const RooCmdArg& arg5=RooCmdArg::none(), const RooCmdArg& arg6=RooCmdArg::none(),
     const RooCmdArg& arg7=RooCmdArg::none(), const RooCmdArg& arg8=RooCmdArg::none(),
     const RooCmdArg& arg9=RooCmdArg::none(), const RooCmdArg& arg10=RooCmdArg::none()
              ) const {
    return RooAbsReal::plotOn(frame,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10) ;
  }


  virtual RooPlot* paramOn(RooPlot* frame,
                           const RooCmdArg& arg1=RooCmdArg::none(), const RooCmdArg& arg2=RooCmdArg::none(),
                           const RooCmdArg& arg3=RooCmdArg::none(), const RooCmdArg& arg4=RooCmdArg::none(),
                           const RooCmdArg& arg5=RooCmdArg::none(), const RooCmdArg& arg6=RooCmdArg::none(),
                           const RooCmdArg& arg7=RooCmdArg::none(), const RooCmdArg& arg8=RooCmdArg::none()) ;

  virtual RooPlot* paramOn(RooPlot* frame, const RooAbsData* data, const char *label= "", Int_t sigDigits = 2,
      Option_t *options = "NELU", Double_t xmin=0.50,
      Double_t xmax= 0.99,Double_t ymax=0.95) ;

  // Built-in generator support
  virtual Int_t getGenerator(const RooArgSet& directVars, RooArgSet &generateVars, Bool_t staticInitOK=kTRUE) const;
  virtual void initGenerator(Int_t code) ;
  virtual void generateEvent(Int_t code);
  virtual Bool_t isDirectGenSafe(const RooAbsArg& arg) const ;

  // Configuration of MC generators used for this pdf
  const RooNumGenConfig* getGeneratorConfig() const ;
  static RooNumGenConfig* defaultGeneratorConfig() ;
  RooNumGenConfig* specialGeneratorConfig() const ;
  RooNumGenConfig* specialGeneratorConfig(Bool_t createOnTheFly) ;
  void setGeneratorConfig() ;
  void setGeneratorConfig(const RooNumGenConfig& config) ;

  // -log(L) fits to binned and unbinned data
  virtual RooFitResult* fitTo(RooAbsData& data, const RooCmdArg& arg1=RooCmdArg::none(), const RooCmdArg& arg2=RooCmdArg::none(),
                              const RooCmdArg& arg3=RooCmdArg::none(), const RooCmdArg& arg4=RooCmdArg::none(), const RooCmdArg& arg5=RooCmdArg::none(),
                              const RooCmdArg& arg6=RooCmdArg::none(), const RooCmdArg& arg7=RooCmdArg::none(), const RooCmdArg& arg8=RooCmdArg::none()) ;
  virtual RooFitResult* fitTo(RooAbsData& data, const RooLinkedList& cmdList) ;

  virtual RooAbsReal* createNLL(RooAbsData& data, const RooLinkedList& cmdList) ;
  virtual RooAbsReal* createNLL(RooAbsData& data, const RooCmdArg& arg1=RooCmdArg::none(), const RooCmdArg& arg2=RooCmdArg::none(),
    const RooCmdArg& arg3=RooCmdArg::none(), const RooCmdArg& arg4=RooCmdArg::none(), const RooCmdArg& arg5=RooCmdArg::none(),
    const RooCmdArg& arg6=RooCmdArg::none(), const RooCmdArg& arg7=RooCmdArg::none(), const RooCmdArg& arg8=RooCmdArg::none()) ;

  // Chi^2 fits to histograms
  using RooAbsReal::chi2FitTo ;
  using RooAbsReal::createChi2 ;
  virtual RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList) ;
  virtual RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1=RooCmdArg::none(), const RooCmdArg& arg2=RooCmdArg::none(),
     const RooCmdArg& arg3=RooCmdArg::none(), const RooCmdArg& arg4=RooCmdArg::none(), const RooCmdArg& arg5=RooCmdArg::none(),
     const RooCmdArg& arg6=RooCmdArg::none(), const RooCmdArg& arg7=RooCmdArg::none(), const RooCmdArg& arg8=RooCmdArg::none()) ;

  // Chi^2 fits to X-Y datasets
  virtual RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList) ;





  // Constraint management
  virtual RooArgSet* getConstraints(const RooArgSet& /*observables*/, RooArgSet& /*constrainedParams*/, Bool_t /*stripDisconnected*/) const {
    // Interface to retrieve constraint terms on this pdf. Default implementation returns null
    return 0 ;
  }
  virtual RooArgSet* getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected=kTRUE) const ;

  // Project p.d.f into lower dimensional p.d.f
  virtual RooAbsPdf* createProjection(const RooArgSet& iset) ;

  // Create cumulative density function from p.d.f
  RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset=RooArgSet()) ;
  RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2=RooCmdArg::none(),
   const RooCmdArg& arg3=RooCmdArg::none(), const RooCmdArg& arg4=RooCmdArg::none(),
   const RooCmdArg& arg5=RooCmdArg::none(), const RooCmdArg& arg6=RooCmdArg::none(),
   const RooCmdArg& arg7=RooCmdArg::none(), const RooCmdArg& arg8=RooCmdArg::none()) ;
  RooAbsReal* createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder) ;

  // Function evaluation support
  virtual Bool_t traceEvalHook(Double_t value) const ;
  virtual Double_t getValV(const RooArgSet* set=0) const ;
  virtual Double_t getLogVal(const RooArgSet* set=0) const ;

  Double_t getNorm(const RooArgSet& nset) const {
    // Get p.d.f normalization term needed for observables 'nset'
    return getNorm(&nset) ;
  }
  virtual Double_t getNorm(const RooArgSet* set=0) const ;

  virtual void resetErrorCounters(Int_t resetValue=10) ;
  void setTraceCounter(Int_t value, Bool_t allNodes=kFALSE) ;
  Bool_t traceEvalPdf(Double_t value) const ;

  Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName=0) const ;

  virtual Bool_t selfNormalized() const {
    // If true, p.d.f is taken as self-normalized and no attempt is made to add a normalization term
    // This default implementation return false
    return kFALSE ;
  }

  // Support for extended maximum likelihood, switched off by default
  enum ExtendMode { CanNotBeExtended, CanBeExtended, MustBeExtended } ;
  virtual ExtendMode extendMode() const {
    // Returns ability of p.d.f to provided extended likelihood terms. Possible
    // answers are CanNotBeExtended, CanBeExtended or MustBeExtended. This
    // default implementation always return CanNotBeExtended
    return CanNotBeExtended ;
  }
  inline Bool_t canBeExtended() const {
    // If true p.d.f can provide extended likelihood term
    return (extendMode() != CanNotBeExtended) ;
  }
  inline Bool_t mustBeExtended() const {
    // If true p.d.f must extended likelihood term
    return (extendMode() == MustBeExtended) ;
  }
  virtual Double_t expectedEvents(const RooArgSet* nset) const ;
  virtual Double_t expectedEvents(const RooArgSet& nset) const {
    // Return expecteded number of p.d.fs to be used in calculated of extended likelihood
    return expectedEvents(&nset) ;
  }

  // Printing interface (human readable)
  virtual void printValue(std::ostream& os) const ;
  virtual void printMultiline(std::ostream& os, Int_t contents, Bool_t verbose=kFALSE, TString indent="") const ;

  static void verboseEval(Int_t stat) ;
  static int verboseEval() ;

  virtual Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset=0) const ;

  static void clearEvalError() ;
  static Bool_t evalError() ;

  void setNormRange(const char* rangeName) ;
  const char* normRange() const {
    return _normRange.Length()>0 ? _normRange.Data() : 0 ;
  }
  void setNormRangeOverride(const char* rangeName) ;

  const RooAbsReal* getNormIntegral(const RooArgSet& nset) const { return getNormObj(0,&nset,0) ; }

protected:

public:
  virtual const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName=0) const ;
protected:

  RooDataSet *generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype,
         Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit=kFALSE,
         Bool_t extended=kFALSE) const ;

  // Implementation version
  virtual RooPlot* paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants=kFALSE,
                           const char *label= "", Int_t sigDigits = 2, Option_t *options = "NELU", Double_t xmin=0.65,
      Double_t xmax= 0.99,Double_t ymax=0.95, const RooCmdArg* formatCmd=0) ;


  virtual RooPlot* plotOn(RooPlot* frame, RooLinkedList& cmdList) const ;
  void plotOnCompSelect(RooArgSet* selNodes) const ;

  virtual RooPlot *plotOn(RooPlot *frame, PlotOpt o) const;

  friend class RooEffGenContext ;
  friend class RooAddGenContext ;
  friend class RooProdGenContext ;
  friend class RooSimGenContext ;
  friend class RooSimSplitGenContext ;
  friend class RooConvGenContext ;
  friend class RooSimultaneous ;
  friend class RooAddGenContextOrig ;
  friend class RooProdPdf ;
  friend class RooMCStudy ;

  Int_t* randomizeProtoOrder(Int_t nProto,Int_t nGen,Bool_t resample=kFALSE) const ;

  virtual RooAbsGenContext* binnedGenContext(const RooArgSet &vars, Bool_t verbose= kFALSE) const ;

  virtual RooAbsGenContext* genContext(const RooArgSet &vars, const RooDataSet *prototype=0,
                                const RooArgSet* auxProto=0, Bool_t verbose= kFALSE) const ;

  virtual RooAbsGenContext* autoGenContext(const RooArgSet &vars, const RooDataSet* prototype=0, const RooArgSet* auxProto=0,
        Bool_t verbose=kFALSE, Bool_t autoBinned=kTRUE, const char* binnedTag="") const ;


  friend class RooExtendPdf ;
  // This also forces the definition of a copy ctor in derived classes 
  RooAbsPdf(const RooAbsPdf& other, const char* name = 0);

  friend class RooRealIntegral ;
  static Int_t _verboseEval ;

  virtual Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies=kTRUE) const ;

  friend class RooAbsAnaConvPdf ;
  mutable Double_t _rawValue ;
  mutable RooAbsReal* _norm ; //! Normalization integral (owned by _normMgr)
  mutable RooArgSet* _normSet ; //! Normalization set with for above integral

  class CacheElem : public RooAbsCacheElement {
  public:
    CacheElem(RooAbsReal& norm) : _norm(&norm) {} ;
    void operModeHook(RooAbsArg::OperMode) ;
    virtual ~CacheElem() ;
    virtual RooArgList containedArgs(Action) { return RooArgList(*_norm) ; }
    RooAbsReal* _norm ;
  } ;
  mutable RooObjCacheManager _normMgr ; // The cache manager

  friend class CacheElem ; // Cache needs to be able to clear _norm pointer

  virtual Bool_t redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t) {
    // Hook function intercepting redirectServer calls. Discard current normalization
    // object if any server is redirected

    // Object is own by _normCacheManager that will delete object as soon as cache
    // is sterilized by server redirect
    _norm = 0 ;
    return kFALSE ;
  } ;


  mutable Int_t _errorCount ; // Number of errors remaining to print
  mutable Int_t _traceCount ; // Number of traces remaining to print
  mutable Int_t _negCount ; // Number of negative probablities remaining to print

  Bool_t _selectComp ; // Component selection flag for RooAbsPdf::plotCompOn

  static void raiseEvalError() ;

  static Bool_t _evalError ;

  RooNumGenConfig* _specGeneratorConfig ; //! MC generator configuration specific for this object

  TString _normRange ; // Normalization range
  static TString _normRangeOverride ;

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 4; } static void Dictionary(); virtual TClass *IsA() const { return RooAbsPdf::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooAbsPdf::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsPdf.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 344; } // Abstract PDF with normalization support
};
# 17 "/scratch/condor/dir_19652/./RooStepBernstein.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooRealProxy.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooRealProxy.h,v 1.23 2007/07/12 20:30:28 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsReal.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooAbsReal.h,v 1.75 2007/07/13 21:50:24 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooRealProxy.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooArgProxy.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooArgProxy.h,v 1.21 2007/07/12 20:30:28 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TNamed.h" 1
// @(#)root/base:$Id: TNamed.h 20877 2007-11-19 11:17:07Z rdm $
// Author: Rene Brun   26/12/94

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooArgProxy.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsProxy.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooAbsProxy.h,v 1.15 2007/07/12 20:30:28 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TObject.h" 1
// @(#)root/base:$Id: TObject.h 38832 2011-04-13 17:54:49Z rdm $
// Author: Rene Brun   26/12/94

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsProxy.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsArg.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooAbsArg.h,v 1.93 2007/07/16 21:04:28 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsProxy.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Riosfwd.h" 1
// @(#)root/base:$Id: Riosfwd.h 20877 2007-11-19 11:17:07Z rdm $
// Author: Fons Rademakers   23/1/02

/*************************************************************************
 * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 22 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsProxy.h" 2
# 32 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsProxy.h"
class RooAbsProxy {
public:

  // Constructors, assignment etc.
  RooAbsProxy() ;
  RooAbsProxy(const char* name, const RooAbsProxy& other) ;
  virtual ~RooAbsProxy() {
    // Destructor
  } ;

  virtual const char* name() const {
    // Return name of proxy
    return "dummy" ;
  } ;

  inline const RooArgSet* nset() const {
    // Return normalization set to be used for evaluation of contents
    return _nset ;
  }
  virtual void print(std::ostream& os, Bool_t addContents=kFALSE) const ;

protected:

  RooArgSet* _nset ; //! Normalization set to be used for evaluation of RooAbsPdf contents

  friend class RooAbsArg ;
  friend class RooObjectFactory ;
  virtual Bool_t changePointer(const RooAbsCollection& newServerSet, Bool_t nameChange=kFALSE, Bool_t factoryInitMode=kFALSE) = 0 ;

  friend class RooAbsPdf ;
  virtual void changeNormSet(const RooArgSet* newNormSet) ;

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return RooAbsProxy::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooAbsProxy::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsProxy.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 64; } // Abstract proxy interface
} ;
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooArgProxy.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsArg.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooAbsArg.h,v 1.93 2007/07/16 21:04:28 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 22 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooArgProxy.h" 2


class RooArgProxy : public TNamed, public RooAbsProxy {
public:

  // Constructors, assignment etc.
  RooArgProxy() : _owner(0), _arg(0), _valueServer(kFALSE), _shapeServer(kFALSE), _isFund(kTRUE), _ownArg(kFALSE) {
    // Default constructor
  } ;
  RooArgProxy(const char* name, const char* desc, RooAbsArg* owner,
       Bool_t valueServer, Bool_t shapeServer, Bool_t proxyOwnsArg=kFALSE) ;
  RooArgProxy(const char* name, const char* desc, RooAbsArg* owner, RooAbsArg& arg,
       Bool_t valueServer, Bool_t shapeServer, Bool_t proxyOwnsArg=kFALSE) ;
  RooArgProxy(const char* name, RooAbsArg* owner, const RooArgProxy& other) ;
  virtual ~RooArgProxy() ;
  inline RooAbsArg* absArg() const {
    // Return pointer to contained argument
    return _arg ;
  }

  virtual const char* name() const {
    // Return name of proxy
    return GetName() ;
  }
  virtual void print(std::ostream& os, Bool_t addContents=kFALSE) const ;

protected:

  friend class RooSimultaneous ;
  RooAbsArg* _owner ; // Pointer to owner of proxy
  RooAbsArg* _arg ; // Pointer to content of proxy

  Bool_t _valueServer ; // If true contents is value server of owner
  Bool_t _shapeServer ; // If true contents is shape server of owner
  Bool_t _isFund ; // If true proxy contains an lvalue
  Bool_t _ownArg ; // If true proxy owns contents

  friend class RooAbsArg ;

  inline Bool_t isValueServer() const {
    // Returns true of contents is value server of owner
    return _valueServer ;
  }
  inline Bool_t isShapeServer() const {
    // Returns true if contents is shape server of owner
    return _shapeServer ;
  }
  virtual Bool_t changePointer(const RooAbsCollection& newServerSet, Bool_t nameChange=kFALSE, Bool_t factoryInitMode=kFALSE) ;

  virtual void changeDataSet(const RooArgSet* newNormSet) ;

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return RooArgProxy::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooArgProxy::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooArgProxy.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 73; } // Abstract proxy for RooAbsArg objects
};
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooRealProxy.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsRealLValue.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooAbsRealLValue.h,v 1.37 2007/07/13 21:50:24 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Riosfwd.h" 1
// @(#)root/base:$Id: Riosfwd.h 20877 2007-11-19 11:17:07Z rdm $
// Author: Fons Rademakers   23/1/02

/*************************************************************************
 * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsRealLValue.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/math.h" 1





#pragma include_noerr <stdfunc.dll>
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsRealLValue.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/float.h" 1
# 22 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsRealLValue.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TString.h" 1
// @(#)root/base:$Id: TString.h 43133 2012-02-27 09:50:10Z rdm $
// Author: Fons Rademakers   04/08/95

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 23 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsRealLValue.h" 2

# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsReal.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooAbsReal.h,v 1.75 2007/07/13 21:50:24 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 25 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsRealLValue.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooNumber.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooNumber.h,v 1.7 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h" 1
/* @(#)root/base:$Id: Rtypes.h 43708 2012-04-12 10:19:00Z axel $ */

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooNumber.h" 2

class RooNumber {
public:

  virtual ~RooNumber() {} ;

  static Double_t infinity() ;
  static Int_t isInfinite(Double_t x) ;

 private:
  static Double_t _Infinity ;

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 0; } static void Dictionary(); virtual TClass *IsA() const { return RooNumber::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooNumber::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooNumber.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 32; } // wrapper class for portable numerics
};
# 26 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsRealLValue.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsLValue.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooAbsLValue.h,v 1.12 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Riosfwd.h" 1
// @(#)root/base:$Id: Riosfwd.h 20877 2007-11-19 11:17:07Z rdm $
// Author: Fons Rademakers   23/1/02

/*************************************************************************
 * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsLValue.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h" 1
/* @(#)root/base:$Id: Rtypes.h 43708 2012-04-12 10:19:00Z axel $ */

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsLValue.h" 2

class RooAbsBinning ;

class RooAbsLValue {
public:

  // Constructors, cloning and assignment
  RooAbsLValue() ;
  virtual ~RooAbsLValue();

  virtual void setBin(Int_t ibin, const char* rangeName=0) = 0 ;
  virtual Int_t getBin(const char* rangeName=0) const = 0 ;
  virtual Int_t numBins(const char* rangeName=0) const = 0 ;
  virtual Double_t getBinWidth(Int_t i, const char* rangeName=0) const = 0 ;
  virtual Double_t volume(const char* rangeName) const = 0 ;
  virtual void randomize(const char* rangeName=0) = 0 ;

  virtual const RooAbsBinning* getBinningPtr(const char* rangeName) const = 0 ;
  virtual Int_t getBin(const RooAbsBinning*) const = 0 ;

protected:

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return RooAbsLValue::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooAbsLValue::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsLValue.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 43; } // Abstract variable
};
# 27 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsRealLValue.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsBinning.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooAbsBinning.h,v 1.13 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h" 1
/* @(#)root/base:$Id: Rtypes.h 43708 2012-04-12 10:19:00Z axel $ */

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsBinning.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooPrintable.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooPrintable.h,v 1.12 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsBinning.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TNamed.h" 1
// @(#)root/base:$Id: TNamed.h 20877 2007-11-19 11:17:07Z rdm $
// Author: Rene Brun   26/12/94

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 22 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsBinning.h" 2
class TIterator ;
class RooAbsRealLValue ;
class RooAbsReal ;

class RooAbsBinning : public TNamed, public RooPrintable {
public:

  RooAbsBinning(const char* name=0) ;
  RooAbsBinning(const RooAbsBinning& other, const char* name=0) : TNamed(name,name), RooPrintable(other) {
    // Copy constructor
  }
  virtual TObject* Clone(const char* newname=0) const { return clone(newname) ; }
  virtual RooAbsBinning* clone(const char* name=0) const = 0 ;
  virtual ~RooAbsBinning() ;

  Int_t numBins() const {
    // Return number of bins 
    return numBoundaries()-1 ;
  }
  virtual Int_t numBoundaries() const = 0 ;
  virtual Int_t binNumber(Double_t x) const = 0 ;
  virtual Int_t rawBinNumber(Double_t x) const { return binNumber(x) ; }
  virtual Double_t binCenter(Int_t bin) const = 0 ;
  virtual Double_t binWidth(Int_t bin) const = 0 ;
  virtual Double_t binLow(Int_t bin) const = 0 ;
  virtual Double_t binHigh(Int_t bin) const = 0 ;
  virtual Bool_t isUniform() const { return kFALSE ; }

  virtual void setRange(Double_t xlo, Double_t xhi) = 0 ;
  virtual void setMin(Double_t xlo) {
    // Change lower bound to xlo
    setRange(xlo,highBound()) ;
  }
  virtual void setMax(Double_t xhi) {
    // Change upper bound to xhi
    setRange(lowBound(),xhi) ;
  }

  virtual Double_t lowBound() const = 0 ;
  virtual Double_t highBound() const = 0 ;
  virtual Double_t averageBinWidth() const = 0 ;


  virtual Double_t* array() const = 0 ;

  inline virtual void Print(Option_t *options= 0) const {
    // Printing interface
    printStream(defaultPrintStream(),defaultPrintContents(options),defaultPrintStyle(options));
  }

  virtual void printName(std::ostream& os) const ;
  virtual void printTitle(std::ostream& os) const ;
  virtual void printClassName(std::ostream& os) const ;
  virtual void printArgs(std::ostream& os) const ;
  virtual void printValue(std::ostream& os) const ;


  virtual Bool_t isParameterized() const {
    // Interface function. If true, min/max of binning is parameterized by external RooAbsReals
    return kFALSE ;
  }
  virtual RooAbsReal* lowBoundFunc() const {
    // Return pointer to RooAbsReal parameterized lower bound, if any
    return 0 ;
  }
  virtual RooAbsReal* highBoundFunc() const {
    // Return pointer to RooAbsReal parameterized upper bound, if any
    return 0 ;
  }
  virtual Bool_t isShareable() const {
    // If true (default) range definition can be shared across clones of a RooRealVar
    return kTRUE ;
  }
  virtual void insertHook(RooAbsRealLValue&) const {
    // Hook interface function to execute code upon insertion into a RooAbsRealLValue
  } ;
  virtual void removeHook(RooAbsRealLValue&) const {
    // Hook interface functionto execute code upon removal from a RooAbsRealLValue
  } ;

protected:

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 2; } static void Dictionary(); virtual TClass *IsA() const { return RooAbsBinning::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooAbsBinning::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsBinning.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 104; } // Abstract base class for binning specification
};
# 28 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsRealLValue.h" 2

class RooArgSet ;

class RooAbsRealLValue : public RooAbsReal, public RooAbsLValue {
public:
  // Constructors, assignment etc.
  inline RooAbsRealLValue() { }
  RooAbsRealLValue(const char *name, const char *title, const char *unit= "") ;
  RooAbsRealLValue(const RooAbsRealLValue& other, const char* name=0);
  virtual ~RooAbsRealLValue();

  // Parameter value and error accessors
  virtual void setVal(Double_t value)=0;
  virtual RooAbsArg& operator=(const RooAbsReal& other) ;
  virtual RooAbsArg& operator=(Double_t newValue);
  virtual RooAbsArg& operator=(Int_t ival) { return operator=((Double_t)ival) ; }

  // Implementation of RooAbsLValue
  virtual void setBin(Int_t ibin, const char* rangeName=0) ;
  virtual Int_t getBin(const char* rangeName=0) const { return getBinning(rangeName).binNumber(getVal()) ; }
  virtual Int_t numBins(const char* rangeName=0) const { return getBins(rangeName) ; }
  virtual Double_t getBinWidth(Int_t i, const char* rangeName=0) const { return getBinning(rangeName).binWidth(i) ; }
  virtual Double_t volume(const char* rangeName) const { return getMax(rangeName)-getMin(rangeName) ; }
  virtual void randomize(const char* rangeName=0);

  virtual const RooAbsBinning* getBinningPtr(const char* rangeName) const { return &getBinning(rangeName) ; }
  virtual Int_t getBin(const RooAbsBinning* ptr) const { return ptr->binNumber(getVal()) ; }

  virtual void setBin(Int_t ibin, const RooAbsBinning& binning) ;
  virtual Int_t getBin(const RooAbsBinning& binning) const { return binning.binNumber(getVal()) ; }
  virtual Int_t numBins(const RooAbsBinning& binning) const { return binning.numBins() ; }
  virtual Double_t getBinWidth(Int_t i, const RooAbsBinning& binning) const { return binning.binWidth(i) ; }
  virtual Double_t volume(const RooAbsBinning& binning) const { return binning.highBound() - binning.lowBound() ; }
  virtual void randomize(const RooAbsBinning& binning) ;


  virtual void setBinFast(Int_t ibin, const RooAbsBinning& binning) ;

  // Get fit range limits

  virtual const RooAbsBinning& getBinning(const char* name=0, Bool_t verbose=kTRUE, Bool_t createOnTheFly=kFALSE) const = 0 ;
  virtual RooAbsBinning& getBinning(const char* name=0, Bool_t verbose=kTRUE, Bool_t createOnTheFly=kFALSE) = 0 ;
  virtual Bool_t hasBinning(const char* name) const = 0 ;
  virtual Bool_t inRange(const char* name) const ;
  virtual Int_t getBins(const char* name=0) const { return getBinning(name).numBins() ; }
  virtual Double_t getMin(const char* name=0) const { return getBinning(name).lowBound() ; }
  virtual Double_t getMax(const char* name=0) const { return getBinning(name).highBound() ; }
  inline Bool_t hasMin(const char* name=0) const { return !RooNumber::isInfinite(getMin(name)); }
  inline Bool_t hasMax(const char* name=0) const { return !RooNumber::isInfinite(getMax(name)); }
  virtual Bool_t hasRange(const char* name) const { return hasBinning(name) ; }

  // Jacobian term management
  virtual Bool_t isJacobianOK(const RooArgSet& depList) const ;
  virtual Double_t jacobian() const { return 1 ; }

  inline virtual Bool_t isLValue() const { return kTRUE; }

  // Test a value against our fit range
  Bool_t inRange(Double_t value, const char* rangeName, Double_t* clippedValue=0) const;
  virtual Bool_t isValidReal(Double_t value, Bool_t printError=kFALSE) const ;

  // Constant and Projected flags 
  inline void setConstant(Bool_t value= kTRUE) { setAttribute("Constant",value); setValueDirty() ; setShapeDirty() ; }

  // I/O streaming interface (machine readable)
  virtual Bool_t readFromStream(std::istream& is, Bool_t compact, Bool_t verbose=kFALSE) ;
  virtual void writeToStream(std::ostream& os, Bool_t compact) const ;

  // Printing interface (human readable)
  virtual void printMultiline(std::ostream& os, Int_t contents, Bool_t verbose=kFALSE, TString indent="") const ;


  // Build 1-dimensional plots
  RooPlot* frame(const RooCmdArg& arg1, const RooCmdArg& arg2=RooCmdArg::none(),
                 const RooCmdArg& arg3=RooCmdArg::none(), const RooCmdArg& arg4=RooCmdArg::none(), const RooCmdArg& arg5=RooCmdArg::none(),
                 const RooCmdArg& arg6=RooCmdArg::none(), const RooCmdArg& arg7=RooCmdArg::none(), const RooCmdArg& arg8=RooCmdArg::none()) const ;
  RooPlot *frame(const RooLinkedList& cmdList) const ;
  RooPlot *frame(Double_t lo, Double_t hi, Int_t nbins) const;
  RooPlot *frame(Double_t lo, Double_t hi) const;
  RooPlot *frame(Int_t nbins) const;
  RooPlot *frame() const;

  // Create empty 1,2, and 3D histograms from a list of 1-3 RooAbsReals
  TH1 *createHistogram(const char *name,
                       const RooCmdArg& arg1=RooCmdArg::none(), const RooCmdArg& arg2=RooCmdArg::none(),
                       const RooCmdArg& arg3=RooCmdArg::none(), const RooCmdArg& arg4=RooCmdArg::none(),
                       const RooCmdArg& arg5=RooCmdArg::none(), const RooCmdArg& arg6=RooCmdArg::none(),
                       const RooCmdArg& arg7=RooCmdArg::none(), const RooCmdArg& arg8=RooCmdArg::none()) const ;
  TH1 *createHistogram(const char *name, const RooLinkedList& cmdList) const ;

  TH1F *createHistogram(const char *name, const char *yAxisLabel) const ;
  TH1F *createHistogram(const char *name, const char *yAxisLabel, Double_t xlo, Double_t xhi, Int_t nBins) const ;
  TH1F *createHistogram(const char *name, const char *yAxisLabel, const RooAbsBinning& bins) const ;

  TH2F *createHistogram(const char *name, const RooAbsRealLValue &yvar, const char *zAxisLabel=0,
   Double_t* xlo=0, Double_t* xhi=0, Int_t* nBins=0) const ;
  TH2F *createHistogram(const char *name, const RooAbsRealLValue &yvar, const char *zAxisLabel, const RooAbsBinning** bins) const ;


  TH3F *createHistogram(const char *name, const RooAbsRealLValue &yvar, const RooAbsRealLValue &zvar,
   const char *tAxisLabel, Double_t* xlo=0, Double_t* xhi=0, Int_t* nBins=0) const ;
  TH3F *createHistogram(const char *name, const RooAbsRealLValue &yvar, const RooAbsRealLValue &zvar, const char* tAxisLabel, const RooAbsBinning** bins) const ;

  static TH1* createHistogram(const char *name, RooArgList &vars, const char *tAxisLabel, Double_t* xlo, Double_t* xhi, Int_t* nBins) ;
  static TH1* createHistogram(const char *name, RooArgList &vars, const char *tAxisLabel, const RooAbsBinning** bins) ;

protected:

  friend class RooRealBinding ;

  virtual void setValFast(Double_t value) { setVal(value) ; }

  virtual void setVal(Double_t value, const char* /*rangeName*/) {
    // Set object value to 'value'
    return setVal(value) ;
  }
  Bool_t fitRangeOKForPlotting() const ;
  void copyCache(const RooAbsArg* source, Bool_t valueOnly=kFALSE, Bool_t setValDirty=kTRUE) ;

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return RooAbsRealLValue::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooAbsRealLValue::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsRealLValue.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 147; } // Abstract modifiable real-valued object
};
# 22 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooRealProxy.h" 2

class RooRealProxy : public RooArgProxy {
public:

  // Constructors, assignment etc.
  RooRealProxy() {} ;
  RooRealProxy(const char* name, const char* desc, RooAbsArg* owner,
        Bool_t valueServer=kTRUE, Bool_t shapeServer=kFALSE, Bool_t proxyOwnsArg=kFALSE) ;
  RooRealProxy(const char* name, const char* desc, RooAbsArg* owner, RooAbsReal& ref,
        Bool_t valueServer=kTRUE, Bool_t shapeServer=kFALSE, Bool_t proxyOwnsArg=kFALSE) ;
  RooRealProxy(const char* name, RooAbsArg* owner, const RooRealProxy& other) ;
  virtual TObject* Clone(const char* newName=0) const { return new RooRealProxy(newName,_owner,*this); }
  virtual ~RooRealProxy();

  // Accessors

  inline operator Double_t() const { return (_arg->_fast && !_arg->_inhibitDirty) ? ((RooAbsReal*)_arg)->_value : ((RooAbsReal*)_arg)->getVal(_nset) ; }




  inline const RooAbsReal& arg() const { return (RooAbsReal&)*_arg ; }

  // Modifier
  virtual Bool_t setArg(RooAbsReal& newRef) ;

protected:

  RooAbsRealLValue* lvptr() const ;

public:

  // LValue operations 
  RooRealProxy& operator=(const Double_t& value) { lvptr()->setVal(value) ; return *this ; }
  Double_t min(const char* rname=0) const { return lvptr()->getMin(rname) ; }
  Double_t max(const char* rname=0) const { return lvptr()->getMax(rname) ; }
  Bool_t hasMin(const char* rname=0) const { return lvptr()->hasMin(rname) ; }
  Bool_t hasMax(const char* rname=0) const { return lvptr()->hasMax(rname) ; }


  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return RooRealProxy::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooRealProxy::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooRealProxy.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 62; } // Proxy for a RooAbsReal object
};
# 18 "/scratch/condor/dir_19652/./RooStepBernstein.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooListProxy.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooListProxy.h,v 1.11 2007/07/13 21:24:36 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TObject.h" 1
// @(#)root/base:$Id: TObject.h 38832 2011-04-13 17:54:49Z rdm $
// Author: Rene Brun   26/12/94

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooListProxy.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Riosfwd.h" 1
// @(#)root/base:$Id: Riosfwd.h 20877 2007-11-19 11:17:07Z rdm $
// Author: Fons Rademakers   23/1/02

/*************************************************************************
 * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooListProxy.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsProxy.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooAbsProxy.h,v 1.15 2007/07/12 20:30:28 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 22 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooListProxy.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooLinkedListIter.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooLinkedListIter.h,v 1.11 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 23 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooListProxy.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsArg.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooAbsArg.h,v 1.93 2007/07/16 21:04:28 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 24 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooListProxy.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooArgList.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooArgList.h,v 1.14 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 25 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooListProxy.h" 2

class RooListProxy : public RooArgList, public RooAbsProxy {
public:

  // Constructors, assignment etc.
  RooListProxy() : _defValueServer(kTRUE), _defShapeServer(kFALSE) { _iter = createIterator() ; _owner=0 ; } ;
  RooListProxy(const char* name, const char* desc, RooAbsArg* owner,
       Bool_t defValueServer=kTRUE, Bool_t defShapeServer=kFALSE) ;
  RooListProxy(const char* name, RooAbsArg* owner, const RooListProxy& other) ;
  virtual ~RooListProxy() ;

  virtual const char* name() const { return GetName() ; }

  // List content management (modified for server hooks)
  virtual Bool_t add(const RooAbsArg& var, Bool_t silent=kFALSE) ;
  virtual Bool_t add(const RooAbsCollection& list, Bool_t silent=kFALSE) { return RooAbsCollection::add(list,silent) ; }
  virtual Bool_t add(const RooAbsArg& var, Bool_t valueServer, Bool_t shapeServer, Bool_t silent) ;
  virtual Bool_t addOwned(RooAbsArg& var, Bool_t silent=kFALSE);
  virtual Bool_t addOwned(const RooAbsCollection& list, Bool_t silent=kFALSE) { return RooAbsCollection::addOwned(list,silent) ; }
  virtual Bool_t replace(const RooAbsArg& var1, const RooAbsArg& var2) ;
  virtual Bool_t remove(const RooAbsArg& var, Bool_t silent=kFALSE, Bool_t matchByNameOnly=kFALSE) ;
  virtual void removeAll() ;

  RooListProxy& operator=(const RooArgList& other) ;

  virtual void print(std::ostream& os, Bool_t addContents=kFALSE) const ;

protected:

  RooAbsArg* _owner ; // Pointer to owner
  Bool_t _defValueServer ; // Propagate value dirty flags?
  Bool_t _defShapeServer ; // Propagate shape dirty flags?
  TIterator* _iter ; //! do not persist

  virtual Bool_t changePointer(const RooAbsCollection& newServerSet, Bool_t nameChange=kFALSE, Bool_t factoryInitMode=kFALSE) ;

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return RooListProxy::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooListProxy::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooListProxy.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 61; } // Proxy class for a RooArgList
};
# 19 "/scratch/condor/dir_19652/./RooStepBernstein.h" 2

class RooRealVar;
class RooArgList ;

class RooStepBernstein : public RooAbsPdf {
public:

  RooStepBernstein() ;
  RooStepBernstein(const char *name, const char *title,
     RooAbsReal& _x, RooAbsReal& _stepThresh,
     const RooArgList& _coefList) ;

  RooStepBernstein(const RooStepBernstein& other, const char* name = 0);
  virtual TObject* clone(const char* newname) const { return new RooStepBernstein(*this, newname); }
  inline virtual ~RooStepBernstein() { }

  Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName=0) const ;
  Double_t analyticalIntegral(Int_t code, const char* rangeName=0) const ;

private:

  RooRealProxy _x;
  RooRealProxy _stepThresh;
  RooListProxy _coefList ;

  Double_t evaluate() const;

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return RooStepBernstein::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooStepBernstein::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/scratch/condor/dir_19652/./RooStepBernstein.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 46; } // Bernstein polynomial PDF with step function
};
# 27 "/scratch/condor/dir_19652/./RooStepBernstein.cxx" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooFit.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooFit.h,v 1.4 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/RConfig.h" 1
/* @(#)root/base:$Id: RConfig.h 43709 2012-04-12 11:04:01Z rdm $ */

/*************************************************************************
 * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooFit.h" 2

// Global include file to fix occasional compiler issues
// An error in the construction of the system and C++ header files on
// Solaris 8 / Workshop 6 Updates 1&2 leads to a conflict between the use
// of ::clock_t and clock_t when <string> is compiled under
// -D_XOPEN_SOURCE=500. The following code ensures that ::clock_t is
// always defined and thus allows <string> to compile.
// This is just a workaround and should be monitored as compiler and
// operating system versions evolve.
# 28 "/scratch/condor/dir_19652/./RooStepBernstein.cxx" 2

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Riostream.h" 1
// @(#)root/base:$Id: Riostream.h 20877 2007-11-19 11:17:07Z rdm $
// Author: Fons Rademakers   23/1/02

/*************************************************************************
 * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/





//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Riostream                                                            //
//                                                                      //
// This headers is only supposed to be used in implementation files.    //
// Never in headers, since it has "using namespace std".                //
// In headers use the companion Riosfwd.h.                              //
//                                                                      //
//////////////////////////////////////////////////////////////////////////






# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/fstream" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/fstream.h" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
/*********************************************************************
* fstream.h
*
*********************************************************************/




# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iostream.h" 1
/* /% C++ %/ */
/***********************************************************************
 * cint (C/C++ interpreter)
 ************************************************************************
 * I/O stream header file iostream.h
 ************************************************************************
 * Description:
 *  CINT iostream header file
 ************************************************************************
 * Copyright(c) 1995~1999  Masaharu Goto 
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
# 17 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/fstream.h" 2
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/fstream" 2
}
# 32 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Riostream.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iostream" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iostream.h" 1
/* /% C++ %/ */
/***********************************************************************
 * cint (C/C++ interpreter)
 ************************************************************************
 * I/O stream header file iostream.h
 ************************************************************************
 * Description:
 *  CINT iostream header file
 ************************************************************************
 * Copyright(c) 1995~1999  Masaharu Goto 
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
# 11 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iostream" 2
}
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/_iostream" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// include/_iostream

std::ostream& operator<<(std::ostream& ostr,std::G__CINT_ENDL& i)
 {return(std::endl(ostr));}
std::ostream& operator<<(std::ostream& ostr,std::G__CINT_ENDS& i)
 {return(std::ends(ostr));}
std::ostream& operator<<(std::ostream& ostr,std::G__CINT_FLUSH& i)
 {return(std::flush(ostr));}

std::istream& operator>>(std::istream& istr,std::G__CINT_ws& i)
 {return(std::ws(istr));}
std::istream& operator>>(std::istream& istr,std::G__CINT_WS& i)
 {return(std::WS(istr));}


std::ostream& operator<<(std::ostream& ostr,std::G__CINT_IOFLAGS& f) {
   ostr.setf(f.flag, f.mask);
  return ostr;
}
std::istream& operator>>(std::istream& istr,std::G__CINT_IOFLAGS& f) {
  istr.setf(f.flag, f.mask);
  return istr;
}

std::ostream& operator<<(std::ostream& ostr,std::G__CINT_NOSUPPORT& i) {
  fprintf(stderr,"Limitation: dec,hex,oct manipurator not supported\n");
  return(ostr);
}
std::istream& operator<<(std::istream& istr,std::G__CINT_NOSUPPORT& i) {
  fprintf(stderr,"Limitation: dec,hex,oct manipurator not supported\n");
  return(istr);
}


std::ostream& operator<<(std::ostream& ostr,long long i) {
  char buf[200];
#pragma ifndef G__TMPLTIOS
  if (ostr.flags() & ios::hex)
#pragma else
  if (ostr.flags() & ios_base::hex)
#pragma endif
     sprintf(buf,"%llx",i);
  else
     sprintf(buf,"%lld",i);
  ostr << buf ;
  return(ostr);
}
std::ostream& operator<<(std::ostream& ostr,unsigned long long i) {
  char buf[200];
#pragma ifndef G__TMPLTIOS
  if (ostr.flags() & ios::hex)
#pragma else
  if (ostr.flags() & ios_base::hex)
#pragma endif
     sprintf(buf,"%llx",i);
  else
     sprintf(buf,"%llu",i);
  ostr << buf ;
  return(ostr);
}
std::ostream& operator<<(std::ostream& ostr,long double i) {
  char buf[200];
  sprintf(buf,"%Lg",i);
  ostr << buf ;
  return(ostr);
}
std::istream& operator>>(std::istream& istr,long long &i) {
  char buf[200];
  istr >> buf ;
  sscanf(buf,"%lld",&i);
  return(istr);
}
std::istream& operator>>(std::istream& istr,unsigned long long &i) {
  char buf[200];
  istr >> buf ;
#pragma ifndef G__TMPLTIOS
  if (ostr.flags() & ios::hex)
#pragma else
  if (ostr.flags() & ios_base::hex)
#pragma endif
     sscanf(buf,"%llx",&i);
  else
     sscanf(buf,"%llu",&i);
  return(istr);
}
std::istream& operator>>(std::istream& istr,long double &i) {
  char buf[200];
  istr >> buf ;
  sscanf(buf,"%Lg",&i);
  return(istr);
}


// Value evaluation
//template<class T> int G__ateval(const T* x) {return(0);}
//template<class T> int G__ateval(const T& x) {return(0);}
int G__ateval(const char* const &x) {return(0);}
//int G__ateval(const void* const &x) {return(0);}
int G__ateval(double x) {return(0);}
int G__ateval(float x) {return(0);}
int G__ateval(bool x) {return(0);}
int G__ateval(char x) {return(0);}
int G__ateval(short x) {return(0);}
int G__ateval(int x) {return(0);}
int G__ateval(long x) {return(0);}
int G__ateval(unsigned char x) {return(0);}
int G__ateval(unsigned short x) {return(0);}
int G__ateval(unsigned int x) {return(0);}
int G__ateval(unsigned long x) {return(0);}
# 127 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/_iostream"
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iomanip.h" 1
/* /% C++ %/ */
/***********************************************************************
 * cint (C/C++ interpreter)
 ************************************************************************
 * I/O manipulator header for iomanip.h
 ************************************************************************
 * Description:
 *  CINT IOMANIP header file
 ************************************************************************
 * Author                  Masaharu Goto 
 * Copyright(c) 1995~1999  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
# 127 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/_iostream" 2
# 12 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iostream" 2
# 33 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Riostream.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iomanip" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iomanip.h" 1
/* /% C++ %/ */
/***********************************************************************
 * cint (C/C++ interpreter)
 ************************************************************************
 * I/O manipulator header for iomanip.h
 ************************************************************************
 * Description:
 *  CINT IOMANIP header file
 ************************************************************************
 * Author                  Masaharu Goto 
 * Copyright(c) 1995~1999  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/iomanip" 2
}
# 34 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Riostream.h" 2
    using namespace std;
# 30 "/scratch/condor/dir_19652/./RooStepBernstein.cxx" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Riostream.h" 1
// @(#)root/base:$Id: Riostream.h 20877 2007-11-19 11:17:07Z rdm $
// Author: Fons Rademakers   23/1/02

/*************************************************************************
 * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 31 "/scratch/condor/dir_19652/./RooStepBernstein.cxx" 2

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TMath.h" 1
// @(#)root/mathcore:$Id: TMath.h 41837 2011-11-09 16:04:19Z rdm $
// Authors: Rene Brun, Anna Kreshuk, Eddy Offermann, Fons Rademakers   29/07/95

/*************************************************************************
 * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/





//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TMath                                                                //
//                                                                      //
// Encapsulate most frequently used Math functions.                     //
// NB. The basic functions Min, Max, Abs and Sign are defined           //
// in TMathBase.                                                        //
//                                                                      //
//////////////////////////////////////////////////////////////////////////
# 33 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TMath.h"
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TError.h" 1
// @(#)root/base:$Id: TError.h 38832 2011-04-13 17:54:49Z rdm $
// Author: Fons Rademakers   29/07/95

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/





//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Error handling routines.                                             //
//                                                                      //
// This file defines a number of global error handling routines:        //
// Warning(), Error(), SysError() and Fatal(). They all take a          //
// location string (where the error happened) and a printf style format //
// string plus vararg's. In the end these functions call an             //
// errorhanlder function. By default DefaultErrorHandler() is used.     //
//                                                                      //
//////////////////////////////////////////////////////////////////////////





# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/stdarg.h" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
/****************************************************************
* stdarg.h
*****************************************************************/
# 33 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TError.h" 2


class TVirtualMutex;

const Int_t kUnset = -1;
const Int_t kPrint = 0;
const Int_t kInfo = 1000;
const Int_t kWarning = 2000;
const Int_t kError = 3000;
const Int_t kBreak = 4000;
const Int_t kSysError = 5000;
const Int_t kFatal = 6000;

extern TVirtualMutex *gErrorMutex;

typedef void (*ErrorHandlerFunc_t)(int level, Bool_t abort, const char *location,
              const char *msg);

extern "C" void ErrorHandler(int level, const char *location, const char *fmt,
                             va_list va);

extern void DefaultErrorHandler(int level, Bool_t abort, const char *location,
                                const char *msg);

extern ErrorHandlerFunc_t SetErrorHandler(ErrorHandlerFunc_t newhandler);
extern ErrorHandlerFunc_t GetErrorHandler();

extern void Info(const char *location, const char *msgfmt, ...)



;
extern void Warning(const char *location, const char *msgfmt, ...)



;
extern void Error(const char *location, const char *msgfmt, ...)



;
extern void Break(const char *location, const char *msgfmt, ...)



;
extern void SysError(const char *location, const char *msgfmt, ...)



;
extern void Fatal(const char *location, const char *msgfmt, ...)



;

extern void AbstractMethod(const char *method);
extern void MayNotUse(const char *method);
extern void Obsolete(const char *function, const char *asOfVers, const char *removedFromVers);

extern const char *kAssertMsg;
extern const char *kCheckMsg;
# 107 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TError.h"
extern Int_t gErrorIgnoreLevel;
extern Int_t gErrorAbortLevel;
extern Bool_t gPrintViaErrorHandler;
# 34 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TMath.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/algorithm" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_algorithm" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

#pragma include_noerr <algorithm.dll>



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/algorithm" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/algorithm

#pragma ifndef PREC_STL_ALGORITHM
#pragma define PREC_STL_ALGORITHM
#pragma link off global PREC_STL_ALGORITHM;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

template <class BidirectionalIterator>
inline void reverse(BidirectionalIterator first, BidirectionalIterator last) {}

// Generic algorithms can not be precompiled

#pragma endif
# 14 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/_algorithm" 2
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/stl/algorithm" 2
}
# 35 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TMath.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/limits" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/

# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/lib/prec_stl/limits" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
// lib/prec_stl/limits

#pragma ifndef PREC_STL_LIMITS
#pragma define PREC_STL_LIMITS
#pragma link off global PREC_STL_LIMITS;
#pragma link C++ nestedtypedef;
#pragma link C++ nestedclass;

// to be implemented

#pragma endif
# 10 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/limits" 2
# 36 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TMath.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/cmath" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
namespace std {

#pragma include_noerr <stdcxxfunc.dll>
}
# 37 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TMath.h" 2

namespace TMath {

   /* ************************* */
   /* * Fundamental constants * */
   /* ************************* */

   inline Double_t Pi() { return 3.14159265358979323846; }
   inline Double_t TwoPi() { return 2.0 * Pi(); }
   inline Double_t PiOver2() { return Pi() / 2.0; }
   inline Double_t PiOver4() { return Pi() / 4.0; }
   inline Double_t InvPi() { return 1.0 / Pi(); }
   inline Double_t RadToDeg() { return 180.0 / Pi(); }
   inline Double_t DegToRad() { return Pi() / 180.0; }
   inline Double_t Sqrt2() { return 1.4142135623730950488016887242097; }

   // e (base of natural log)
   inline Double_t E() { return 2.71828182845904523536; }

   // natural log of 10 (to convert log to ln)
   inline Double_t Ln10() { return 2.30258509299404568402; }

   // base-10 log of e  (to convert ln to log)
   inline Double_t LogE() { return 0.43429448190325182765; }

   // velocity of light
   inline Double_t C() { return 2.99792458e8; } // m s^-1
   inline Double_t Ccgs() { return 100.0 * C(); } // cm s^-1
   inline Double_t CUncertainty() { return 0.0; } // exact

   // gravitational constant
   inline Double_t G() { return 6.673e-11; } // m^3 kg^-1 s^-2
   inline Double_t Gcgs() { return G() / 1000.0; } // cm^3 g^-1 s^-2
   inline Double_t GUncertainty() { return 0.010e-11; }

   // G over h-bar C
   inline Double_t GhbarC() { return 6.707e-39; } // (GeV/c^2)^-2
   inline Double_t GhbarCUncertainty() { return 0.010e-39; }

   // standard acceleration of gravity
   inline Double_t Gn() { return 9.80665; } // m s^-2
   inline Double_t GnUncertainty() { return 0.0; } // exact

   // Planck's constant
   inline Double_t H() { return 6.62606876e-34; } // J s
   inline Double_t Hcgs() { return 1.0e7 * H(); } // erg s
   inline Double_t HUncertainty() { return 0.00000052e-34; }

   // h-bar (h over 2 pi)
   inline Double_t Hbar() { return 1.054571596e-34; } // J s
   inline Double_t Hbarcgs() { return 1.0e7 * Hbar(); } // erg s
   inline Double_t HbarUncertainty() { return 0.000000082e-34; }

   // hc (h * c)
   inline Double_t HC() { return H() * C(); } // J m
   inline Double_t HCcgs() { return Hcgs() * Ccgs(); } // erg cm

   // Boltzmann's constant
   inline Double_t K() { return 1.3806503e-23; } // J K^-1
   inline Double_t Kcgs() { return 1.0e7 * K(); } // erg K^-1
   inline Double_t KUncertainty() { return 0.0000024e-23; }

   // Stefan-Boltzmann constant
   inline Double_t Sigma() { return 5.6704e-8; } // W m^-2 K^-4
   inline Double_t SigmaUncertainty() { return 0.000040e-8; }

   // Avogadro constant (Avogadro's Number)
   inline Double_t Na() { return 6.02214199e+23; } // mol^-1
   inline Double_t NaUncertainty() { return 0.00000047e+23; }

   // universal gas constant (Na * K)
   // http://scienceworld.wolfram.com/physics/UniversalGasConstant.html
   inline Double_t R() { return K() * Na(); } // J K^-1 mol^-1
   inline Double_t RUncertainty() { return R()*((KUncertainty()/K()) + (NaUncertainty()/Na())); }

   // Molecular weight of dry air
   // 1976 US Standard Atmosphere,
   // also see http://atmos.nmsu.edu/jsdap/encyclopediawork.html
   inline Double_t MWair() { return 28.9644; } // kg kmol^-1 (or gm mol^-1)

   // Dry Air Gas Constant (R / MWair)
   // http://atmos.nmsu.edu/education_and_outreach/encyclopedia/gas_constant.htm
   inline Double_t Rgair() { return (1000.0 * R()) / MWair(); } // J kg^-1 K^-1

   // Euler-Mascheroni Constant
   inline Double_t EulerGamma() { return 0.577215664901532860606512090082402431042; }

   // Elementary charge
   inline Double_t Qe() { return 1.602176462e-19; } // C
   inline Double_t QeUncertainty() { return 0.000000063e-19; }

   /* ************************** */
   /* * Mathematical Functions * */
   /* ************************** */

   /* ***************************** */
   /* * Trigonometrical Functions * */
   /* ***************************** */
   inline Double_t Sin(Double_t);
   inline Double_t Cos(Double_t);
   inline Double_t Tan(Double_t);
   inline Double_t SinH(Double_t);
   inline Double_t CosH(Double_t);
   inline Double_t TanH(Double_t);
   inline Double_t ASin(Double_t);
   inline Double_t ACos(Double_t);
   inline Double_t ATan(Double_t);
   inline Double_t ATan2(Double_t, Double_t);
          Double_t ASinH(Double_t);
          Double_t ACosH(Double_t);
          Double_t ATanH(Double_t);
          Double_t Hypot(Double_t x, Double_t y);


   /* ************************ */
   /* * Elementary Functions * */
   /* ************************ */
   inline Double_t Sqrt(Double_t x);
   inline Double_t Ceil(Double_t x);
   inline Int_t CeilNint(Double_t x);
   inline Double_t Floor(Double_t x);
   inline Int_t FloorNint(Double_t x);
   inline Double_t Exp(Double_t x);
   inline Double_t Ldexp(Double_t x, Int_t exp);
          Double_t Factorial(Int_t i);
   inline Double_t Power(Double_t x, Double_t y);
   inline Double_t Power(Double_t x, Int_t y);
   inline Double_t Log(Double_t x);
          Double_t Log2(Double_t x);
   inline Double_t Log10(Double_t x);
          Int_t Nint(Float_t x);
          Int_t Nint(Double_t x);
   inline Int_t Finite(Double_t x);
   inline Int_t IsNaN(Double_t x);

   inline Double_t QuietNaN();
   inline Double_t SignalingNaN();
   inline Double_t Infinity();

   template <typename T>
   struct Limits {
      inline static T Min();
      inline static T Max();
      inline static T Epsilon();
   };

   // Some integer math
   Long_t Hypot(Long_t x, Long_t y); // sqrt(px*px + py*py)

   // Comparing floating points
   inline Bool_t AreEqualAbs(Double_t af, Double_t bf, Double_t epsilon) {
      //return kTRUE if absolute difference between af and bf is less than epsilon
      return TMath::Abs(af-bf) < epsilon;
   }
   inline Bool_t AreEqualRel(Double_t af, Double_t bf, Double_t relPrec) {
      //return kTRUE if relative difference between af and bf is less than relPrec
      return TMath::Abs(af-bf) <= 0.5*relPrec*(TMath::Abs(af)+TMath::Abs(bf));
   }

   /* ******************** */
   /* * Array Algorithms * */
   /* ******************** */

   // Min, Max of an array
   template <typename T> T MinElement(Long64_t n, const T *a);
   template <typename T> T MaxElement(Long64_t n, const T *a);

   // Locate Min, Max element number in an array
   template <typename T> Long64_t LocMin(Long64_t n, const T *a);
   template <typename Iterator> Iterator LocMin(Iterator first, Iterator last);
   template <typename T> Long64_t LocMax(Long64_t n, const T *a);
   template <typename Iterator> Iterator LocMax(Iterator first, Iterator last);

   // Binary search
   template <typename T> Long64_t BinarySearch(Long64_t n, const T *array, T value);
   template <typename T> Long64_t BinarySearch(Long64_t n, const T **array, T value);
   template <typename Iterator, typename Element> Iterator BinarySearch(Iterator first, Iterator last, Element value);

   // Hashing
   ULong_t Hash(const void *txt, Int_t ntxt);
   ULong_t Hash(const char *str);

   // Sorting
   template <typename Element, typename Index>
   void Sort(Index n, const Element* a, Index* index, Bool_t down=kTRUE);
   template <typename Iterator, typename IndexIterator>
   void SortItr(Iterator first, Iterator last, IndexIterator index, Bool_t down=kTRUE);

   void BubbleHigh(Int_t Narr, Double_t *arr1, Int_t *arr2);
   void BubbleLow (Int_t Narr, Double_t *arr1, Int_t *arr2);

   Bool_t Permute(Int_t n, Int_t *a); // Find permutations

   /* ************************* */
   /* * Geometrical Functions * */
   /* ************************* */

   //Sample quantiles
   void Quantiles(Int_t n, Int_t nprob, Double_t *x, Double_t *quantiles, Double_t *prob,
                       Bool_t isSorted=kTRUE, Int_t *index = 0, Int_t type=7);

   // IsInside
   template <typename T> Bool_t IsInside(T xp, T yp, Int_t np, T *x, T *y);

   // Calculate the Cross Product of two vectors
   template <typename T> T *Cross(const T v1[3],const T v2[3], T out[3]);

   Float_t Normalize(Float_t v[3]); // Normalize a vector
   Double_t Normalize(Double_t v[3]); // Normalize a vector

   //Calculate the Normalized Cross Product of two vectors
   template <typename T> inline T NormCross(const T v1[3],const T v2[3],T out[3]);

   // Calculate a normal vector of a plane
   template <typename T> T *Normal2Plane(const T v1[3],const T v2[3],const T v3[3], T normal[3]);

   /* ************************ */
   /* * Polynomial Functions * */
   /* ************************ */

   Bool_t RootsCubic(const Double_t coef[4],Double_t &a, Double_t &b, Double_t &c);

   /* *********************** */
   /* * Statistic Functions * */
   /* *********************** */

   Double_t Binomial(Int_t n,Int_t k); // Calculate the binomial coefficient n over k
   Double_t BinomialI(Double_t p, Int_t n, Int_t k);
   Double_t BreitWigner(Double_t x, Double_t mean=0, Double_t gamma=1);
   Double_t CauchyDist(Double_t x, Double_t t=0, Double_t s=1);
   Double_t ChisquareQuantile(Double_t p, Double_t ndf);
   Double_t FDist(Double_t F, Double_t N, Double_t M);
   Double_t FDistI(Double_t F, Double_t N, Double_t M);
   Double_t Gaus(Double_t x, Double_t mean=0, Double_t sigma=1, Bool_t norm=kFALSE);
   Double_t KolmogorovProb(Double_t z);
   Double_t KolmogorovTest(Int_t na, const Double_t *a, Int_t nb, const Double_t *b, Option_t *option);
   Double_t Landau(Double_t x, Double_t mpv=0, Double_t sigma=1, Bool_t norm=kFALSE);
   Double_t LandauI(Double_t x);
   Double_t LaplaceDist(Double_t x, Double_t alpha=0, Double_t beta=1);
   Double_t LaplaceDistI(Double_t x, Double_t alpha=0, Double_t beta=1);
   Double_t LogNormal(Double_t x, Double_t sigma, Double_t theta=0, Double_t m=1);
   Double_t NormQuantile(Double_t p);
   Double_t Poisson(Double_t x, Double_t par);
   Double_t PoissonI(Double_t x, Double_t par);
   Double_t Prob(Double_t chi2,Int_t ndf);
   Double_t Student(Double_t T, Double_t ndf);
   Double_t StudentI(Double_t T, Double_t ndf);
   Double_t StudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail=kTRUE);
   Double_t Vavilov(Double_t x, Double_t kappa, Double_t beta2);
   Double_t VavilovI(Double_t x, Double_t kappa, Double_t beta2);
   Double_t Voigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4);

   /* ************************** */
   /* * Statistics over arrays * */
   /* ************************** */

   //Mean, Geometric Mean, Median, RMS(sigma)

   template <typename T> Double_t Mean(Long64_t n, const T *a, const Double_t *w=0);
   template <typename Iterator> Double_t Mean(Iterator first, Iterator last);
   template <typename Iterator, typename WeightIterator> Double_t Mean(Iterator first, Iterator last, WeightIterator w);

   template <typename T> Double_t GeomMean(Long64_t n, const T *a);
   template <typename Iterator> Double_t GeomMean(Iterator first, Iterator last);

   template <typename T> Double_t RMS(Long64_t n, const T *a);
   template <typename Iterator> Double_t RMS(Iterator first, Iterator last);

   template <typename T> Double_t Median(Long64_t n, const T *a, const Double_t *w=0, Long64_t *work=0);

   //k-th order statistic
   template <class Element, typename Size> Element KOrdStat(Size n, const Element *a, Size k, Size *work = 0);

   /* ******************* */
   /* * Special Functions */
   /* ******************* */

   Double_t Beta(Double_t p, Double_t q);
   Double_t BetaCf(Double_t x, Double_t a, Double_t b);
   Double_t BetaDist(Double_t x, Double_t p, Double_t q);
   Double_t BetaDistI(Double_t x, Double_t p, Double_t q);
   Double_t BetaIncomplete(Double_t x, Double_t a, Double_t b);

   // Bessel functions
   Double_t BesselI(Int_t n,Double_t x); // integer order modified Bessel function I_n(x)
   Double_t BesselK(Int_t n,Double_t x); // integer order modified Bessel function K_n(x)
   Double_t BesselI0(Double_t x); // modified Bessel function I_0(x)
   Double_t BesselK0(Double_t x); // modified Bessel function K_0(x)
   Double_t BesselI1(Double_t x); // modified Bessel function I_1(x)
   Double_t BesselK1(Double_t x); // modified Bessel function K_1(x)
   Double_t BesselJ0(Double_t x); // Bessel function J0(x) for any real x
   Double_t BesselJ1(Double_t x); // Bessel function J1(x) for any real x
   Double_t BesselY0(Double_t x); // Bessel function Y0(x) for positive x
   Double_t BesselY1(Double_t x); // Bessel function Y1(x) for positive x
   Double_t StruveH0(Double_t x); // Struve functions of order 0
   Double_t StruveH1(Double_t x); // Struve functions of order 1
   Double_t StruveL0(Double_t x); // Modified Struve functions of order 0
   Double_t StruveL1(Double_t x); // Modified Struve functions of order 1

   Double_t DiLog(Double_t x);
   Double_t Erf(Double_t x);
   Double_t ErfInverse(Double_t x);
   Double_t Erfc(Double_t x);
   Double_t ErfcInverse(Double_t x);
   Double_t Freq(Double_t x);
   Double_t Gamma(Double_t z);
   Double_t Gamma(Double_t a,Double_t x);
   Double_t GammaDist(Double_t x, Double_t gamma, Double_t mu=0, Double_t beta=1);
   Double_t LnGamma(Double_t z);
}


//---- Trig and other functions ------------------------------------------------
# 362 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TMath.h"
// math functions are defined inline so we have to include them here




// #   if defined(R__GLIBC) && defined(__STRICT_ANSI__)
// #      ifndef finite
// #         define finite __finite
// #      endif
// #      ifndef isnan
// #         define isnan  __isnan
// #      endif
// #   endif
# 411 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TMath.h"
inline Double_t TMath::Sin(Double_t x)
   { return sin(x); }

inline Double_t TMath::Cos(Double_t x)
   { return cos(x); }

inline Double_t TMath::Tan(Double_t x)
   { return tan(x); }

inline Double_t TMath::SinH(Double_t x)
   { return sinh(x); }

inline Double_t TMath::CosH(Double_t x)
   { return cosh(x); }

inline Double_t TMath::TanH(Double_t x)
   { return tanh(x); }

inline Double_t TMath::ASin(Double_t x)
   { if (x < -1.) return -TMath::Pi()/2;
     if (x > 1.) return TMath::Pi()/2;
     return asin(x);
   }

inline Double_t TMath::ACos(Double_t x)
   { if (x < -1.) return TMath::Pi();
     if (x > 1.) return 0;
     return acos(x);
   }

inline Double_t TMath::ATan(Double_t x)
   { return atan(x); }

inline Double_t TMath::ATan2(Double_t y, Double_t x)
   { if (x != 0) return atan2(y, x);
     if (y == 0) return 0;
     if (y > 0) return Pi()/2;
     else return -Pi()/2;
   }

inline Double_t TMath::Sqrt(Double_t x)
   { return sqrt(x); }

inline Double_t TMath::Ceil(Double_t x)
   { return ceil(x); }

inline Int_t TMath::CeilNint(Double_t x)
   { return TMath::Nint(ceil(x)); }

inline Double_t TMath::Floor(Double_t x)
   { return floor(x); }

inline Int_t TMath::FloorNint(Double_t x)
   { return TMath::Nint(floor(x)); }

inline Double_t TMath::Exp(Double_t x)
   { return exp(x); }

inline Double_t TMath::Ldexp(Double_t x, Int_t exp)
   { return ldexp(x, exp); }

inline Double_t TMath::Power(Double_t x, Double_t y)
   { return pow(x, y); }

inline Double_t TMath::Power(Double_t x, Int_t y) {

   return std::pow(x, y);



}

inline Double_t TMath::Log(Double_t x)
   { return log(x); }

inline Double_t TMath::Log10(Double_t x)
   { return log10(x); }

inline Int_t TMath::Finite(Double_t x)
# 501 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TMath.h"
   { return finite(x); }


inline Int_t TMath::IsNaN(Double_t x)





   // from cmath
   { return std::isnan(x); }





//--------wrapper to numeric_limits
//____________________________________________________________________________
inline Double_t TMath::QuietNaN() {
   // returns a quiet NaN as defined by IEEE 754 
   // see http://en.wikipedia.org/wiki/NaN#Quiet_NaN
   return std::numeric_limits<Double_t>::quiet_NaN();
}

//____________________________________________________________________________
inline Double_t TMath::SignalingNaN() {
   // returns a signaling NaN as defined by IEEE 754 
   // see http://en.wikipedia.org/wiki/NaN#Signaling_NaN
   return std::numeric_limits<Double_t>::signaling_NaN();
}

inline Double_t TMath::Infinity() {
   // returns an infinity as defined by the IEEE standard
   return std::numeric_limits<Double_t>::infinity();
}

template<typename T>
inline T TMath::Limits<T>::Min() {
   // returns maximum representation for type T
   return (std::numeric_limits<T>::min)(); //N.B. use this signature to avoid class with macro min() on Windows 
}

template<typename T>
inline T TMath::Limits<T>::Max() {
   // returns minimum double representation
   return (std::numeric_limits<T>::max)(); //N.B. use this signature to avoid class with macro max() on Windows 
}

template<typename T>
inline T TMath::Limits<T>::Epsilon() {
   // returns minimum double representation
   return std::numeric_limits<T>::epsilon();
}


//-------- Advanced -------------

template <typename T> inline T TMath::NormCross(const T v1[3],const T v2[3],T out[3])
{
   // Calculate the Normalized Cross Product of two vectors
   return Normalize(Cross(v1,v2,out));
}

template <typename T>
T TMath::MinElement(Long64_t n, const T *a) {
   // Return minimum of array a of length n.

   return *std::min_element(a,a+n);
}

template <typename T>
T TMath::MaxElement(Long64_t n, const T *a) {
   // Return maximum of array a of length n.

   return *std::max_element(a,a+n);
}

template <typename T>
Long64_t TMath::LocMin(Long64_t n, const T *a) {
   // Return index of array with the minimum element.
   // If more than one element is minimum returns first found.

   // Implement here since this one is found to be faster (mainly on 64 bit machines)
   // than stl generic implementation.
   // When performing the comparison,  the STL implementation needs to de-reference both the array iterator
   // and the iterator pointing to the resulting minimum location

   if (n <= 0 || !a) return -1;
   T xmin = a[0];
   Long64_t loc = 0;
   for (Long64_t i = 1; i < n; i++) {
      if (xmin > a[i]) {
         xmin = a[i];
         loc = i;
      }
   }
   return loc;
}

template <typename Iterator>
Iterator TMath::LocMin(Iterator first, Iterator last) {
   // Return index of array with the minimum element.
   // If more than one element is minimum returns first found.
   return std::min_element(first, last);
}

template <typename T>
Long64_t TMath::LocMax(Long64_t n, const T *a) {
   // Return index of array with the maximum element.
   // If more than one element is maximum returns first found.

   // Implement here since it is faster (see comment in LocMin function)

   if (n <= 0 || !a) return -1;
   T xmax = a[0];
   Long64_t loc = 0;
   for (Long64_t i = 1; i < n; i++) {
      if (xmax < a[i]) {
         xmax = a[i];
         loc = i;
      }
   }
   return loc;
}

template <typename Iterator>
Iterator TMath::LocMax(Iterator first, Iterator last)
{
   // Return index of array with the maximum element.
   // If more than one element is maximum returns first found.

   return std::max_element(first, last);
}

template<typename T>
struct CompareDesc {

   CompareDesc(T d) : fData(d) {}

   template<typename Index>
   bool operator()(Index i1, Index i2) {
      return *(fData + i1) > *(fData + i2);
   }

   T fData;
};

template<typename T>
struct CompareAsc {

   CompareAsc(T d) : fData(d) {}

   template<typename Index>
   bool operator()(Index i1, Index i2) {
      return *(fData + i1) < *(fData + i2);
   }

   T fData;
};

template <typename Iterator>
Double_t TMath::Mean(Iterator first, Iterator last)
{
   // Return the weighted mean of an array defined by the iterators.

   Double_t sum = 0;
   Double_t sumw = 0;
   while ( first != last )
   {
      sum += *first;
      sumw += 1;
      first++;
   }

   return sum/sumw;
}

template <typename Iterator, typename WeightIterator>
Double_t TMath::Mean(Iterator first, Iterator last, WeightIterator w)
{
   // Return the weighted mean of an array defined by the first and
   // last iterators. The w iterator should point to the first element
   // of a vector of weights of the same size as the main array.

   Double_t sum = 0;
   Double_t sumw = 0;
   int i = 0;
   while ( first != last ) {
      if ( *w < 0) {
         ::Error("TMath::Mean","w[%d] = %.4e < 0 ?!",i,*w);
         return 0;
      }
      sum += (*w) * (*first);
      sumw += (*w) ;
      ++w;
      ++first;
      ++i;
   }
   if (sumw <= 0) {
      ::Error("TMath::Mean","sum of weights == 0 ?!");
      return 0;
   }

   return sum/sumw;
}

template <typename T>
Double_t TMath::Mean(Long64_t n, const T *a, const Double_t *w)
{
   // Return the weighted mean of an array a with length n.

   if (w) {
      return TMath::Mean(a, a+n, w);
   } else {
      return TMath::Mean(a, a+n);
   }
}

template <typename Iterator>
Double_t TMath::GeomMean(Iterator first, Iterator last)
{
   // Return the geometric mean of an array defined by the iterators.
   // geometric_mean = (Prod_i=0,n-1 |a[i]|)^1/n

   Double_t logsum = 0.;
   Long64_t n = 0;
   while ( first != last ) {
      if (*first == 0) return 0.;
      Double_t absa = (Double_t) TMath::Abs(*first);
      logsum += TMath::Log(absa);
      ++first;
      ++n;
   }

   return TMath::Exp(logsum/n);
}

template <typename T>
Double_t TMath::GeomMean(Long64_t n, const T *a)
{
   // Return the geometric mean of an array a of size n.
   // geometric_mean = (Prod_i=0,n-1 |a[i]|)^1/n

   return TMath::GeomMean(a, a+n);
}

template <typename Iterator>
Double_t TMath::RMS(Iterator first, Iterator last)
{
   // Return the Standard Deviation of an array defined by the iterators.
   // Note that this function returns the sigma(standard deviation) and
   // not the root mean square of the array.

   Double_t n = 0;

   Double_t tot = 0, tot2 =0, adouble;
   while ( first != last ) {
      adouble=Double_t(*first);
      tot += adouble; tot2 += adouble*adouble;
      ++first;
      ++n;
   }
   Double_t n1 = 1./n;
   Double_t mean = tot*n1;
   Double_t rms = TMath::Sqrt(TMath::Abs(tot2*n1 -mean*mean));
   return rms;
}

template <typename T>
Double_t TMath::RMS(Long64_t n, const T *a)
{
   // Return the Standard Deviation of an array a with length n.
   // Note that this function returns the sigma(standard deviation) and
   // not the root mean square of the array.

   return TMath::RMS(a, a+n);
}

template <typename Iterator, typename Element>
Iterator TMath::BinarySearch(Iterator first, Iterator last, Element value)
{
   // Binary search in an array defined by its iterators.
   //
   // The values in the iterators range are supposed to be sorted
   // prior to this call.  If match is found, function returns
   // position of element.  If no match found, function gives nearest
   // element smaller than value.

   Iterator pind;
   pind = std::lower_bound(first, last, value);
   if ( (pind != last) && (*pind == value) )
      return pind;
   else
      return ( pind - 1);
}


template <typename T> Long64_t TMath::BinarySearch(Long64_t n, const T *array, T value)
{
   // Binary search in an array of n values to locate value.
   //
   // Array is supposed  to be sorted prior to this call.
   // If match is found, function returns position of element.
   // If no match found, function gives nearest element smaller than value.

   const T* pind;
   pind = std::lower_bound(array, array + n, value);
   if ( (pind != array + n) && (*pind == value) )
      return (pind - array);
   else
      return ( pind - array - 1);
}

template <typename T> Long64_t TMath::BinarySearch(Long64_t n, const T **array, T value)
{
   // Binary search in an array of n values to locate value.
   //
   // Array is supposed  to be sorted prior to this call.
   // If match is found, function returns position of element.
   // If no match found, function gives nearest element smaller than value.

   const T* pind;
   pind = std::lower_bound(*array, *array + n, value);
   if ( (pind != *array + n) && (*pind == value) )
      return (pind - *array);
   else
      return ( pind - *array - 1);
}

template <typename Iterator, typename IndexIterator>
void TMath::SortItr(Iterator first, Iterator last, IndexIterator index, Bool_t down)
{
   // Sort the n1 elements of the Short_t array defined by its
   // iterators.  In output the array index contains the indices of
   // the sorted array.  If down is false sort in increasing order
   // (default is decreasing order).

   // NOTE that the array index must be created with a length bigger
   // or equal than the main array before calling this function.

   int i = 0;

   IndexIterator cindex = index;
   for ( Iterator cfirst = first; cfirst != last; ++cfirst )
   {
      *cindex = i++;
      ++cindex;
   }

   if ( down )
      std::sort(index, cindex, CompareDesc<Iterator>(first) );
   else
      std::sort(index, cindex, CompareAsc<Iterator>(first) );
}

template <typename Element, typename Index> void TMath::Sort(Index n, const Element* a, Index* index, Bool_t down)
{
   // Sort the n elements of the  array a of generic templated type Element.
   // In output the array index of type Index contains the indices of the sorted array.
   // If down is false sort in increasing order (default is decreasing order).

   // NOTE that the array index must be created with a length >= n
   // before calling this function.
   // NOTE also that the size type for n must be the same type used for the index array
   // (templated type Index)

   for(Index i = 0; i < n; i++) { index[i] = i; }
   if ( down )
      std::sort(index, index + n, CompareDesc<const Element*>(a) );
   else
      std::sort(index, index + n, CompareAsc<const Element*>(a) );
}

template <typename T> T *TMath::Cross(const T v1[3],const T v2[3], T out[3])
{
   // Calculate the Cross Product of two vectors:
   //         out = [v1 x v2]

   out[0] = v1[1] * v2[2] - v1[2] * v2[1];
   out[1] = v1[2] * v2[0] - v1[0] * v2[2];
   out[2] = v1[0] * v2[1] - v1[1] * v2[0];

   return out;
}

template <typename T> T * TMath::Normal2Plane(const T p1[3],const T p2[3],const T p3[3], T normal[3])
{
   // Calculate a normal vector of a plane.
   //
   //  Input:
   //     Float_t *p1,*p2,*p3  -  3 3D points belonged the plane to define it.
   //
   //  Return:
   //     Pointer to 3D normal vector (normalized)

   T v1[3], v2[3];

   v1[0] = p2[0] - p1[0];
   v1[1] = p2[1] - p1[1];
   v1[2] = p2[2] - p1[2];

   v2[0] = p3[0] - p1[0];
   v2[1] = p3[1] - p1[1];
   v2[2] = p3[2] - p1[2];

   NormCross(v1,v2,normal);
   return normal;
}

template <typename T> Bool_t TMath::IsInside(T xp, T yp, Int_t np, T *x, T *y)
{
   // Function which returns kTRUE if point xp,yp lies inside the
   // polygon defined by the np points in arrays x and y, kFALSE otherwise.
   // Note that the polygon may be open or closed.

   Int_t i, j = np-1 ;
   Bool_t oddNodes = kFALSE;

   for (i=0; i<np; i++) {
      if ((y[i]<yp && y[j]>=yp) || (y[j]<yp && y[i]>=yp)) {
         if (x[i]+(yp-y[i])/(y[j]-y[i])*(x[j]-x[i])<xp) {
            oddNodes = !oddNodes;
         }
      }
      j=i;
   }

   return oddNodes;
}

template <typename T> Double_t TMath::Median(Long64_t n, const T *a, const Double_t *w, Long64_t *work)
{
   // Return the median of the array a where each entry i has weight w[i] .
   // Both arrays have a length of at least n . The median is a number obtained
   // from the sorted array a through
   //
   // median = (a[jl]+a[jh])/2.  where (using also the sorted index on the array w)
   //
   // sum_i=0,jl w[i] <= sumTot/2
   // sum_i=0,jh w[i] >= sumTot/2
   // sumTot = sum_i=0,n w[i]
   //
   // If w=0, the algorithm defaults to the median definition where it is
   // a number that divides the sorted sequence into 2 halves.
   // When n is odd or n > 1000, the median is kth element k = (n + 1) / 2.
   // when n is even and n < 1000the median is a mean of the elements k = n/2 and k = n/2 + 1.
   //
   // If the weights are supplied (w not 0) all weights must be >= 0
   //
   // If work is supplied, it is used to store the sorting index and assumed to be
   // >= n . If work=0, local storage is used, either on the stack if n < kWorkMax
   // or on the heap for n >= kWorkMax .

   const Int_t kWorkMax = 100;

   if (n <= 0 || !a) return 0;
   Bool_t isAllocated = kFALSE;
   Double_t median;
   Long64_t *ind;
   Long64_t workLocal[kWorkMax];

   if (work) {
      ind = work;
   } else {
      ind = workLocal;
      if (n > kWorkMax) {
         isAllocated = kTRUE;
         ind = new Long64_t[n];
      }
   }

   if (w) {
      Double_t sumTot2 = 0;
      for (Int_t j = 0; j < n; j++) {
         if (w[j] < 0) {
            ::Error("TMath::Median","w[%d] = %.4e < 0 ?!",j,w[j]);
            if (isAllocated) delete [] ind;
            return 0;
         }
         sumTot2 += w[j];
      }

      sumTot2 /= 2.;

      Sort(n, a, ind, kFALSE);

      Double_t sum = 0.;
      Int_t jl;
      for (jl = 0; jl < n; jl++) {
         sum += w[ind[jl]];
         if (sum >= sumTot2) break;
      }

      Int_t jh;
      sum = 2.*sumTot2;
      for (jh = n-1; jh >= 0; jh--) {
         sum -= w[ind[jh]];
         if (sum <= sumTot2) break;
      }

      median = 0.5*(a[ind[jl]]+a[ind[jh]]);

   } else {

      if (n%2 == 1)
         median = KOrdStat(n, a,n/2, ind);
      else {
         median = 0.5*(KOrdStat(n, a, n/2 -1, ind)+KOrdStat(n, a, n/2, ind));
      }
   }

   if (isAllocated)
      delete [] ind;
   return median;
}




template <class Element, typename Size>
Element TMath::KOrdStat(Size n, const Element *a, Size k, Size *work)
{
   // Returns k_th order statistic of the array a of size n
   // (k_th smallest element out of n elements).
   //
   // C-convention is used for array indexing, so if you want
   // the second smallest element, call KOrdStat(n, a, 1).
   //
   // If work is supplied, it is used to store the sorting index and
   // assumed to be >= n. If work=0, local storage is used, either on
   // the stack if n < kWorkMax or on the heap for n >= kWorkMax.
   // Note that the work index array will not contain the sorted indices but 
   // all indeces of the smaller element in arbitrary order in work[0,...,k-1] and 
   // all indeces of the larger element in arbitrary order in work[k+1,..,n-1]
   // work[k] will contain instead the index of the returned element.
   //
   // Taken from "Numerical Recipes in C++" without the index array
   // implemented by Anna Khreshuk.
   //
   // See also the declarations at the top of this file

   const Int_t kWorkMax = 100;

   typedef Size Index;

   Bool_t isAllocated = kFALSE;
   Size i, ir, j, l, mid;
   Index arr;
   Index *ind;
   Index workLocal[kWorkMax];
   Index temp;

   if (work) {
      ind = work;
   } else {
      ind = workLocal;
      if (n > kWorkMax) {
         isAllocated = kTRUE;
         ind = new Index[n];
      }
   }

   for (Size ii=0; ii<n; ii++) {
      ind[ii]=ii;
   }
   Size rk = k;
   l=0;
   ir = n-1;
   for(;;) {
      if (ir<=l+1) { //active partition contains 1 or 2 elements
         if (ir == l+1 && a[ind[ir]]<a[ind[l]])
            {temp = ind[l]; ind[l]=ind[ir]; ind[ir]=temp;}
         Element tmp = a[ind[rk]];
         if (isAllocated)
            delete [] ind;
         return tmp;
      } else {
         mid = (l+ir) >> 1; //choose median of left, center and right
         {temp = ind[mid]; ind[mid]=ind[l+1]; ind[l+1]=temp;}//elements as partitioning element arr.
         if (a[ind[l]]>a[ind[ir]]) //also rearrange so that a[l]<=a[l+1]
            {temp = ind[l]; ind[l]=ind[ir]; ind[ir]=temp;}

         if (a[ind[l+1]]>a[ind[ir]])
            {temp=ind[l+1]; ind[l+1]=ind[ir]; ind[ir]=temp;}

         if (a[ind[l]]>a[ind[l+1]])
            {temp = ind[l]; ind[l]=ind[l+1]; ind[l+1]=temp;}

         i=l+1; //initialize pointers for partitioning
         j=ir;
         arr = ind[l+1];
         for (;;){
            do i++; while (a[ind[i]]<a[arr]);
            do j--; while (a[ind[j]]>a[arr]);
            if (j<i) break; //pointers crossed, partitioning complete
               {temp=ind[i]; ind[i]=ind[j]; ind[j]=temp;}
         }
         ind[l+1]=ind[j];
         ind[j]=arr;
         if (j>=rk) ir = j-1; //keep active the partition that
         if (j<=rk) l=i; //contains the k_th element
      }
   }
}
# 33 "/scratch/condor/dir_19652/./RooStepBernstein.cxx" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsReal.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooAbsReal.h,v 1.75 2007/07/13 21:50:24 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 34 "/scratch/condor/dir_19652/./RooStepBernstein.cxx" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooRealVar.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooRealVar.h,v 1.54 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Riosfwd.h" 1
// @(#)root/base:$Id: Riosfwd.h 20877 2007-11-19 11:17:07Z rdm $
// Author: Fons Rademakers   23/1/02

/*************************************************************************
 * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooRealVar.h" 2


# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TString.h" 1
// @(#)root/base:$Id: TString.h 43133 2012-02-27 09:50:10Z rdm $
// Author: Fons Rademakers   04/08/95

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 23 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooRealVar.h" 2

# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsRealLValue.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooAbsRealLValue.h,v 1.37 2007/07/13 21:50:24 wouter Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 25 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooRealVar.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooUniformBinning.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooUniformBinning.h,v 1.10 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/Rtypes.h" 1
/* @(#)root/base:$Id: Rtypes.h 43708 2012-04-12 10:19:00Z axel $ */

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooUniformBinning.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooAbsBinning.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooAbsBinning.h,v 1.13 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooUniformBinning.h" 2
class TIterator ;

class RooUniformBinning : public RooAbsBinning {
public:

  RooUniformBinning(const char* name=0) ;
  RooUniformBinning(Double_t xlo, Double_t xhi, Int_t nBins, const char* name=0) ;
  RooUniformBinning(const RooUniformBinning& other, const char* name=0) ;
  RooAbsBinning* clone(const char* name=0) const { return new RooUniformBinning(*this,name?name:GetName()) ; }
  virtual ~RooUniformBinning() ;

  virtual void setRange(Double_t xlo, Double_t xhi) ;

  virtual Int_t numBoundaries() const { return _nbins + 1 ; }
  virtual Int_t binNumber(Double_t x) const ;
  virtual Bool_t isUniform() const { return kTRUE ; }

  virtual Double_t lowBound() const { return _xlo ; }
  virtual Double_t highBound() const { return _xhi ; }

  virtual Double_t binCenter(Int_t bin) const ;
  virtual Double_t binWidth(Int_t bin) const ;
  virtual Double_t binLow(Int_t bin) const ;
  virtual Double_t binHigh(Int_t bin) const ;

  virtual Double_t averageBinWidth() const { return _binw ; }
  virtual Double_t* array() const ;

protected:

  mutable Double_t* _array ; //! do not persist
  Double_t _xlo ;
  Double_t _xhi ;
  Int_t _nbins ;
  Double_t _binw ;


  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return RooUniformBinning::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooUniformBinning::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooUniformBinning.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 58; } // Uniform binning specification
};
# 26 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooRealVar.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooNumber.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooNumber.h,v 1.7 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 27 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooRealVar.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooSharedPropertiesList.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooSharedPropertiesList.h,v 1.2 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TObject.h" 1
// @(#)root/base:$Id: TObject.h 38832 2011-04-13 17:54:49Z rdm $
// Author: Rene Brun   26/12/94

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooSharedPropertiesList.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/cint/cint/include/assert.h" 1
/* -*- C++ -*- */
/*************************************************************************
 * Copyright(c) 1995~2005  Masaharu Goto (root-cint@cern.ch)
 *
 * For the licensing terms see the file COPYING
 *
 ************************************************************************/
/****************************************************************
* assert.h
*****************************************************************/
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooSharedPropertiesList.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooRefCountList.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooRefCountList.h,v 1.7 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 22 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooSharedPropertiesList.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooSharedProperties.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooSharedProperties.h,v 1.3 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TObject.h" 1
// @(#)root/base:$Id: TObject.h 38832 2011-04-13 17:54:49Z rdm $
// Author: Rene Brun   26/12/94

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooSharedProperties.h" 2
# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TUUID.h" 1
// @(#)root/base:$Id: TUUID.h 27658 2009-02-28 05:34:57Z pcanal $
// Author: Fons Rademakers   30/9/2001

/*************************************************************************
 * Copyright (C) 1995-2001, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/




//////////////////////////////////////////////////////////////////////////
//                                                                      //
// TUUID                                                                //
//                                                                      //
// This class defines a UUID (Universally Unique IDentifier), also      //
// known as GUIDs (Globally Unique IDentifier). A UUID is 128 bits      //
// long, and if generated according to this algorithm, is either        //
// guaranteed to be different from all other UUIDs/GUIDs generated      //
// until 3400 A.D. or extremely likely to be different. UUIDs were      //
// originally used in the Network Computing System (NCS) and            //
// later in the Open Software Foundation's (OSF) Distributed Computing  //
// Environment (DCE).                                                   //
//                                                                      //
//////////////////////////////////////////////////////////////////////////
# 37 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TUUID.h"
// forward declaration
class TBuffer;
class TFile;
class TDirectory;
class TInetAddress;
class TDatime;

class TUUID {

protected:
   UInt_t fUUIDIndex; //!index in the list of UUIDs in TProcessUUID
   UInt_t fTimeLow; // 60 bit time, lower 32 bits
   UShort_t fTimeMid; // middle 16 time bits
   UShort_t fTimeHiAndVersion; // high 12 time bits + 4 UUID version bits
   UChar_t fClockSeqHiAndReserved; // high 6 clock bits + 2 bits reserved
   UChar_t fClockSeqLow; // low 8 clock bits
   UChar_t fNode[6]; // 6 node id bytes

   struct uuid_time_t {
      UInt_t high;
      UInt_t low;
   };

   Int_t CmpTime(uuid_time_t *t1, uuid_time_t *t2);
   void Format(UShort_t clockseq, uuid_time_t ts);
   void GetNodeIdentifier();
   void GetCurrentTime(uuid_time_t *timestamp);
   void GetSystemTime(uuid_time_t *timestamp);
   void GetRandomInfo(UChar_t seed[16]);
   void SetFromString(const char *uuid_str);

public:
   TUUID();
   TUUID(const char *uuid_str);
   virtual ~TUUID();

   const char *AsString() const;
   Int_t Compare(const TUUID &u) const;
   UShort_t Hash() const;
   void Print() const;
   TInetAddress GetHostAddress() const;
   TDatime GetTime() const;
   void GetUUID(UChar_t uuid[16]) const;
   void SetUUID(const char *uuid_str);
   UInt_t GetUUIDNumber() const { return fUUIDIndex; }
   void SetUUIDNumber(UInt_t index) { fUUIDIndex = index; }

   void StreamerV1(TBuffer &b);
   void FillBuffer(char *&buffer);
   void ReadBuffer(char *&buffer);
   Int_t Sizeof() const { return 18; }

   private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return TUUID::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { TUUID::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TUUID.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 89; } // Universally Unique IDentifier
};


inline TBuffer &operator>>(TBuffer &buf, TUUID &uuid)
{ uuid.Streamer(buf); return buf; }

// Not inlined in order to avoid const casted away warning in user code.  
TBuffer &operator<<(TBuffer &buf, const TUUID &uuid);

inline Bool_t operator==(const TUUID &u1, const TUUID &u2)
{ return (!u1.Compare(u2)) ? kTRUE : kFALSE; }

inline Bool_t operator!=(const TUUID &u1, const TUUID &u2)
{ return !(u1 == u2); }
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooSharedProperties.h" 2

class RooSharedProperties : public TObject {
public:

  RooSharedProperties() ;
  RooSharedProperties(const char* uuidstr) ;
  virtual ~RooSharedProperties() ;
  Bool_t operator==(const RooSharedProperties& other) ;

  virtual RooSharedProperties* clone() = 0 ;

  virtual void Print(Option_t* opts=0) const ;

  void increaseRefCount() { _refCount++ ; }
  void decreaseRefCount() { if (_refCount>0) _refCount-- ; }
  Int_t refCount() const { return _refCount ; }

  void setInSharedList() { _inSharedList = kTRUE ; }
  Bool_t inSharedList() const { return _inSharedList ; }

protected:

  TUUID _uuid ; // Unique object ID
  Int_t _refCount ; //! Use count 
  Int_t _inSharedList ; //! Is in shared list

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return RooSharedProperties::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooSharedProperties::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooSharedProperties.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 47; } // Abstract interface for shared property implementations
};
# 23 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooSharedPropertiesList.h" 2

class RooSharedPropertiesList : public TObject {
public:

  RooSharedPropertiesList() ;
  virtual ~RooSharedPropertiesList() ;

  RooSharedProperties* registerProperties(RooSharedProperties*, Bool_t canDeleteIncoming=kTRUE) ;
  void unregisterProperties(RooSharedProperties*) ;

protected:

  RooRefCountList _propList ;

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 0; } static void Dictionary(); virtual TClass *IsA() const { return RooSharedPropertiesList::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooSharedPropertiesList::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooSharedPropertiesList.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 37; } // Manager for shared properties among clones of certain RooAbsArg-derived types
};
# 28 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooRealVar.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooRealVarSharedProperties.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooRealVarSharedProperties.h,v 1.3 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/



# 1 "/hpc/software/tier3/osg/slc5_amd64_gcc472/lcg/root/5.34.03-cms4/include/TObject.h" 1
// @(#)root/base:$Id: TObject.h 38832 2011-04-13 17:54:49Z rdm $
// Author: Rene Brun   26/12/94

/*************************************************************************
 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers.               *
 * All rights reserved.                                                  *
 *                                                                       *
 * For the licensing terms see $ROOTSYS/LICENSE.                         *
 * For the list of contributors see $ROOTSYS/README/CREDITS.             *
 *************************************************************************/
# 20 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooRealVarSharedProperties.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooSharedProperties.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooSharedProperties.h,v 1.3 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 21 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooRealVarSharedProperties.h" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooLinkedList.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooLinkedList.h,v 1.15 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 22 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooRealVarSharedProperties.h" 2

class RooRealVarSharedProperties : public RooSharedProperties {
public:

  RooRealVarSharedProperties() ;
  RooRealVarSharedProperties(const RooRealVarSharedProperties&) ;
  RooRealVarSharedProperties(const char* uuidstr) ;
  virtual ~RooRealVarSharedProperties() ;

  RooSharedProperties* clone() { return new RooRealVarSharedProperties(*this) ; }

protected:

  friend class RooRealVar ;

  RooLinkedList _altBinning ; // Optional alternative ranges and binnings

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 1; } static void Dictionary(); virtual TClass *IsA() const { return RooRealVarSharedProperties::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooRealVarSharedProperties::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooRealVarSharedProperties.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 39; } // Shared properties of a RooRealVar clone set
};
# 29 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooRealVar.h" 2

class RooArgSet ;
class RooErrorVar ;
class RooVectorDataStore ;

class RooRealVar : public RooAbsRealLValue {
public:
  // Constructors, assignment etc.
  RooRealVar() ;
  RooRealVar(const char *name, const char *title,
      Double_t value, const char *unit= "") ;
  RooRealVar(const char *name, const char *title, Double_t minValue,
    Double_t maxValue, const char *unit= "");
  RooRealVar(const char *name, const char *title, Double_t value,
    Double_t minValue, Double_t maxValue, const char *unit= "") ;
  RooRealVar(const RooRealVar& other, const char* name=0);
  virtual TObject* clone(const char* newname) const { return new RooRealVar(*this,newname); }
  virtual ~RooRealVar();

  // Parameter value and error accessors
  virtual Double_t getValV(const RooArgSet* nset=0) const ;
  virtual void setVal(Double_t value);
  inline Double_t getError() const { return _error>=0?_error:0. ; }
  inline Bool_t hasError(Bool_t allowZero=kTRUE) const { return allowZero ? (_error>=0) : (_error>0) ; }
  inline void setError(Double_t value) { _error= value ; }
  inline void removeError() { _error = -1 ; }
  inline Double_t getAsymErrorLo() const { return _asymErrLo<=0?_asymErrLo:0. ; }
  inline Double_t getAsymErrorHi() const { return _asymErrHi>=0?_asymErrHi:0. ; }
  inline Bool_t hasAsymError(Bool_t allowZero=kTRUE) const { return allowZero ? ((_asymErrHi>=0 && _asymErrLo<=0)) : ((_asymErrHi>0 && _asymErrLo<0)) ; }
  inline void removeAsymError() { _asymErrLo = 1 ; _asymErrHi = -1 ; }
  inline void setAsymError(Double_t lo, Double_t hi) { _asymErrLo = lo ; _asymErrHi = hi ; }
  inline Double_t getErrorLo() const { return _asymErrLo<=0?_asymErrLo:-1*_error ; }
  inline Double_t getErrorHi() const { return _asymErrHi>=0?_asymErrHi:_error ; }

  RooErrorVar* errorVar() const ;

  // Set/get finite fit range limits
  void setMin(const char* name, Double_t value) ;
  void setMax(const char* name, Double_t value) ;
  void setRange(const char* name, Double_t min, Double_t max) ;
  void setRange(const char* name, RooAbsReal& min, RooAbsReal& max) ;
  inline void setMin(Double_t value) { setMin(0,value) ; }
  inline void setMax(Double_t value) { setMax(0,value) ; }
  inline void setRange(Double_t min, Double_t max) { setRange(0,min,max) ; }
  inline void setRange(RooAbsReal& min, RooAbsReal& max) { setRange(0,min,max) ; }

  void setBins(Int_t nBins, const char* name=0) { setBinning(RooUniformBinning(getMin(name),getMax(name),nBins),name) ; }
  void setBinning(const RooAbsBinning& binning, const char* name=0) ;

  // RooAbsRealLValue implementation
  Bool_t hasBinning(const char* name) const ;
  const RooAbsBinning& getBinning(const char* name=0, Bool_t verbose=kTRUE, Bool_t createOnTheFly=kFALSE) const ;
  RooAbsBinning& getBinning(const char* name=0, Bool_t verbose=kTRUE, Bool_t createOnTheFly=kFALSE) ;

  // Set infinite fit range limits
  inline void removeMin(const char* name=0) { getBinning(name).setMin(-RooNumber::infinity()) ; }
  inline void removeMax(const char* name=0) { getBinning(name).setMax(RooNumber::infinity()) ; }
  inline void removeRange(const char* name=0) { getBinning(name).setRange(-RooNumber::infinity(),RooNumber::infinity()) ; }

  // I/O streaming interface (machine readable)
  virtual Bool_t readFromStream(std::istream& is, Bool_t compact, Bool_t verbose=kFALSE) ;
  virtual void writeToStream(std::ostream& os, Bool_t compact) const ;

  // We implement a fundamental type of AbsArg that can be stored in a dataset
  inline virtual Bool_t isFundamental() const { return kTRUE; }

  // Force to be a leaf-node of any expression tree, even if we have (shape) servers
  virtual Bool_t isDerived() const {
    // Does value or shape of this arg depend on any other arg?
    return (_serverList.GetSize()>0 || _proxyList.GetSize()>0)?kTRUE:kFALSE;
  }

  // Printing interface (human readable)
  virtual void printValue(std::ostream& os) const ;
  virtual void printExtras(std::ostream& os) const ;
  virtual void printMultiline(std::ostream& os, Int_t contents, Bool_t verbose=kFALSE, TString indent="") const ;
  virtual Int_t defaultPrintContents(Option_t* opt) const ;


  TString* format(const RooCmdArg& formatArg) const ;
  TString* format(Int_t sigDigits, const char *options) const ;

  static void printScientific(Bool_t flag=kFALSE) ;
  static void printSigDigits(Int_t ndig=5) ;

  using RooAbsRealLValue::operator= ;

  void deleteSharedProperties() ;

  void copyCacheFast(const RooRealVar& other, Bool_t setValDirty=kTRUE) { _value = other._value ; if (setValDirty) setValueDirty() ; }

  protected:

  static Bool_t _printScientific ;
  static Int_t _printSigDigits ;

  virtual void setVal(Double_t value, const char* rangeName) ;

  friend class RooAbsRealLValue ;
  virtual void setValFast(Double_t value) { _value = value ; setValueDirty() ; }


  virtual Double_t evaluate() const { return _value ; } // dummy because we overloaded getVal()
  virtual void copyCache(const RooAbsArg* source, Bool_t valueOnly=kFALSE, Bool_t setValDirty=kTRUE) ;
  virtual void attachToTree(TTree& t, Int_t bufSize=32000) ;
  virtual void attachToVStore(RooVectorDataStore& vstore) ;
  virtual void fillTreeBranch(TTree& t) ;

  Double_t chopAt(Double_t what, Int_t where) const ;

  Double_t _error; // Symmetric error associated with current value
  Double_t _asymErrLo ; // Low side of asymmetric error associated with current value
  Double_t _asymErrHi ; // High side of asymmetric error associated with current value
  RooAbsBinning* _binning ;
  RooLinkedList _altNonSharedBinning ; // Non-shareable alternative binnings

  inline RooRealVarSharedProperties* sharedProp() const {
    if (!_sharedProp) {
      _sharedProp = (RooRealVarSharedProperties*) _sharedPropList.registerProperties(new RooRealVarSharedProperties()) ;
    }
    return _sharedProp ;
  }

  static RooSharedPropertiesList _sharedPropList; // List of properties shared among clone sets 
  static RooRealVarSharedProperties _nullProp ; // Null property
  mutable RooRealVarSharedProperties* _sharedProp ; //! Shared properties associated with this instance

  private: static TClass *fgIsA; public: static TClass *Class(); static const char *Class_Name(); static Version_t Class_Version() { return 5; } static void Dictionary(); virtual TClass *IsA() const { return RooRealVar::Class(); } virtual void ShowMembers(TMemberInspector&); virtual void Streamer(TBuffer&); void StreamerNVirtual(TBuffer&ClassDef_StreamerNVirtual_b) { RooRealVar::Streamer(ClassDef_StreamerNVirtual_b); } static const char *DeclFileName() { return "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooRealVar.h"; } static int ImplFileLine(); static const char *ImplFileName(); static int DeclFileLine() { return 156; } // Real-valued variable 
};
# 35 "/scratch/condor/dir_19652/./RooStepBernstein.cxx" 2
# 1 "/software/tier3/osg/slc5_amd64_gcc472/lcg/roofit/5.34.04-cms2//include/RooArgList.h" 1
/*****************************************************************************
 * Project: RooFit                                                           *
 * Package: RooFitCore                                                       *
 *    File: $Id: RooArgList.h,v 1.14 2007/05/11 09:11:30 verkerke Exp $
 * Authors:                                                                  *
 *   WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu       *
 *   DK, David Kirkby,    UC Irvine,         dkirkby@uci.edu                 *
 *                                                                           *
 * Copyright (c) 2000-2005, Regents of the University of California          *
 *                          and Stanford University. All rights reserved.    *
 *                                                                           *
 * Redistribution and use in source and binary forms,                        *
 * with or without modification, are permitted according to the terms        *
 * listed in LICENSE (http://roofit.sourceforge.net/license.txt)             *
 *****************************************************************************/
# 36 "/scratch/condor/dir_19652/./RooStepBernstein.cxx" 2

using namespace std;




//_____________________________________________________________________________
RooStepBernstein::RooStepBernstein()
{
}


//_____________________________________________________________________________
RooStepBernstein::RooStepBernstein(const char* name, const char* title,
       RooAbsReal& x, RooAbsReal& step_thresh,
       const RooArgList& coefList):
  RooAbsPdf(name, title),
  _x("x", "Dependent", this, x),
  _stepThresh("stepThresh","value where step function changes",this,step_thresh),
  _coefList("coefficients","List of coefficients",this)
{
  // Constructor
  TIterator* coefIter = coefList.createIterator() ;
  RooAbsArg* coef ;
  while((coef = (RooAbsArg*)coefIter->Next())) {
    if (!dynamic_cast<RooAbsReal*>(coef)) {
      cout << "RooStepBernstein::ctor(" << GetName() << ") ERROR: coefficient " << coef->GetName()
    << " is not of type RooAbsReal" << endl ;
      assert(0) ;
    }
    _coefList.add(*coef) ;
  }
  delete coefIter ;
}



//_____________________________________________________________________________
RooStepBernstein::RooStepBernstein(const RooStepBernstein& other, const char* name) :
  RooAbsPdf(other, name),
  _x("x", this, other._x),
  _stepThresh("stepThresh",this,other._stepThresh),
  _coefList("coefList",this,other._coefList)
{
}


//_____________________________________________________________________________
Double_t RooStepBernstein::evaluate() const
{
  // now xmin is stepThresh and we return when less than stepThresh
  // warning! this means we are only useful as a PDF when we are convoluted with
  // something that's positive definite!!!!!!
  Double_t xmin = _x.min(); // old  

  //Double_t xmin = _stepThresh;
  Double_t x = (_x - xmin) / (_x.max() - xmin); // rescale to [0,1] where 0 is on stepThresh
  if( x < _stepThresh) return 0; // lazy return

  x = (x - _stepThresh)/(1.0-_stepThresh); // now we get the full polynomial  

  Int_t degree = _coefList.getSize() - 1; // n+1 polys of degree n
  RooFIter iter = _coefList.fwdIterator();

  if(degree == 0) {

    return ((RooAbsReal *)iter.next())->getVal();

  } else if(degree == 1) {

    Double_t a0 = ((RooAbsReal *)iter.next())->getVal(); // c0
    Double_t a1 = ((RooAbsReal *)iter.next())->getVal() - a0; // c1 - c0
    return a1 * x + a0;

  } else if(degree == 2) {

    Double_t a0 = ((RooAbsReal *)iter.next())->getVal(); // c0
    Double_t a1 = 2 * (((RooAbsReal *)iter.next())->getVal() - a0); // 2 * (c1 - c0)
    Double_t a2 = ((RooAbsReal *)iter.next())->getVal() - a1 - a0; // c0 - 2 * c1 + c2
    return (a2 * x + a1) * x + a0;

  } else if(degree > 2) {

    Double_t t = x;
    Double_t s = 1 - x;

    Double_t result = ((RooAbsReal *)iter.next())->getVal() * s;
    for(Int_t i = 1; i < degree; i++) {
      result = (result + t * TMath::Binomial(degree, i) * ((RooAbsReal *)iter.next())->getVal()) * s;
      t *= x;
    }
    result += t * ((RooAbsReal *)iter.next())->getVal();

    return result;
  }

  // in case list of arguments passed is empty
  return TMath::SignalingNaN();
}


//_____________________________________________________________________________
Int_t RooStepBernstein::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName) const
{
  // No analytical calculation available (yet) of integrals over subranges
  if (rangeName && strlen(rangeName)) {
    return 0 ;
  }

  if (matchArgs(allVars, analVars, _x)) return 1;
  return 0;
}


//_____________________________________________________________________________
Double_t RooStepBernstein::analyticalIntegral(Int_t code, const char* rangeName) const
{
  assert(code==1) ;
  // since we are basically squishing the bernstein polynomial to after some
  // threshold the normalization only need be modified by the range in which
  // the function is zero
  Double_t xmin = _x.min(rangeName);
  Double_t step = _stepThresh;
  Double_t xmax = _x.max(rangeName);
  Int_t degree= _coefList.getSize()-1; // n+1 polys of degree n
  Double_t norm(0) ;

  RooFIter iter = _coefList.fwdIterator() ;
  Double_t temp=0;
  for (int i=0; i<=degree; ++i){
    // for each of the i Bernstein basis polynomials
    // represent it in the 'power basis' (the naive polynomial basis)
    // where the integral is straight forward.
    temp = 0;
    for (int j=i; j<=degree; ++j){ // power basis
      temp += pow(-1.,j-i) * TMath::Binomial(degree, j) * TMath::Binomial(j,i) / (j+1);
    }
    temp *= ((RooAbsReal*)iter.next())->getVal(); // include coeff
    norm += temp; // add this basis's contribution to total
  }

  norm *= xmax-(1.0+step)*xmin;
  return norm;
}
# 4 "/tmp/rootcint_85GekZ.h" 2
# 1 "/scratch/condor/dir_19652/RooStepBernstein_cxx_ACLiC_linkdef.h" 1
// File Automatically generated by the ROOT Script Compiler 



#pragma link C++ nestedclasses;
#pragma link C++ nestedtypedefs;

#pragma link C++ defined_in /scratch/condor/dir_19652/./RooStepBernstein.h;
#pragma link C++ defined_in "/scratch/condor/dir_19652/./RooStepBernstein.cxx";
# 4 "/tmp/rootcint_85GekZ.h" 2
# 2 "/scratch/condor/dir_19652/QCBAeV_cint.cxx" 2
